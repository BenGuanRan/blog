<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>了解安卓开发</title>
      <link href="/blog/2023/05/22/%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91/"/>
      <url>/blog/2023/05/22/%E4%BA%86%E8%A7%A3%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="了解安卓开发"><a href="#了解安卓开发" class="headerlink" title="了解安卓开发"></a>了解安卓开发</h1><h2 id="Log类"><a href="#Log类" class="headerlink" title="Log类"></a>Log类</h2><p>级别：</p><ul><li>e：错误</li><li>w：警告</li><li>i：一般</li><li>d：调试</li><li>v：冗余</li></ul><h2 id="APP工程目录结构"><a href="#APP工程目录结构" class="headerlink" title="APP工程目录结构"></a>APP工程目录结构</h2><p>App工程分为两个层次，第一个层次是项目，第二个层次是模块，模块依附于项目，每个项目至少有一个模块，也能拥有多个模块。一般说的变异运行APP指的是运行某个模块，而非整个项目，因为模块才对应实际的APP。</p><p>其中目录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- app</span><br><span class="line">    - manifests：是APP的运行配置文件</span><br><span class="line">    - java：里面有三个com.muapp.exapmle包，只有第一个是源文件，其余的是测试文件</span><br><span class="line">    - res：资源文件</span><br><span class="line">        - drawable：图标</span><br><span class="line">        - layout：布局文件</span><br><span class="line">        - mipmap：启动图标</span><br><span class="line">        - values：设置常量，例如颜色，等</span><br><span class="line">        - themes：主题</span><br><span class="line">- Gradle Scripts</span><br><span class="line">    - build.dradle：全局配置，描述编译规则</span><br><span class="line">    - build.dradle：模块配置，描述编译规则</span><br><span class="line">    - proguard-rules.pro：用于描述java代码的混淆规则，有利于提升安卓应用的安全性</span><br><span class="line">    - gradsel.properties：用于配置编译工程的命令行参数</span><br><span class="line">    - settings.gradel：配置了需要编译哪些模块</span><br><span class="line">    - local.properties：项目的本地配置文件，用于描述电脑的环境配置，包括SDK本地路径，NDK本地路径等</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>什么是Gradle，类似于webpack，是一种自动化构建工具，用于将代码应用打包，部署等工作。</p><h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><p>本质上Activity就是一个页面组件，可以理解为提供一个屏幕，用户再上面完成交互。</p><h3 id="创建与跳转"><a href="#创建与跳转" class="headerlink" title="创建与跳转"></a>创建与跳转</h3><p>完整的页面创建需要经历一下三个步骤：</p><ul><li>在layout目录下创建XML文件</li><li>创建与XML文件对应的java代码</li><li>在AndroidManifest.xml中注册页面配置</li></ul><h2 id="简单控件"><a href="#简单控件" class="headerlink" title="简单控件"></a>简单控件</h2><h3 id="设置文本内容的两种方式"><a href="#设置文本内容的两种方式" class="headerlink" title="设置文本内容的两种方式"></a>设置文本内容的两种方式</h3><ul><li>XML文件中属性android:text设置文本</li><li>Java代码中通过setText方式设置文本</li></ul><h3 id="设置字体大小"><a href="#设置字体大小" class="headerlink" title="设置字体大小"></a>设置字体大小</h3><ul><li>textSize</li><li>setTextSize<br>单位尺寸的一些知识：</li><li>px：逻辑像素</li><li>Resolution：分辨率</li><li>Dpi：像素密度</li></ul><h3 id="设置文本颜色"><a href="#设置文本颜色" class="headerlink" title="设置文本颜色"></a>设置文本颜色</h3><ul><li>textColor</li><li>setTextColor<br>Color类来表示颜色，绿色：Color.GREEN</li></ul><h3 id="设置视图的宽高"><a href="#设置视图的宽高" class="headerlink" title="设置视图的宽高"></a>设置视图的宽高</h3><h2 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h2><p>在安卓开发中，我们使用一些常见的单位来测量和布局屏幕上的元素。以下是一些常见的安卓开发单位：</p><ol><li><p>像素（Pixel，px）：像素是屏幕上最小的可见点。在安卓开发中，屏幕上的元素通常以像素为单位进行测量和定位。</p></li><li><p>密度无关像素（Density Independent Pixel，dp或dip）：dp是一种与设备密度无关的单位，它确保了在不同的屏幕密度下元素的尺寸保持一致。在不同的设备上，1dp会根据设备的屏幕密度进行自适应调整。</p></li><li><p>独立比例像素（Scale Independent Pixel，sp）：sp与dp类似，但在字体大小方面更为常用。它会根据用户的字体大小首选项进行自适应调整，确保字体在不同设备上具有一致的可读性。</p></li><li><p>英寸（Inch，in）：英寸是长度单位，用于测量屏幕的物理尺寸。它通常与屏幕分辨率结合使用，以计算像素密度等信息。</p></li><li><p>毫米（Millimeter，mm）：毫米也是一种长度单位，常用于测量设备的物理尺寸。</p></li><li><p>点（Point，pt）：点是一种常见的打印和排版单位，也可以在安卓开发中使用。它与像素之间存在一定的关系，但在不同的设备上可能会有一些差异。</p></li></ol><p>在安卓开发中，使用合适的单位可以帮助我们实现屏幕适配和元素布局的灵活性和一致性。根据具体的需求和设计，选择合适的单位可以确保应用程序在不同的设备上以一致的方式呈现。</p><h2 id="ViewGroup"><a href="#ViewGroup" class="headerlink" title="ViewGroup"></a>ViewGroup</h2><h3 id="LinearLayout线性布局"><a href="#LinearLayout线性布局" class="headerlink" title="LinearLayout线性布局"></a>LinearLayout线性布局</h3><p>属性介绍：</p><ul><li>origentation：布局中组件的排列方式</li><li>gravity：组件中子元素的对其方式</li><li>layout_gravity：该组件在父容器中的对其方式</li><li>layout_width：布局的宽度</li><li>layout_height：高度</li><li>weight：权重</li></ul><h3 id="RelativeLayout相对布局"><a href="#RelativeLayout相对布局" class="headerlink" title="RelativeLayout相对布局"></a>RelativeLayout相对布局</h3><p>可以相对于父级也可以相对于兄弟元素。</p><h3 id="TableLayout表格布局"><a href="#TableLayout表格布局" class="headerlink" title="TableLayout表格布局"></a>TableLayout表格布局</h3><h3 id="FrameLayout帧布局"><a href="#FrameLayout帧布局" class="headerlink" title="FrameLayout帧布局"></a>FrameLayout帧布局</h3><h3 id="GridLayout网格布局"><a href="#GridLayout网格布局" class="headerlink" title="GridLayout网格布局"></a>GridLayout网格布局</h3><p>常用的属性：</p><ul><li>android:layout_row：行索引</li><li>android:layout_column：列索引</li><li>android:layout_rowSpan：组件跨域的行数</li><li>android:layout_gravity：组件在网格中的对其方式</li><li>android:layout_rowCount：设置行数</li></ul><h2 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h2><p>Activity表现为四种状态：</p><ul><li>活动状态Active：Activity在用户界面中处于最上层，完全能被用户看到，能够与用户进行交互。</li><li>暂停状态Pause：Activity在界面上被部分遮挡，不再处于用户界面的最上层，且不能够与用户进行交互。(如弹出选择框时)</li><li>停止状态Stop：Activity被其他Activity全部遮挡，界面完全不能被用户看到。(如玩游戏时来电了)</li><li>非活动状态Dead：Activity没有启动或者被finish()。<br>随着Activity自身状态的变化，Android系统会调用不同的<br>事件回调函数(7个)：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span>; </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span>; <span class="comment">// 显示在屏幕上时</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRestart</span><span class="params">()</span>; <span class="comment">// stop状态进入start状态</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">()</span>; <span class="comment">// 用户可以交互时</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onPause</span><span class="params">()</span>; <span class="comment">// 弹窗</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">()</span>; <span class="comment">// 玩游戏来电话</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span>; <span class="comment">// 销毁</span></span><br></pre></td></tr></table></figure><a href="https://imgse.com/i/p9bvVTH"><img src="https://s1.ax1x.com/2023/05/26/p9bvVTH.png" alt="p9bvVTH.png"></a></li></ul><h2 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h2><h3 id="Stander（默认模式）"><a href="#Stander（默认模式）" class="headerlink" title="Stander（默认模式）"></a>Stander（默认模式）</h3><p>每次调用Activity时都会创建一个新的实例，并将其放入活动栈中，无论Activity否存在，都会创建新的实例</p><h3 id="SingleTop（栈顶复用）"><a href="#SingleTop（栈顶复用）" class="headerlink" title="SingleTop（栈顶复用）"></a>SingleTop（栈顶复用）</h3><p>只有栈顶的Activity会复用，只更新意图（intent），不会重新创建新的实例</p><h3 id="SingleTask（栈内复用）"><a href="#SingleTask（栈内复用）" class="headerlink" title="SingleTask（栈内复用）"></a>SingleTask（栈内复用）</h3><p>于singleTop类似，只不过前者策略是：如果栈中存在目标Activity实例，则将任务栈中的在目标Activity实例之上的所有任务弹出。</p><h3 id="SignalInstance（全局唯一模式）"><a href="#SignalInstance（全局唯一模式）" class="headerlink" title="SignalInstance（全局唯一模式）"></a>SignalInstance（全局唯一模式）</h3><p>会为每个实例都创建一个任务栈，然后复用</p><h3 id="启动标志"><a href="#启动标志" class="headerlink" title="启动标志"></a>启动标志</h3><p>通过调用Intent类的setFlags()方法来设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FLAG_ACTIVITY_NEW_TASK：将Activity启动为一个新的任务。如果当前没有任务栈存在，则会创建一个新的任务栈，如果已经存在任务栈，则该Activity会被添加到已存在的任务栈中。</span><br><span class="line"></span><br><span class="line">FLAG_ACTIVITY_CLEAR_TOP：如果目标Activity已经在任务栈中存在，那么会将该Activity之上的所有Activity实例移除，并将该Activity置于栈顶。这样可以避免在同一个任务栈中创建多个相同的Activity实例。</span><br><span class="line"></span><br><span class="line">FLAG_ACTIVITY_SINGLE_TOP：如果目标Activity已经在任务栈的栈顶，那么不会创建新的Activity实例，而是调用目标Activity的onNewIntent()方法来传递新的Intent。</span><br><span class="line"></span><br><span class="line">FLAG_ACTIVITY_CLEAR_TASK：清除任务栈中的所有Activity实例，并且将目标Activity作为新的任务栈的栈底。</span><br><span class="line"></span><br><span class="line">FLAG_ACTIVITY_NO_HISTORY：启动Activity时，不在任务栈中保留该Activity的实例。当用户离开该Activity时，该Activity实例会被立即销毁。</span><br><span class="line"></span><br><span class="line">FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS：启动的Activity不会出现在最近任务列表中。</span><br></pre></td></tr></table></figure><h2 id="一些基本的组件"><a href="#一些基本的组件" class="headerlink" title="一些基本的组件"></a>一些基本的组件</h2><ul><li>TextView</li><li>ImageView<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ImageView iv=(ImageView)findViewById(R.id.imageView); iv.setImageResource(R.drawable.bg320_480);<span class="comment">//根据id值加载图片 iv.setVisibility( View.INVISIBLE );//图片不可见</span></span><br><span class="line">可见：View.VISIBLE注：VISIBLE值为<span class="number">0</span>，INVISIBLE为<span class="number">4</span></span><br></pre></td></tr></table></figure></li><li>Button<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加点击事件</span></span><br><span class="line">Button bt=(Button)findViewById(R.id.button); bt.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line"><span class="comment">// 代码</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>ImageButton</li><li>ToggleButton 打开和关闭的那种二状态按钮<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ToggleButton tb=(ToggleButton)findViewById(R.id.toggleButton); tb.setOnCheckedChangeListener(<span class="keyword">new</span> <span class="title class_">CompoundButton</span>.OnCheckedChangeListener()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCheckedChanged</span><span class="params">(CompoundButton buttonView, <span class="type">boolean</span> isChecked)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>( isChecked )&#123;</span><br><span class="line"><span class="comment">// 开关开启</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// 开关关闭</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>EditText<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EditText et=(EditText)findViewById(R.id.editText);</span><br><span class="line">et.setText(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">String msg=et.getText().toString();<span class="comment">//toString()转换为字符串</span></span><br></pre></td></tr></table></figure></li><li>RadioButton 单选按钮需归入一个Group，每个组中只有一个能选中。<br><a href="https://imgse.com/i/p9qpCUe"><img src="https://s1.ax1x.com/2023/05/26/p9qpCUe.png" alt="p9qpCUe.png"></a></li><li>CheckBox</li><li>Spinner下拉列表</li><li>ListView</li></ul><h2 id="Adapter适配器"><a href="#Adapter适配器" class="headerlink" title="Adapter适配器"></a>Adapter适配器</h2><p>适配器就是数据对于视图的一个转换映射<br>以ArrayAdapter为例：</p><ol><li>定义数据集<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] data = &#123;<span class="string">&quot;Item 1&quot;</span>, <span class="string">&quot;Item 2&quot;</span>, <span class="string">&quot;Item 3&quot;</span>, <span class="string">&quot;Item 4&quot;</span>, <span class="string">&quot;Item 5&quot;</span>&#125;;</span><br></pre></td></tr></table></figure></li><li>创建Adapter<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayAdapter&lt;String&gt; adapter = <span class="keyword">new</span> <span class="title class_">ArrayAdapter</span>&lt;&gt;(<span class="built_in">this</span>, android.R.layout.simple_list_item_1, data);</span><br><span class="line"><span class="comment">// 其中参数：上下文、一种自带的布局模式、数据集</span></span><br></pre></td></tr></table></figure></li><li>绑定适配器<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ListView</span> <span class="variable">listView</span> <span class="operator">=</span> findViewById(R.id.listView);</span><br><span class="line">listView.setAdapter(adapter);</span><br></pre></td></tr></table></figure></li></ol><h2 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h2><p>Intent是一种组件之间消息传递机制，他是一个动作的完整描述：包含了动作产生组件、接收组件和传递的数据信息。<br><a href="https://imgse.com/i/p9qeP1O"><img src="https://s1.ax1x.com/2023/05/26/p9qeP1O.png" alt="p9qeP1O.png"></a><br>主要用途：启动Activity、Service、发布广播</p><h2 id="Intent意图"><a href="#Intent意图" class="headerlink" title="Intent意图"></a>Intent意图</h2><p>是各个组件之间信息沟通的桥梁</p><h3 id="显示Intent"><a href="#显示Intent" class="headerlink" title="显示Intent"></a>显示Intent</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>, ActStartActivity.class);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><h3 id="隐式Intent"><a href="#隐式Intent" class="headerlink" title="隐式Intent"></a>隐式Intent</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">itt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">itt.setAction(Intent.ACTION_DIAL);</span><br><span class="line"><span class="comment">// 声明一个拨号的URI</span></span><br><span class="line"><span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(<span class="string">&quot;tel:&quot;</span> + PHONE_NUMBER);</span><br><span class="line">itt.setData(uri);</span><br><span class="line">startActivity(itt);</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h3 id="Intent传递消息"><a href="#Intent传递消息" class="headerlink" title="Intent传递消息"></a>Intent传递消息</h3><p>向下传递</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传递数据</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">itt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, ActStartActivity.class);</span><br><span class="line">itt.putExtra(<span class="string">&quot;main_msg&quot;</span>, <span class="string">&quot;这是一条来自Main的消息&quot;</span>);</span><br><span class="line">startActivity(itt);</span><br><span class="line"><span class="comment">// 接收数据</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">itt</span> <span class="operator">=</span> getIntent();</span><br><span class="line"><span class="keyword">if</span>(itt != <span class="literal">null</span> &amp;&amp; itt.hasExtra(<span class="string">&quot;main_msg&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> itt.getStringExtra(<span class="string">&quot;main_msg&quot;</span>);</span><br><span class="line">    <span class="type">TextView</span> <span class="variable">tv</span> <span class="operator">=</span> findViewById(R.id.receiver);</span><br><span class="line">    tv.setText(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向上传递<br>不想写了，略了</p><h2 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h2><p>广播分为：系统广播、用户自定义广播<br>使用步骤：</p><ol><li>定义广播接收器<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title class_">BroadcastReceiver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里处理接收到的广播消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>注册广播接收器<br>a. 静态注册 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyBroadcastReceiver</span> <span class="variable">receiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBroadcastReceiver</span>();</span><br><span class="line"><span class="type">IntentFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntentFilter</span>(<span class="string">&quot;com.example.    MY_ACTION&quot;</span>);</span><br><span class="line">context.registerReceiver(receiver, filter);</span><br></pre></td></tr></table></figure>b. 动态注册 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">&quot;.MyBroadcastReceiver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.MY_ACTION&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>创建广播消息<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">broadcastIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;com.example.MY_ACTION&quot;</span>);</span><br><span class="line">broadcastIntent.putExtra(<span class="string">&quot;extra_key&quot;</span>, <span class="string">&quot;extra_value&quot;</span>); <span class="comment">// 可选：添加额外的数据</span></span><br></pre></td></tr></table></figure></li><li>发送广播<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.sendBroadcast(broadcastIntent);</span><br></pre></td></tr></table></figure></li></ol><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>当用户播放音乐时，可以使用Service来实现后台音乐播放的功能。以下是一个简单的示例：</p><ol><li><p>创建一个MusicService类，该类继承自Service，并在其中实现音乐播放逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MusicService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MediaPlayer mediaPlayer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate();</span><br><span class="line">        <span class="comment">// 初始化MediaPlayer等操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">onStartCommand</span><span class="params">(Intent intent, <span class="type">int</span> flags, <span class="type">int</span> startId)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理从Activity传递过来的播放控制指令</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> intent.getAction();</span><br><span class="line">        <span class="keyword">if</span> (action.equals(<span class="string">&quot;play&quot;</span>)) &#123;</span><br><span class="line">            playMusic();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.equals(<span class="string">&quot;pause&quot;</span>)) &#123;</span><br><span class="line">            pauseMusic();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.equals(<span class="string">&quot;stop&quot;</span>)) &#123;</span><br><span class="line">            stopMusic();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> START_STICKY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">playMusic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 播放音乐的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pauseMusic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 暂停音乐的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">stopMusic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 停止音乐的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> IBinder <span class="title function_">onBind</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在AndroidManifest.xml文件中声明MusicService。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">&quot;.MusicService&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在Activity中通过Intent启动和控制音乐播放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动音乐播放服务</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, MusicService.class);</span><br><span class="line">startService(intent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送播放指令</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">playIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, MusicService.class);</span><br><span class="line">playIntent.setAction(<span class="string">&quot;play&quot;</span>);</span><br><span class="line">startService(playIntent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送暂停指令</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">pauseIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, MusicService.class);</span><br><span class="line">pauseIntent.setAction(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">startService(pauseIntent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送停止指令</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">stopIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, MusicService.class);</span><br><span class="line">stopIntent.setAction(<span class="string">&quot;stop&quot;</span>);</span><br><span class="line">startService(stopIntent);</span><br></pre></td></tr></table></figure></li></ol><p>通过上述示例，您可以创建一个Service来处理音乐播放的逻辑，并通过启动服务和发送指令的方式控制音乐的播放、暂停和停止。即使在用户切换到其他应用程序或锁定屏幕时，音乐播放服务仍可在后台持续运行。</p><p>如果您希望通过广播与Service进行交互，可以使用以下步骤：</p><ol><li><p>定义广播接收器类：创建一个继承自<code>BroadcastReceiver</code>的广播接收器类，用于接收来自Activity或其他组件发送的广播消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MusicControlReceiver</span> <span class="keyword">extends</span> <span class="title class_">BroadcastReceiver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里处理接收到的广播消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> intent.getAction();</span><br><span class="line">        <span class="keyword">if</span> (action.equals(<span class="string">&quot;play&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 处理播放音乐的逻辑</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.equals(<span class="string">&quot;pause&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 处理暂停音乐的逻辑</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action.equals(<span class="string">&quot;stop&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 处理停止音乐的逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注册广播接收器：在Service的<code>onCreate()</code>方法中注册广播接收器，以便Service能够接收广播消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MusicService</span> <span class="keyword">extends</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MusicControlReceiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate();</span><br><span class="line">        <span class="comment">// 初始化操作和其他逻辑</span></span><br><span class="line">        receiver = <span class="keyword">new</span> <span class="title class_">MusicControlReceiver</span>();</span><br><span class="line">        <span class="type">IntentFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntentFilter</span>();</span><br><span class="line">        filter.addAction(<span class="string">&quot;play&quot;</span>);</span><br><span class="line">        filter.addAction(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        filter.addAction(<span class="string">&quot;stop&quot;</span>);</span><br><span class="line">        registerReceiver(receiver, filter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他方法和逻辑 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        <span class="comment">// 在Service销毁时注销广播接收器</span></span><br><span class="line">        unregisterReceiver(receiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在Activity中发送广播消息：在需要控制音乐播放的地方，发送相应的广播消息给Service。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送播放指令</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">playIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;play&quot;</span>);</span><br><span class="line">sendBroadcast(playIntent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送暂停指令</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">pauseIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">sendBroadcast(pauseIntent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送停止指令</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">stopIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;stop&quot;</span>);</span><br><span class="line">sendBroadcast(stopIntent);</span><br></pre></td></tr></table></figure></li></ol><p>通过上述步骤，您可以通过广播消息在Activity和Service之间进行交互。当Activity发送广播消息时，Service的广播接收器将接收到相应的消息并执行相应的操作，以控制音乐播放。这种方式可以实现跨组件的通信和控制。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nextjs基本特性</title>
      <link href="/blog/2023/05/09/Nextjs%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7/"/>
      <url>/blog/2023/05/09/Nextjs%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="Layouts布局"><a href="#Layouts布局" class="headerlink" title="Layouts布局"></a>Layouts布局</h2><p>当页面有多个地方需要复用时，例如header、nav、footer等，这时，就可以写一个高阶组件，来对现有组件进行修饰，具体例子如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">AddHeader</span>(<span class="params">Component</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Header<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Component</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述实例AddHeader，作为一个高阶组件，对传入的组件进行一个修饰，从而使得所有传入的组件上面都会添加一个header。<br>其他组件使用示例如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> addHeader <span class="keyword">from</span> <span class="string">&#x27;../utils/addHeader&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Home</span> = <span class="title function_">addHeader</span>(<span class="function">(<span class="params">&#123; value &#125;: &#123; value: string &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>index<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&#x27;/posts/home&#x27;</span>&gt;</span>&#123;value&#125;<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&#x27;/ssr&#x27;</span>&gt;</span>进入SSR模式<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Button</span> <span class="attr">value</span>=<span class="string">&#123;</span>&#x27;<span class="attr">点击</span>&#x27;&#125;&gt;</span><span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Home</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getStaticProps</span>(<span class="params">context: any</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">value</span>: <span class="string">&#x27;静态生成传值&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Image组件与图片优化"><a href="#Image组件与图片优化" class="headerlink" title="Image组件与图片优化"></a>Image组件与图片优化</h2><p>Nextjs中Image组件是DOM中Img标签的一个扩展，其中提供一些性能优化，有利于三大核心指标（LCP最大内容元素可见时间、FID首次输入延迟、CLS视觉稳定性）优化。<br>其中内置优化包括：</p><ul><li>提高性能：始终使用现代图像格式为每个设备提供正确大小的图像。</li><li>视觉稳定性：自动防止累积布局偏移。</li><li>更快的页面加载：图像只有在进入视口时才加载，带有可选的模糊占位符</li><li>资产灵活性：根据需要调整图像大小，即使是存储在远程服务器上的图像<br>其中一些属性值如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">src：需要显示的图像的路径。这个属性是必需的。</span><br><span class="line"></span><br><span class="line">alt：图像的描述文字。这个属性是必需的，因为它提高了可访问性，让屏幕阅读器用户能够理解图像的内容。</span><br><span class="line"></span><br><span class="line">width 和 height：图像的显示宽度和高度。这些属性是必需的，因为它们提供了图像的尺寸信息，以便在图像加载之前为其分配空间。在使用自适应图像时，可以省略这些属性，因为 Image 组件会自动根据图像的原始大小计算宽度和高度。</span><br><span class="line"></span><br><span class="line">layout：指定图像的布局方式。可选的值有fill，fixed，intrinsic和responsive。默认值为responsive，表示图像的宽度和高度会自动根据容器的大小进行调整。如果使用fill布局，则图像会自动缩放以填满其容器。如果使用fixed布局，则图像会以其原始大小显示。如果使用intrinsic布局，则图像会在保持其宽高比的同时，缩放以适应其容器。详细使用方法可参考官方文档</span><br><span class="line"></span><br><span class="line">objectFit：指定如何缩放和裁剪图像以适应其容器。可选的值有fill、contain、cover、none、scale-down。默认为cover。详细使用方法可参考官方文档</span><br><span class="line"></span><br><span class="line">priority：指定图像的优先级。可选的值为true或false。如果设置为true，则图像会在页面加载时尽可能快地加载。默认值为false。</span><br><span class="line"></span><br><span class="line">loading：指定图像的加载方式。可选的值有eager、lazy和auto。默认为lazy，表示图像会在用户滚动到它们时加载。如果使用eager，则图像会在页面加载时立即加载。如果使用auto，则 Image 组件会根据用户的浏览器和设备自动选择最佳的加载方式。</span><br></pre></td></tr></table></figure></li></ul><h2 id="内置Script组件"><a href="#内置Script组件" class="headerlink" title="内置Script组件"></a>内置Script组件</h2><p>在Next中内置了script组件，我们可以这样引入</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Script</span> <span class="keyword">from</span> <span class="string">&#x27;next/script&#x27;</span></span><br></pre></td></tr></table></figure><p>使用next&#x2F;script，我们可以使用策略属性决定何时加载第三方脚本，相应策略如下：</p><ul><li>afterInteractive(default)：脚本将在页面交互后加载。这是默认的引入策略，适用于大多数情况。脚本将在页面内容加载完成后才开始加载，以确保不会阻塞页面的呈现和交互。</li><li>beforeInteractive：脚本将在页面交互前尽早加载。使用这个策略，脚本会尽早加载，但可能会阻塞页面的呈现和交互。如果脚本很重要且需要尽早执行，可以选择这个策略。</li><li>lazyOnload：脚本在获取所有资源后以及空闲时间加载。<br><strong>注意：该组件的src只能引入public文件夹下的静态js文件。</strong></li></ul><p>Inline Script</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Script</span>&gt;</span><br><span class="line">  &#123;<span class="string">`</span></span><br><span class="line"><span class="string">    // 这是自定义的JavaScript代码</span></span><br><span class="line"><span class="string">    alert(&#x27;Hello, world!&#x27;);</span></span><br><span class="line"><span class="string">  `</span>&#125;</span><br><span class="line">&lt;/<span class="title class_">Script</span>&gt;</span><br></pre></td></tr></table></figure><p>必须要定义id属性，nextjs才能跟踪优化脚本</p><h2 id="静态文件服务"><a href="#静态文件服务" class="headerlink" title="静态文件服务"></a>静态文件服务</h2><p>public 目录下存放的静态文件的对外访问路径以 (&#x2F;) 作为起始路径。<br>public 目录下存放的静态文件的对外访问路径以 (&#x2F;) 作为起始路径。</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>在 Next.js 中，可以使用环境变量来配置应用程序的行为。Next.js 提供了一种简便的方式来设置和使用环境变量。<br>在 Next.js 项目中，可以在根目录下创建一个名为 <strong>.env.local</strong> 的文件。这是一个本地环境变量文件，用于存储私密或特定于本地开发环境的变量。<br>在 .env.local 文件中，按照 <strong>KEY&#x3D;VALUE</strong> 的格式定义环境变量。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">API_KEY=abc123</span><br><span class="line">API_URL=https://api.example.com</span><br></pre></td></tr></table></figure><p>这样就定义了两个环境变量：API_KEY 和 API_URL。</p><p>在 Next.js 的代码中，可以通过使用 process.env 对象来访问环境变量的值。例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Copy</span> code</span><br><span class="line"><span class="keyword">const</span> apiKey = process.<span class="property">env</span>.<span class="property">API_KEY</span>;</span><br><span class="line"><span class="keyword">const</span> apiUrl = process.<span class="property">env</span>.<span class="property">API_URL</span>;</span><br></pre></td></tr></table></figure><p>这样就可以获取环境变量的值并在应用程序中使用。<br>需要注意的是，环境变量在 Next.js 中有一些特殊的命名规则：</p><ul><li>环境变量以 NEXT_PUBLIC_ 前缀开头的变量，可以在客户端代码中直接访问。这些变量将被打包到客户端代码中。</li><li>不以 NEXT_PUBLIC_ 前缀开头的变量，只能在服务端代码中访问。这些变量不会暴露给客户端代码，因此适合存储敏感信息。</li></ul><p>除了 .env.local 文件外，Next.js 还支持其他环境变量文件，如 .env.development、.env.production 等。这些文件可以根据不同的环境配置不同的变量。<br>在生产环境中，你需要在部署应用程序时设置实际的环境变量值。可以通过环境变量的管理工具、云服务平台或配置文件来实现。<br>总结一下，Next.js 支持使用环境变量来配置应用程序的行为。你可以在项目根目录下的 .env.local 文件中定义环境变量，并使用 process.env 对象在代码中访问这些变量。在 Next.js 中有一些特殊的命名规则和文件约定，可以根据不同的环境配置不同的变量。记得在部署应用程序时设置实际的环境变量值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Nextjs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nextjs数据获取（Data Fetching）</title>
      <link href="/blog/2023/04/13/Nextjs%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/"/>
      <url>/blog/2023/04/13/Nextjs%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Nextjs入门中我们说过，Next分为两种渲染模式，SSR&#x2F;SG。针对这两种不同的渲染模式，Nextjs提供给了不同的API进行服务端的数据获取操作。</p><ul><li><code>getStaticProps</code>：（SG）build时获取数据</li><li><code>getStaticPaths</code>：（SG）获取动态路由数据</li><li><code>getServerSideProps</code>：（SSR）获取每次请求的数据</li></ul><h2 id="getStaticProps（SG）"><a href="#getStaticProps（SG）" class="headerlink" title="getStaticProps（SG）"></a>getStaticProps（SG）</h2><p>Next会在build时自动调用此函数，并且将返回值注入到组件的props参数中。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getStaticProps</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;&#125;, <span class="comment">// will be passed to the page component as props</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值是一个对象，允许有以下属性：</p><ul><li>props，向组件props属性中注入</li><li>revalidate，决定x秒后重新生成还是使用缓存，若为true则每次请求都进行重新生成</li><li>notFound，允许返回一个404页面<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getStaticProps</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">requestData</span>(<span class="number">500</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">props</span>: &#123;</span><br><span class="line">                data</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">notFound</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>Incremental Static Regeneration（ISG）</strong><br>允许在静态页面生成之后进行创建或更新静态页面，这就要利用getStaticProps返回值中的<strong>revalidate</strong>属性。</p><h2 id="getStaticPaths（SG）"><a href="#getStaticPaths（SG）" class="headerlink" title="getStaticPaths（SG）"></a>getStaticPaths（SG）</h2><p>如果页面具有动态路由，getStaticsPaths则需要定义一个路径列表。<br><strong>如果从使用动态路由的页面导出名为getStaticPaths的异步函数，Next.js将静态预渲染getStaticPath指定的所有路径。</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getStaticPaths</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">paths</span>: [</span><br><span class="line">      &#123; <span class="attr">params</span>: &#123; ... &#125; &#125; <span class="comment">// See the &quot;paths&quot; section below</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">fallback</span>: <span class="literal">true</span>, <span class="literal">false</span>, or <span class="string">&#x27;blocking&#x27;</span> <span class="comment">// See the &quot;fallback&quot; section below</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个小栗子如下：<br>在一个名为[id].tsx文件夹下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Page</span>(<span class="params">&#123; name &#125;: &#123; name: <span class="built_in">string</span> &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>这是一篇有关&#123;name&#125;的文章<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getStaticPaths</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> posts = [<span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;css&#x27;</span>, <span class="string">&#x27;js&#x27;</span>]</span><br><span class="line">    <span class="keyword">const</span> paths = posts.<span class="title function_">map</span>(<span class="function">(<span class="params">post</span>) =&gt;</span> (&#123;</span><br><span class="line">        <span class="attr">params</span>: &#123; <span class="attr">id</span>: post &#125;,</span><br><span class="line">    &#125;))</span><br><span class="line">    <span class="keyword">return</span> &#123; paths, <span class="attr">fallback</span>: <span class="literal">true</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getStaticProps</span>(<span class="params">&#123; params &#125;: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">props</span>: &#123; <span class="attr">name</span>: params.<span class="property">id</span> &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：不能将getStaticPaths与getServerSideProps一起使用。</strong></p><h2 id="getSeverSideProps（SSR）"><a href="#getSeverSideProps（SSR）" class="headerlink" title="getSeverSideProps（SSR）"></a>getSeverSideProps（SSR）</h2><p>若页面导出了一个异步函数名为getSeverSideProps，则Next默认会开启SSR模式。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getServerSideProps</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;&#125;, <span class="comment">// will be passed to the page component as props</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中context是一个对象，包含属性如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">context.<span class="property">req</span>: 该属性是一个 <span class="title class_">Node</span>.<span class="property">js</span> 的 http.<span class="property">IncomingMessage</span> 对象，它包含了来自客户端的请求信息，例如请求头、请求方法等等。</span><br><span class="line">context.<span class="property">res</span>: 该属性是一个 <span class="title class_">Node</span>.<span class="property">js</span> 的 http.<span class="property">ServerResponse</span> 对象，它用于向客户端发送响应，例如设置响应头、响应状态码等等。</span><br><span class="line">context.<span class="property">query</span>: 该属性是一个对象，它包含了来自客户端的查询参数，例如 ?id=<span class="number">123</span> 中的 id 参数可以通过 context.<span class="property">query</span>.<span class="property">id</span> 获取。</span><br><span class="line">context.<span class="property">params</span>: 该属性是一个对象，它包含了路由参数，例如路由为 /posts/[id]，则访问 /posts/<span class="number">123</span> 时，context.<span class="property">params</span> 中会包含 &#123; <span class="attr">id</span>: <span class="string">&#x27;123&#x27;</span> &#125;。</span><br><span class="line">context.<span class="property">preview</span>: 该属性是一个布尔值，用于判断是否为预览模式，如果是预览模式，则可以显示未发布的内容。</span><br><span class="line">context.<span class="property">resolvedUrl</span>: 该属性是一个字符串，它表示在 <span class="title class_">Next</span>.<span class="property">js</span> 内部解析后的 <span class="variable constant_">URL</span>，通常与 context.<span class="property">req</span>.<span class="property">url</span> 不同，因为 <span class="title class_">Next</span>.<span class="property">js</span> 可以通过路由配置将一个 <span class="variable constant_">URL</span> 映射到另一个 <span class="variable constant_">URL</span>。</span><br></pre></td></tr></table></figure><p>其中返回对象包含属性如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">props</span>: 表示页面渲染所需的数据，它是一个对象。</span><br><span class="line"><span class="attr">redirect</span>: 表示将用户重定向到另一个页面，它是一个对象，包含以下属性：</span><br><span class="line">  - <span class="attr">destination</span>: 表示重定向的目标页面的 <span class="variable constant_">URL</span>。</span><br><span class="line">  - <span class="attr">permanent</span>: 表示重定向的类型，如果为 <span class="literal">true</span>，则表示为永久重定向（<span class="number">301</span>），如果为 <span class="literal">false</span>，则表示为临时重定向（<span class="number">302</span>）。</span><br><span class="line"><span class="attr">notFound</span>: 表示页面不存在，它是一个布尔值，默认为 <span class="literal">false</span>。如果设置为 <span class="literal">true</span>，则会显示 <span class="number">404</span> 页面。</span><br><span class="line"><span class="attr">revalidate</span>: 表示页面的重新验证时间（revalidation time），它是一个数字，表示在指定的秒数内不需要重新生成页面。如果不设置该属性，则页面将在每个请求时重新生成。设置为 <span class="literal">false</span> 则表示该页面不应该被缓存。</span><br><span class="line"><span class="attr">dehydratedState</span>: 表示传递给客户端的静态页面数据。如果启用了 hybrid 模式，客户端将使用该数据进行初次渲染。</span><br><span class="line"><span class="attr">preview</span>: 表示是否启用预览模式，它是一个对象，包含以下属性：</span><br><span class="line">  - <span class="attr">active</span>: 表示是否启用预览模式，它是一个布尔值，默认为 <span class="literal">false</span>。</span><br><span class="line">  - <span class="attr">data</span>: 表示预览模式所使用的数据，它是一个对象。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Nextjs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端性能指标</title>
      <link href="/blog/2023/04/09/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E6%A0%87/"/>
      <url>/blog/2023/04/09/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8C%87%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>什么是web前端性能？</strong><br>简而言之就是：网页在浏览器中下载，呈现以及交互的流畅程度。<br>之前的文章有谈到过那些老生常谈的问题：输入URL到页面加载发生了什么、浏览器渲染原理。<br>了解这些有助于之后的理解。<br>本文参考：<a href="https://juejin.cn/post/6967156013464027143">https://juejin.cn/post/6967156013464027143</a></p><h2 id="前端的一些性能指标"><a href="#前端的一些性能指标" class="headerlink" title="前端的一些性能指标"></a>前端的一些性能指标</h2><p><a href="https://imgse.com/i/ppq9SfO"><img src="https://s1.ax1x.com/2023/04/10/ppq9SfO.png" alt="ppq9SfO.png"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FCP（First Contentful Paint）白屏时间，值越低越好；</span><br><span class="line">SI（Speed Index）页面渲染时间，值越低越好；</span><br><span class="line">LCP（Largest Contentful Paint）可视窗口最大内容渲染时间，值越低越好</span><br><span class="line">TTI（Time to Interactive）用户可交互时间，值越低越好；</span><br><span class="line">TBT（Total Blocking Time）用户行为阻塞时间，值越低越好；</span><br><span class="line">CLS（Cumulative Layout Shift）可视窗口中累计可见元素布局偏移；</span><br><span class="line">FID（First Input Delay）用户首次交互时间，值越低越好</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="FCP（First-Contentful-Paint）首次内容渲染"><a href="#FCP（First-Contentful-Paint）首次内容渲染" class="headerlink" title="FCP（First Contentful Paint）首次内容渲染"></a>FCP（First Contentful Paint）首次内容渲染</h3><p>白屏时间指的是用户在浏览器中打开页面到渲染第一个DOM元素所花费的时间，DOM元素包括图片，非空白canvas，SVG等元素，不包括iframe中的元素。<br>建议阈值：<code>优 1.8s 良 3.0s 差 </code><br><strong>优化策略</strong></p><ol><li>DNS解析优化</li><li>服务端处理优化：例如GZIP压缩等</li><li>CND加速</li><li>精简DOM结构，合理压缩静态资源文件</li><li>字体加载优化：font-display属性</li></ol><h3 id="SI（Speed-Index）页面内容呈现速度"><a href="#SI（Speed-Index）页面内容呈现速度" class="headerlink" title="SI（Speed Index）页面内容呈现速度"></a>SI（Speed Index）页面内容呈现速度</h3><p>与其他页面加载时间指标（如首次内容呈现时间、最大可见元素延迟时间）不同，SI 是一种综合指标，它考虑了页面的整体渲染速度。具体来说，SI 是通过计算页面加载过程中每个时刻屏幕上显示的像素数量的平均值来确定的。SI 越低，表示页面内容的呈现速度越快，用户体验越好。</p><p><strong>优化策略</strong></p><ol><li>优化主进程，包括解析和执行阶段。</li><li>利用webworker进行复杂计算</li><li>减少复杂的样式计算和嵌套</li><li>避免复杂的布局回流</li><li>异步加载非必须的CSS</li></ol><h3 id="LCP（Largest-Contentful-Paint）最大内容渲染速度"><a href="#LCP（Largest-Contentful-Paint）最大内容渲染速度" class="headerlink" title="LCP（Largest Contentful Paint）最大内容渲染速度"></a>LCP（Largest Contentful Paint）最大内容渲染速度</h3><p>LCP 时间是指最大内容元素呈现在屏幕上的时间。它反映了页面呈现的速度，因为最大内容元素通常是页面中最具代表性的元素。LCP 时间越短，页面的视觉稳定性和用户体验就越好。<strong>注意：这里的大小指的是尺寸的大下，而非数据的内存的大小。</strong><br><strong>哪些元素可能是最大的？</strong></p><ul><li>图片</li><li>网络请求资源</li><li>包含文本节点的块级元素<br>建议阈值：<code>优 2.5s 良 4.0s 差 </code><br><strong>优化策略</strong><br>LCP 的优化通常需要改善页面加载速度和响应性能，例如通过优化图像大小和压缩，优化代码和减少HTTP请求等。因此，通过优化 LCP 可以显著提高页面的性能和用户体验。</li></ul><h3 id="TTI（Time-to-Interactive）用户可交互速度"><a href="#TTI（Time-to-Interactive）用户可交互速度" class="headerlink" title="TTI（Time to Interactive）用户可交互速度"></a>TTI（Time to Interactive）用户可交互速度</h3><p>TTI（Time to Interactive）是一个重要的页面加载性能指标，用于衡量用户可以与页面进行交互的时间。它表示从页面开始加载到页面变得交互式所需的时间，通常以秒（s）为单位进行测量。</p><p>TTI 是一个非常关键的指标，因为它反映了用户可以开始与页面进行交互的时间。用户往往会因为长时间等待页面加载而感到沮丧，因此通过优化 TTI 可以显著提高页面的用户体验。</p><p><strong>优化策略</strong></p><ol><li>加载采用PRPL模式<ul><li>Push (or preload) the most important resources.</li><li>Render the initial route as soon as possible.</li><li>Pre-cache remaining assets.</li><li>Lazy load other routes and non-critical assets.</li></ul></li><li>压缩资源，确保js先执行</li><li>减少因代码割裂导致的依赖</li></ol><h3 id="CLS（Cumulative-Layout-Shift）"><a href="#CLS（Cumulative-Layout-Shift）" class="headerlink" title="CLS（Cumulative Layout Shift）"></a>CLS（Cumulative Layout Shift）</h3><p>CLS（Cumulative Layout Shift）是一个页面渲染稳定性指标，用于衡量页面加载过程中内容变化的程度。CLS 表示页面上元素位置变化的累计量，通常用数值表示。<br>CLS 是一个非常重要的指标，因为它可以帮助开发人员和网站管理员了解页面的视觉稳定性，并改善用户体验。如果页面加载过程中出现频繁的内容移动或跳动，用户可能会感到困惑或失望，影响他们对网站的信任和忠诚度。<br>通常，CLS 可以通过各种性能测试工具（如Google Lighthouse和WebPageTest）来测量。这些工具可以生成报告，显示页面的 CLS 值以及其他性能指标，以帮助开发人员和网站管理员优化其网站的性能和用户体验。<br>建议阈值：<code>优 0.1良 0.25 差 </code> </p><p><strong>优化策略</strong></p><ol><li>给页面元素设置固定的大小和位置</li><li>预留图像和视频的空间，避免它们加载时造成页面布局的变化</li><li>避免在页面上插入动态内容，例如广告或跟踪脚本</li><li>避免使用字体或图标库，因为它们可能会在加载时造成页面元素的变化。</li></ol><h3 id="FID（First-Input-Delay）首次交互延迟"><a href="#FID（First-Input-Delay）首次交互延迟" class="headerlink" title="FID（First Input Delay）首次交互延迟"></a>FID（First Input Delay）首次交互延迟</h3><p>它衡量的是用户首次与页面交互（例如点击链接、按钮或输入框）到页面响应该交互的时间差。FID 的单位通常是毫秒（ms）。<br>建议阈值：<code>优 100ms 良 300ms 差 </code> </p><p><strong>优化策略</strong></p><ol><li>最小化JavaScript文件大小和数量，以加快脚本执行速度</li><li>避免在主线程上执行长时间运行的任务，例如计算和解析数据</li><li>使用 Web Worker 将这些任务从主线程移除</li><li>避免使用阻塞渲染的第三方脚本</li><li>最小化网络请求并使用HTTP&#x2F;2等协议来加快加载时间</li></ol><h3 id="TBT（Total-Blocking-Time）用户行为阻塞时间"><a href="#TBT（Total-Blocking-Time）用户行为阻塞时间" class="headerlink" title="TBT（Total Blocking Time）用户行为阻塞时间"></a>TBT（Total Blocking Time）用户行为阻塞时间</h3><p>也就是说页面FCP首次内容绘制到TTI用户可交互的时间，也就是FCP到TTI之间所有长任务阻塞的时间总和。<br>TBT（Total Blocking Time）是一个衡量页面响应速度的指标，它与页面的 FID（First Input Delay）指标密切相关。TBT 表示在页面主线程被阻塞的总时间，这些阻塞通常是由长时间运行的 JavaScript 代码或者其他资源加载等导致的。TBT 的单位通常是毫秒（ms）。</p><p><strong>优化策略</strong></p><ol><li>最小化 JavaScript 文件大小和数量，以加快脚本执行速度</li><li>避免在主线程上执行长时间运行的任务，例如计算和解析数据</li><li>使用 Web Worker 将这些任务从主线程移除</li><li>避免使用阻塞渲染的第三方脚本</li><li>最小化网络请求并使用 HTTP&#x2F;2 等协议来加快加载时间</li></ol><h2 id="Yahoo35条军规"><a href="#Yahoo35条军规" class="headerlink" title="Yahoo35条军规"></a>Yahoo35条军规</h2><ul><li>尽量减少HTTP请求数</li><li>合并文件、CSS Sprites、行内图片</li><li>减少DNS查找</li><li>避免重定向</li><li>让Ajax可缓存</li><li>延迟加载组件</li><li>预加载组件（无条件预加载、条件性预加载、提前预加载）</li><li>减少DOM元素的数量（700以内HTML标签）</li><li>跨域分离组件（静态分离，同域名并行下载一般不能超过6条）</li><li>尽量少用iframe</li><li>杜绝404</li><li>把样式表放在顶部；</li><li>避免使用CSS表达式；</li><li>选择舍弃@import；</li><li>避免使用滤镜；</li><li>去除重复脚本；</li><li>尽量减少DOM访问（缓存已访问过的元素的索引先“离线”更新节点，再把它们添到DOM树上，避免用JavaScript修复布局问题）；</li><li>用智能的事件处理器（比如DOMContentLoaded 代替load，合理使用事件委托）；</li><li>把脚本放在底部，合理使用defer，async异步加载；</li><li>把JavaScript和CSS放到外面；</li><li>压缩JavaScript和CSS</li><li>优化图片；</li><li>优化CSS Sprite；</li><li>不要用HTML缩放图片；</li><li>用小的可缓存的favicon.ico（越小越好，一定要有，否则会造成404）；</li><li>给Cookie减肥（清除不必要的cookie、保持合理大小，合理域名、有效期）；</li><li>把组件放在不含cookie的域下；</li><li>保证所有组件都小于25K；</li><li>把组件打包到一个复合文档里；</li><li>Gzip组件；</li><li>避免图片src属性为空；</li><li>配置ETags（服务器）</li><li>对Ajax用GET请求（服务器）；</li><li>尽早清空缓冲区（服务器）；</li><li>使用CDN(Content Delivery Network)；</li><li>添上Expires或者Cache-Control HTTP头</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nextjs入门（翻译自官网）</title>
      <link href="/blog/2023/03/23/Nextjs%E5%85%A5%E9%97%A8/"/>
      <url>/blog/2023/03/23/Nextjs%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>Nextjs的导航不同于React的配置式导航，是采用基于pages文件夹下页面路径与导航进行一个映射关系。<br>例如：<br>&#x2F; —-&gt; &#x2F;pages&#x2F;index.js<br>&#x2F;a&#x2F;1 —-&gt; &#x2F;pages&#x2F;a&#x2F;[id].js</p><h3 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h3><p>需要引入Next中的Link组件，来包裹a标签：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Link</span> <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">FirstPost</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>First Post<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">a</span>&gt;</span>Back to home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码的分割与预取操作"><a href="#代码的分割与预取操作" class="headerlink" title="代码的分割与预取操作"></a>代码的分割与预取操作</h3><p>Next.js会自动对代码进行拆分，因此每个页面只加载页面所需的js代码和资源。这意味着当主页被呈现时，其他页面的代码最初不会被提供。<br>这样可以确保即使添加了数百个页面，主页也能快速加载。<br>只加载您请求的页面的代码也意味着页面将被隔离。如果某个页面抛出错误，那么应用程序的其余部分仍然可以工作。<br>此外，在Next.js的生产版本中，每当链接组件出现在浏览器的视口中时，Next.js都会自动在后台预取链接页面的代码。当你点击链接时，目标页面的代码已经在后台加载，页面转换将接近即时！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Next.js通过代码拆分、客户端导航和预取（在生产中）自动优化您的应用程序以获得最佳性能。<br>您可以将路由创建为页面下的文件，并使用内置的“链接”组件。不需要路由库。</p><h2 id="资源、元数据和CSS"><a href="#资源、元数据和CSS" class="headerlink" title="资源、元数据和CSS"></a>资源、元数据和CSS</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>本章节将学会：</p><ul><li>如何将静态文件（图像等）添加到Next.js。</li><li>如何为每个页面自定义＜head＞中的内容。</li><li>如何创建一个可重用的React组件，该组件使用CSS模块进行样式设计。</li><li>如何在pages&#x2F;_app.js中添加全局CSS。</li><li>在Next.js中设置样式的一些有用提示。</li></ul><h3 id="如何修改head中的内容"><a href="#如何修改head中的内容" class="headerlink" title="如何修改head中的内容"></a>如何修改head中的内容</h3><p>可以引入Next中的Head组件，Next在页面生成时会自动帮助我们替换掉原head标签为Head组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Head</span> <span class="keyword">from</span> <span class="string">&#x27;next/head&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">FirstPost</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>First Post<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      …</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CSS样式引入"><a href="#CSS样式引入" class="headerlink" title="CSS样式引入"></a>CSS样式引入</h3><p>Nextjs内置styled-jsx库，使用如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style jsx&gt;&#123;<span class="string">`</span></span><br><span class="line"><span class="string">  …</span></span><br><span class="line"><span class="string">`</span>&#125;&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>Nextjs也支持其他CSS-in-JS库，例如 styled-components 、 emotion.</p><h3 id="创建可复用组件"><a href="#创建可复用组件" class="headerlink" title="创建可复用组件"></a>创建可复用组件</h3><ol><li>创建顶层文件夹components</li><li>创建XXX.js文件（XXX组件名）</li><li>其他文件导入组件</li></ol><h3 id="全局样式文件"><a href="#全局样式文件" class="headerlink" title="全局样式文件"></a>全局样式文件</h3><ol><li>在pages页面下创建一个_app.js文件，并添加以下内容：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params">&#123; Component, pageProps &#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...pageProps</span>&#125; /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>创建全局样式css文件</li><li>在_app.js文件中引入全局样式文件<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;../styles/global.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params">&#123; Component, pageProps &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...pageProps</span>&#125; /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>注意：全局css样式文件只能在_app.js文件中引入！！！</strong></li></ol><h3 id="添加组件级CSS文件"><a href="#添加组件级CSS文件" class="headerlink" title="添加组件级CSS文件"></a>添加组件级CSS文件</h3><p>Next.js 通过 [name].module.css 文件命名约定来支持 CSS 模块 。<br>通过这样命名可以将CSS文件限定在局部范围。从而可以在不同文件内部使用相同文件名，一次避免冲突。</p><h2 id="预渲染和数据获取"><a href="#预渲染和数据获取" class="headerlink" title="预渲染和数据获取"></a>预渲染和数据获取</h2><h3 id="什么是预渲染"><a href="#什么是预渲染" class="headerlink" title="什么是预渲染"></a>什么是预渲染</h3><p>默认情况下，Next会对每个页面进行预渲染，也就是说Next为每个页面提前生成HTML，而不是像传统的框架那样，全部用js来实现，不利于SEO。<br>也就是说一个html页面对应最小化确保交互的js代码。</p><h3 id="预渲染的两种形式"><a href="#预渲染的两种形式" class="headerlink" title="预渲染的两种形式"></a>预渲染的两种形式</h3><p>两种形式：静态生成（Static Generation）、服务端渲染（Sever-side Rendering）<br>SG是在打包时静态生成，然后预渲染的HTML在每个请求上重复使用。<br>SSR是在每次向服务端请求后，再生成代码。</p><p><img src="https://secure2.wostatic.cn/static/pL5j3zq1UYkzn83rnEPZwz/1EFF175C-16DC-484B-8A05-720ADDE36F7C.png?auth_key=1679903860-rHggJm5Aj7eqiXJtkuKbhi-0-18a918fd04cfdc94244d6958da9d9d3a"></p><p>适合静态生成的页面：不经常更新改变的页面<br>适合服务端渲染的页面：每次请求，页面大概率改变</p><h3 id="有数据和无数据的静态生成"><a href="#有数据和无数据的静态生成" class="headerlink" title="有数据和无数据的静态生成"></a>有数据和无数据的静态生成</h3><p><strong>无数据的静态生成</strong><br>直接构建就好</p><p><strong>有数据的静态生成</strong><br>也就是说静态生成之前必须要异步获取数据。<br>其中有一个异步方法’getStaticProps’，将会在生产环境构建页面时运行。在这个方法中，可以去额外的数据，并通过props注入到组件中。<br>getStaticProps代码不会返回给客户，因此，可以直接在getStaticProps代码中填写一些私密性代码，例如sql语句，等等。</p><h3 id="服务端渲染（SSR）"><a href="#服务端渲染（SSR）" class="headerlink" title="服务端渲染（SSR）"></a>服务端渲染（SSR）</h3><p><a href="https://imgse.com/i/ppsq1ds"><img src="https://s1.ax1x.com/2023/03/27/ppsq1ds.md.png" alt="ppsq1ds.md.png"></a></p><p>关键函数<code>getServerSideProps</code>,区别于SG中的getStaticProps，前者是用于SSR，后者是用于SG，执行时间不一样。前者是每次请求执行，后者是构建时执行。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getServerSideProps</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="comment">// props for your component</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中context包含特定的请求参数。getServerSideProps要比getStaticProps慢，因为服务器必须计算每个请求的结果，并且没有额外配置，CDN不会缓存。</p><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>一个页面的路由取决于页面的内容（额外的数据）。↓<br><a href="https://imgse.com/i/ppsLvjO"><img src="https://s1.ax1x.com/2023/03/27/ppsLvjO.md.png" alt="ppsLvjO.md.png"></a></p><p><strong>pages&#x2F;posts&#x2F;[id].js</strong>这种形式的路径。</p>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Nextjs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Native-入门</title>
      <link href="/blog/2023/03/12/RN-%E5%85%A5%E9%97%A8/"/>
      <url>/blog/2023/03/12/RN-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Why-RN-可以跨平台？How-To-Work？"><a href="#Why-RN-可以跨平台？How-To-Work？" class="headerlink" title="Why RN 可以跨平台？How To Work？"></a>Why RN 可以跨平台？How To Work？</h2><p>通过使用js来访问移动平台的API，以及使用React组件来描述UI的外观和行为。<br>在Android&#x2F;IOS开发中，视图是UI的最基本组成部分，在web中与之对应的是组件。在运行时，RN会为所有组件创建视图。可以理解为一个翻译的过程。<br>其中用户编写的RN组件被称为原生组件，核心组件是一种特殊的原生组件，是一种无需编写，RN内置的随时可用的组件。</p><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><table><thead><tr><th>REACT NATIVE UI COMPONENT</th><th>ANDROID VIEW</th><th>IOS VIEW</th><th>WEB ANALOG</th><th>说明</th></tr></thead><tbody><tr><td>View</td><td>ViewGroup</td><td>UIView</td><td>A non-scrollling div</td><td>A container that supports layout with flexbox, style, some touch handling, and accessibility controls</td></tr><tr><td>Text</td><td>TextView</td><td>UITextView</td><td>p</td><td>Displays, styles, and nests strings of text and even handles touch events</td></tr><tr><td>Image</td><td>ImageView</td><td>UIImageView</td><td>img</td><td>Displays different types of images</td></tr><tr><td>ScrollView</td><td>ScrollView</td><td>UIScrollView</td><td>div</td><td>A generic scrolling container that can contain multiple components and views</td></tr><tr><td>TextInput</td><td>EditText</td><td>UITextField</td><td>input type&#x3D;”text”</td><td>Allows the user to enter text</td></tr></tbody></table><p><strong>一个核心组件使用栗子：</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">View</span>, <span class="title class_">Text</span>, <span class="title class_">Image</span>, <span class="title class_">ScrollView</span>, <span class="title class_">TextInput</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ScrollView</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Text</span>&gt;</span>Some text<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">View</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Text</span>&gt;</span>Some more text<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Image</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">source</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">uri:</span> &#x27;<span class="attr">https:</span>//<span class="attr">reactnative.dev</span>/<span class="attr">docs</span>/<span class="attr">assets</span>/<span class="attr">p_cat2.png</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">width:</span> <span class="attr">200</span>, <span class="attr">height:</span> <span class="attr">200</span> &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">TextInput</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">height:</span> <span class="attr">40</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">borderColor:</span> &#x27;<span class="attr">gray</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">borderWidth:</span> <span class="attr">1</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">defaultValue</span>=<span class="string">&quot;You can type in me&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ScrollView</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><h3 id="TextInput"><a href="#TextInput" class="headerlink" title="TextInput"></a>TextInput</h3><p>TextInput是一个允许用户输入文本的基础组件。它有一个名为onChangeText的属性，此属性接受一个函数，而此函数会在文本变化时被调用。另外还有一个名为onSubmitEditing的属性，会在文本被提交后（用户按下软键盘上的提交键）调用。</p><h3 id="ScrollView"><a href="#ScrollView" class="headerlink" title="ScrollView"></a>ScrollView</h3><p>ScrollView是一个通用的可滚动的容器，你可以在其中放入多个组件和视图，而且这些组件并不需要是同类型的。ScrollView 不仅可以垂直滚动，还能水平滚动（通过horizontal属性来设置）。<br>使用pagingEnabled属性来允许使用滑动手势对视图进行分页，在 Android 上也可以利用ViewPager组件水平滑动视图。<br><strong>ScrollView适合用来显示数量不多的滚动元素</strong>。<strong>放置在ScrollView中的所有组件都会被渲染，哪怕有些组件因为内容太长被挤出了屏幕外</strong>。如果你需要显示较长的滚动列表，那么应该使用功能差不多但性能更好的<strong>FlatList组件</strong>。</p><h3 id="长列表（FlatList-x2F-SectionList）"><a href="#长列表（FlatList-x2F-SectionList）" class="headerlink" title="长列表（FlatList&#x2F;SectionList）"></a>长列表（FlatList&#x2F;SectionList）</h3><p><strong>FlatList</strong><br>FlatList组件用于显示一个垂直的滚动列表，其中的元素之间结构近似而仅数据不同。<br>FlatList更适于长列表数据，且元素个数可以增删。和ScrollView不同的是，FlatList并不立即渲染所有元素，而是优先渲染屏幕上可见的元素。<br>FlatList组件必须的两个属性是<strong>data</strong>和<strong>renderItem</strong>。data是列表的数据源，而renderItem则从数据源中逐个解析数据，然后返回一个设定好格式的组件来渲染。<br><strong>SectionList</strong></p><ul><li>sections 设置title和data</li><li>renderItem</li><li>renderSectionHeader</li><li>keyExtractor</li></ul><h2 id="特定平台代码（Platform-模块）"><a href="#特定平台代码（Platform-模块）" class="headerlink" title="特定平台代码（Platform 模块）"></a>特定平台代码（Platform 模块）</h2><h3 id="Platform-OS"><a href="#Platform-OS" class="headerlink" title="Platform.OS"></a>Platform.OS</h3><p>在IOS返回ios，Android返回android</p><h3 id="Platform-select"><a href="#Platform-select" class="headerlink" title="Platform.select"></a>Platform.select</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Platform</span>.<span class="title function_">select</span>(&#123;</span><br><span class="line">    <span class="attr">ios</span>: &#123;</span><br><span class="line">      <span class="attr">backgroundColor</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">android</span>: &#123;</span><br><span class="line">      <span class="attr">backgroundColor</span>: <span class="string">&#x27;blue&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><h3 id="Platform-Version"><a href="#Platform-Version" class="headerlink" title="Platform.Version"></a>Platform.Version</h3><p>检测设备版本</p><h3 id="特定平台后缀"><a href="#特定平台后缀" class="headerlink" title="特定平台后缀"></a>特定平台后缀</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigButton.ios.js</span><br><span class="line">BigButton.android.js</span><br></pre></td></tr></table></figure><p>可以去掉平台后缀直接引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">BigButton</span> <span class="keyword">from</span> <span class="string">&#x27;./BigButton&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果你还希望在 web 端复用 React Native 的代码，那么还可以使用.native.js的后缀。此时 iOS 和 Android 会使用BigButton.native.js文件，而 web 端会使用BigButton.js。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Container.js # 由 Webpack, Rollup 或者其他打包工具打包的文件</span><br><span class="line">Container.native.js # 由 React Native 自带打包工具(Metro) 为ios和android 打包的文件</span><br></pre></td></tr></table></figure><p>在引用时并不需要添加.native.后缀:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Container</span> <span class="keyword">from</span> <span class="string">&#x27;./Container&#x27;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> React Native </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阅读build-your-own-react总结</title>
      <link href="/blog/2023/03/11/%E9%98%85%E8%AF%BBbuild-your-own-react%E6%80%BB%E7%BB%93/"/>
      <url>/blog/2023/03/11/%E9%98%85%E8%AF%BBbuild-your-own-react%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>原文出处：<a href="https://pomb.us/build-your-own-react/">build-your-own-react</a><br>该文章旨在通过以下几步引导读者创建自己的React：</p><ul><li>Step I: The createElement Function</li><li>Step II: The render Function</li><li>Step III: Concurrent Mode</li><li>Step IV: Fibers</li><li>Step V: Render and Commit Phases</li><li>Step VI: Reconciliation</li><li>Step VII: Function Components</li><li>Step VIII: Hooks</li></ul><h2 id="Step-I-The-createElement-Function"><a href="#Step-I-The-createElement-Function" class="headerlink" title="Step I: The createElement Function"></a>Step I: The createElement Function</h2><p><strong>createElement 函数的作用是根据指定的第一个参数创建一个React元素，可以用JSX来替代</strong><br><strong>下面是createElement的模拟代码：</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createElement</span>(<span class="params">type, props, ...children</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      ...props,</span><br><span class="line">      <span class="attr">children</span>: children.<span class="title function_">map</span>(<span class="function"><span class="params">child</span> =&gt;</span></span><br><span class="line">        <span class="keyword">typeof</span> child === <span class="string">&quot;object&quot;</span></span><br><span class="line">          ? child</span><br><span class="line">          : <span class="title function_">createTextElement</span>(child)</span><br><span class="line">      ),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createTextElement</span>(<span class="params">text</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;TEXT_ELEMENT&quot;</span>,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">nodeValue</span>: text,</span><br><span class="line">      <span class="attr">children</span>: [],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JSX写法：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello, &#123; this.props.toWhat &#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Hello</span> <span class="attr">toWhat</span>=<span class="string">‘world’</span>&gt;</span>,</span></span><br><span class="line"><span class="language-xml">    document.getElementById(‘root’)</span></span><br><span class="line"><span class="language-xml">)</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转化为原生JS后的写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">React</span>.<span class="title function_">createElement</span>(‘div’,<span class="literal">null</span>, <span class="string">`Hello,<span class="subst">$&#123;<span class="variable language_">this</span>.props.toWhat&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">createElement</span>(‘<span class="title class_">Hello</span>’, &#123; <span class="attr">toWhat</span>: ‘world’ &#125;, <span class="literal">null</span>),</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(‘root’)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="Step-II-The-render-Function"><a href="#Step-II-The-render-Function" class="headerlink" title="Step II: The render Function"></a>Step II: The render Function</h2><p><strong>render函数主要的作用就是将虚拟dom转化为真实dom，并挂载到container容器上。</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码只是第一版本，递归操作会有问题，后续步骤中会修改。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Once we start rendering, we won’t stop until we have rendered the complete element tree. If the element tree is big, it may block the main thread for too long. And if the browser needs to do high priority stuff like handling user input or keeping an animation smooth, it will have to wait until the render finishes.(递归操作的问题)</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">element, container</span>) &#123;</span><br><span class="line">    <span class="comment">// 根据ract元素类型不同创建相应的dom节点</span></span><br><span class="line">    <span class="keyword">const</span> dom = element.<span class="property">type</span> === <span class="string">&#x27;TEXT_ELEMENT&#x27;</span></span><br><span class="line">        ? <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        : <span class="variable language_">document</span>.<span class="title function_">createElement</span>(element.<span class="property">type</span>)</span><br><span class="line">    <span class="comment">// 将props上记录的非children属性添加到dom上</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">isProperty</span> = key =&gt; key !== <span class="string">&quot;children&quot;</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(element.<span class="property">props</span>)</span><br><span class="line">        .<span class="title function_">filter</span>(isProperty)</span><br><span class="line">        .<span class="title function_">forEach</span>(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">            dom[name] = element.<span class="property">props</span>[name]</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="comment">// 便利子节点，递归创建真是DOM</span></span><br><span class="line">    element.<span class="property">props</span>.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">child</span> =&gt;</span></span><br><span class="line">        <span class="title function_">render</span>(child, dom)</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 虚拟DOM转化来的真是DOM挂载到container上</span></span><br><span class="line">    container.<span class="title function_">appendChild</span>(dom)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Step-III-Concurrent-Mode"><a href="#Step-III-Concurrent-Mode" class="headerlink" title="Step III: Concurrent Mode"></a>Step III: Concurrent Mode</h2><p><strong>考虑到上述版本的render函数无法打断的问题，这一步骤将render函数进行改良。</strong>So we are going to break the work into small units, and after we finish each unit we’ll let the browser interrupt the rendering if there’s anything else that needs to be done.<br><strong>requestIdleCallback函数</strong>React-render并发模式的救世主，以下是MDN对该函数的介绍：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.requestIdleCallback() 方法插入一个函数，这个函数将在浏览器空闲时期被调用。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间timeout，则有可能为了在超时前执行函数而打乱执行顺序。</span><br></pre></td></tr></table></figure><p>注意：该函数只是在React早期版本使用，后期版本中采用<strong>scheduler package</strong>的方式，但原理都是充分利用了浏览器空闲时期。<br>那么问题来了，传统的虚拟DOM无法适应这种打断机制，因此React中采用了<strong>Fibers</strong>架构，来配合这种能够随时打断并回复执行的机制。</p><h2 id="Fibers"><a href="#Fibers" class="headerlink" title="Fibers"></a>Fibers</h2><p>React为每一个Element提供一个Fiber。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设想要渲染的元素树如下所示：</span></span><br><span class="line"><span class="title class_">Didact</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">a</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">  container</span><br><span class="line">)<span class="string">`</span></span><br></pre></td></tr></table></figure><p>对应的Fibers Tree如下图：<br><a href="https://imgse.com/i/pptfcAP"><img src="https://s1.ax1x.com/2023/03/20/pptfcAP.png" alt="pptfcAP.png"></a></p><p>这种数据结构的目标之一是使查找下一个工作单元变得容易。这就是为什么每个Fiber都有一个链接到它的第一个孩子、下一个兄弟姐妹和它的父母。<br><strong>Fiber工作的机制：</strong><br>从根出发，孩子作为下一个工作单元，若没有孩子，则兄弟节点作为下一个工作单元，若既没有孩子也没有兄弟，则向上寻找其叔叔节点，也就是父亲节点的兄弟节点，直到再次回到兄弟节点为止。上述过程的顺序如下图：<br><a href="https://imgse.com/i/ppthcr9"><img src="https://s1.ax1x.com/2023/03/20/ppthcr9.png" alt="ppthcr9.png"></a></p><h2 id="Step-V-Render-and-Commit-Phases"><a href="#Step-V-Render-and-Commit-Phases" class="headerlink" title="Step V: Render and Commit Phases"></a>Step V: Render and Commit Phases</h2><p>由于React在Fiber渲染阶段可以随时被打断，若渲染之后立即提交的话，用户会看到不完整的UI，因为渲染随时可能被更高优先级的事件打断。因此在整个Fibers Tree渲染完成之前，React是不会进行提交操作的，也就是不会渲染真实DOM</p><h2 id="Step-VI-Reconciliation（调和阶段）"><a href="#Step-VI-Reconciliation（调和阶段）" class="headerlink" title="Step VI: Reconciliation（调和阶段）"></a>Step VI: Reconciliation（调和阶段）</h2><p>将render函数上接的元素与提交给DOM的最后一个元素Fiber进行对比。<br>因此在每次提交之前需要保存本次的FiberTree，这里叫currentRoot </p>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆</title>
      <link href="/blog/2023/03/02/%E5%A0%86/"/>
      <url>/blog/2023/03/02/%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h2><p>堆本质上是一种特殊的树结构————完全二叉树，且堆中每个节点的值都大于其子节点的值。<br>因此分为 <strong>大根堆</strong> &#x2F; <strong>小根堆</strong></p><h2 id="堆的表示"><a href="#堆的表示" class="headerlink" title="堆的表示"></a>堆的表示</h2><p>可以用数组来表示。<br>当前节点序号为i，其子节点为 <strong>i * 2 + 1</strong> 、 <strong>i * 2 + 2</strong><br>当前节点序号为i，其父节点为 Math.floor(i&#x2F;2) &#x2F;&#x2F; 向下取整</p><h2 id="堆中的一系列操作"><a href="#堆中的一系列操作" class="headerlink" title="堆中的一系列操作"></a>堆中的一系列操作</h2><h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><p><strong>自顶向下（nlogn）</strong><br>不断将数据插入堆尾，然后每插入一次进行一次堆化操作（也就是上浮操作）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">7</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">heapifyUp</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.<span class="property">length</span> - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">let</span> j = i</span><br><span class="line">        <span class="keyword">while</span> (arr[j] &gt; arr[<span class="title class_">Math</span>.<span class="title function_">floor</span>(j / <span class="number">2</span>)]) &#123;</span><br><span class="line">            <span class="comment">// 交换两个节点</span></span><br><span class="line">            <span class="keyword">let</span> t = arr[j]</span><br><span class="line">            arr[j] = arr[<span class="title class_">Math</span>.<span class="title function_">floor</span>(j / <span class="number">2</span>)]</span><br><span class="line">            arr[<span class="title class_">Math</span>.<span class="title function_">floor</span>(j / <span class="number">2</span>)] = t</span><br><span class="line">            j = <span class="title class_">Math</span>.<span class="title function_">floor</span>(j / <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自下而上（n）</strong><br>将数组从第一个非叶子节点开始，对其子树进行下沉操作进行堆化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">7</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createHeap</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.<span class="property">length</span></span><br><span class="line">    <span class="comment">// 下沉操作</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">down</span>(<span class="params">i</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">            left_index = <span class="number">2</span> * i + <span class="number">1</span></span><br><span class="line">            right_index = <span class="number">2</span> * i + <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (left_index &gt;= len) <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">let</span> index = arr[left_index] &gt; arr[right_index] ? left_index : (arr[right_index] ? right_index : left_index)</span><br><span class="line">            <span class="keyword">let</span> t = arr[i]</span><br><span class="line">            arr[i] = arr[index]</span><br><span class="line">            arr[index] = t</span><br><span class="line">            i = index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="title function_">down</span>(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">createHeap</span>(arr));</span><br></pre></td></tr></table></figure><h3 id="堆化（将数组转化为堆结构）"><a href="#堆化（将数组转化为堆结构）" class="headerlink" title="堆化（将数组转化为堆结构）"></a>堆化（将数组转化为堆结构）</h3><p>堆化主要分为两种，上浮和下沉<br><strong>上浮：</strong><br>从右往左，如图：<br><a href="https://imgse.com/i/ppA2F81"><img src="https://s1.ax1x.com/2023/03/04/ppA2F81.png" alt="ppA2F81.png"></a><br>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">7</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">heapifyUp</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = arr.<span class="property">length</span> - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">let</span> j = i</span><br><span class="line">        <span class="keyword">while</span> (arr[j] &gt; arr[<span class="title class_">Math</span>.<span class="title function_">floor</span>(j / <span class="number">2</span>)]) &#123;</span><br><span class="line">            <span class="comment">// 交换两个节点</span></span><br><span class="line">            <span class="keyword">let</span> t = arr[j]</span><br><span class="line">            arr[j] = arr[<span class="title class_">Math</span>.<span class="title function_">floor</span>(j / <span class="number">2</span>)]</span><br><span class="line">            arr[<span class="title class_">Math</span>.<span class="title function_">floor</span>(j / <span class="number">2</span>)] = t</span><br><span class="line">            j = <span class="title class_">Math</span>.<span class="title function_">floor</span>(j / <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>先插入到数组尾部，确保数据结构为完全二叉树，然后再进行堆化。<br><a href="https://imgse.com/i/ppA20Gn"><img src="https://s1.ax1x.com/2023/03/04/ppA20Gn.png" alt="ppA20Gn.png"></a><br>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insert</span>(<span class="params">number, heap</span>) &#123;</span><br><span class="line">    heap.<span class="title function_">push</span>(number)</span><br><span class="line">    <span class="keyword">let</span> index = heap.<span class="property">length</span> - <span class="number">1</span>, father_index = <span class="title class_">Math</span>.<span class="title function_">floor</span>(index / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">while</span> (heap[index] &gt; heap[father_index]) &#123;</span><br><span class="line">        <span class="keyword">let</span> t = heap[index]</span><br><span class="line">        heap[index] = heap[father_index]</span><br><span class="line">        heap[father_index] = t</span><br><span class="line">        index = father_index</span><br><span class="line">        father_index = <span class="title class_">Math</span>.<span class="title function_">floor</span>(index / <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除堆顶元素"><a href="#删除堆顶元素" class="headerlink" title="删除堆顶元素"></a>删除堆顶元素</h3><p>先将堆顶元素与末尾元素进行交换，（以大根堆为例），再将堆顶元素进行下沉操作。</p><h2 id="与堆有关的时间复杂度"><a href="#与堆有关的时间复杂度" class="headerlink" title="与堆有关的时间复杂度"></a>与堆有关的时间复杂度</h2><p>堆化：O(logn)<br>插入：O(logn)<br>删除：O(logn)</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序的基本思想是：<br>1.将待排序序列构造成一个大顶堆<br>2.此时，整个序列的最大值就是堆顶的根节点。<br>3.将其与末尾元素进行交换，此时末尾就为最大值。<br>4.然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作用域、作用域链、执行上下文、执行栈</title>
      <link href="/blog/2023/02/19/%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E3%80%81%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E6%89%A7%E8%A1%8C%E6%A0%88/"/>
      <url>/blog/2023/02/19/%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E3%80%81%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E3%80%81%E6%89%A7%E8%A1%8C%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为笔者在准备前端面试的过程中，对于<strong>作用域、作用域链、执行上下文、执行栈</strong>的概念时长感到力不从心、模糊不清，因此记录了这篇文章，深入探究以下。</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>说起作用域，其实分为两种：<strong>静态作用域</strong>、<strong>动态作用域</strong>，js是前者。<br>所谓静态作用域，无非就是在编译阶段就产生的。学过编译原理的朋友都知道，在此法分析解阶段，编译器会将你的代码解析成一个个token关键字，形成AST抽象词法树，静态作用域在此时就可创建完成，而动态作用域只有在函数执行时才确认，js中的this很像动态作用域的概念，玩家可以通过bind、call等方法动态改变this的指向(箭头函数除外，箭头函数本身没有this，其中的this经过babel翻译之后只不过是一个被赋值了外层this值的一个变量而已，在定义时就已经确定)，这也变相弥补了js是静态作用域的缺陷。<br>也就是说<strong>作用域</strong>定义了一套代码执行时<strong>变量的一个访问规则</strong>。</p><p>js的作用域分为：</p><ul><li>全局作用域</li><li>局部作用域（es6 let&#x2F;const）</li></ul><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>为什么会有作用域链呢？js引入作用域链并非是多此一举（这里不要与js的原型链弄混），主要是为了提高js语言的容错率，在本层作用域未访问到的方法，会向上查找外层的作用域。知道找到全局作用域</p><p>举一个栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">C</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">A</span>()</span><br></pre></td></tr></table></figure><p>执行A函数，A函数中找不到关于a的声明，那么A就会沿着作用域链向上查找，知道找到变量a。</p><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>执行上下文与作用域不同，执行上下文是在代码运行的过程中创建的一个变量对象，这个对象我们无法直接访问，但是可以访问其中的变量、this对象等。<br>作用域是在函数声明的时候就确定的一套变量访问规则，而执行上下文时函数执行时才产生的一系列变量的环境，也就是说<strong>作用域定义了执行上下文中的变量访问规则</strong>(这句话很重要)，执行上下文在这个作用域规则的前提下进行变量查找，函数引用等具体操作。</p><p>执行上下文分为两个阶段：</p><ul><li>创建阶段<br>为了方便理解，可以将作用域和this指向当作执行上下文的组成部分。</li><li>执行阶段</li></ul><h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>执行栈，在其他编程语言中也被称为“调用栈”，是一个具有后进先出结构的栈，它用于存储代码执行期间创建的所有执行上下文。<br>执行栈是存放执行上下文的一个栈，当新的函数执行时，那么该函数的执行上下文便会入栈，执行结束之后便会出栈。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你必须掌握的web图片相关知识</title>
      <link href="/blog/2023/02/18/%E4%BD%A0%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84web%E5%9B%BE%E7%89%87%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
      <url>/blog/2023/02/18/%E4%BD%A0%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84web%E5%9B%BE%E7%89%87%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="常见图片格式"><a href="#常见图片格式" class="headerlink" title="常见图片格式"></a>常见图片格式</h2><h3 id="JPEG"><a href="#JPEG" class="headerlink" title="JPEG"></a>JPEG</h3><ul><li>优势：是最常见的图片格式，使用非常广泛，支持应用不同级别的压缩，适合携带和发送</li><li>劣势：有损压缩，不支持图层、透明度</li></ul><h3 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h3><ul><li>优势：支持比GIF更多的颜色，无损压缩，支持透明度</li><li>劣势：尺寸往往比JPEG更大，而且仅支持RGB色彩空间</li></ul><h3 id="TIFF"><a href="#TIFF" class="headerlink" title="TIFF"></a>TIFF</h3><ul><li>优势：无损压缩，支持多图层和透明度</li><li>劣势：文件很大</li></ul><h3 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h3><ul><li>优势：加载迅速，支持动画，无损压缩，尺寸较小，支持透明度。</li><li>劣势：最大仅支持256色</li></ul><h3 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h3><p>常用于网络矢量图</p><ul><li>优势：支持矢量内容，也支持文本和像素图，可以添加动画（通过外部代码交互）。放大缩小不会模糊。尺寸较小。可直接作为代码放在HTML里。可以被搜索引擎检索。</li><li>劣势：DOM节点较多，不利于首次渲染</li></ul><h3 id="WEBP"><a href="#WEBP" class="headerlink" title="WEBP"></a>WEBP</h3><p>谷歌开发的专用于web的新图片格式</p><ul><li>优势：相同质量图片尺寸更小，同时支持无损和有损压缩，支持图片透明度。</li><li>劣势：支持性较低</li></ul><h3 id="base64编码图片"><a href="#base64编码图片" class="headerlink" title="base64编码图片"></a>base64编码图片</h3><p>这是一种骚操作</p><ul><li>优势：可以减少浏览器请求次数</li><li>缺点：对于大的图片转化成base64之后会更大</li></ul><h2 id="常见图片压缩的方法"><a href="#常见图片压缩的方法" class="headerlink" title="常见图片压缩的方法"></a>常见图片压缩的方法</h2><h3 id="image-webpack-loader"><a href="#image-webpack-loader" class="headerlink" title="image-webpack-loader"></a>image-webpack-loader</h3><p>使用webpack配置的方式在每次打包时对图片进行压缩</p><h3 id="手动上传"><a href="#手动上传" class="headerlink" title="手动上传"></a>手动上传</h3><p>常见的网站</p><ul><li>tinypng</li><li>pp鸭</li></ul><h3 id="webp"><a href="#webp" class="headerlink" title="webp"></a>webp</h3><p>转化成webp格式</p>]]></content>
      
      
      
        <tags>
            
            <tag> 技术文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreeJs光与影</title>
      <link href="/blog/2023/02/06/ThreeJs%E5%85%89%E4%B8%8E%E5%BD%B1/"/>
      <url>/blog/2023/02/06/ThreeJs%E5%85%89%E4%B8%8E%E5%BD%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="常见的光的种类"><a href="#常见的光的种类" class="headerlink" title="常见的光的种类"></a>常见的光的种类</h2><p><a href="https://imgse.com/i/pScJxa9"><img src="https://s1.ax1x.com/2023/02/06/pScJxa9.png" alt="pScJxa9.png"></a></p><h3 id="环境光AmbientLight"><a href="#环境光AmbientLight" class="headerlink" title="环境光AmbientLight"></a>环境光AmbientLight</h3><p>环境光是没有特定方向的光源，主要是均匀整体改变物体表面的敏感效果。<br>环境光的颜色与物体的颜色rgb分别相乘，形成了我们看到的颜色</p><h3 id="点光源PointLight"><a href="#点光源PointLight" class="headerlink" title="点光源PointLight"></a>点光源PointLight</h3><p>可以理解为生活中的白炽灯，position可以设置光源的位置</p><h3 id="平行光DirectionalLight"><a href="#平行光DirectionalLight" class="headerlink" title="平行光DirectionalLight"></a>平行光DirectionalLight</h3><p>可以模拟太阳光，<strong>position只是确定平行光的照射方向的</strong></p><h3 id="聚光灯SpotLight"><a href="#聚光灯SpotLight" class="headerlink" title="聚光灯SpotLight"></a>聚光灯SpotLight</h3><p>就是类似手电筒的效果，舞台聚光灯</p><h2 id="设置影子"><a href="#设置影子" class="headerlink" title="设置影子"></a>设置影子</h2><p>想要物体产生影子，需要进行四个步骤</p><ol><li>渲染器开启影子渲染 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renderer.<span class="property">shadowMap</span>.<span class="property">enabled</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li>被投影物体设置可接收影子<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plane.<span class="property">receiveShadow</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li>物体设置可产生影子<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ball.<span class="property">castShadow</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li>光源可产生影子<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">light.<span class="property">castShadow</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>若上述步骤依然未产生影子，可能是正交影子相机的问题！<br>设置正交影子相机<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">directionalLight.<span class="property">shadow</span>.<span class="property">camera</span>.<span class="property">near</span> = <span class="number">10</span></span><br><span class="line">directionalLight.<span class="property">shadow</span>.<span class="property">camera</span>.<span class="property">far</span> = <span class="number">400</span></span><br><span class="line">directionalLight.<span class="property">shadow</span>.<span class="property">camera</span>.<span class="property">left</span> = -<span class="number">100</span>; <span class="comment">//产生阴影距离位置的最左边位置</span></span><br><span class="line">directionalLight.<span class="property">shadow</span>.<span class="property">camera</span>.<span class="property">right</span> = <span class="number">100</span>; <span class="comment">//最右边</span></span><br><span class="line">directionalLight.<span class="property">shadow</span>.<span class="property">camera</span>.<span class="property">top</span> = <span class="number">400</span>; <span class="comment">//最上边</span></span><br><span class="line">directionalLight.<span class="property">shadow</span>.<span class="property">camera</span>.<span class="property">bottom</span> = -<span class="number">400</span>; <span class="comment">//最下面</span></span><br><span class="line"><span class="comment">//这两个值决定使用多少像素生成阴影 默认512</span></span><br><span class="line">directionalLight.<span class="property">shadow</span>.<span class="property">mapSize</span>.<span class="property">height</span> = <span class="number">1024</span>;</span><br><span class="line">directionalLight.<span class="property">shadow</span>.<span class="property">mapSize</span>.<span class="property">width</span> = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> ThreeJs </tag>
            
            <tag> WebGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreeJs动画系统</title>
      <link href="/blog/2023/02/06/ThreeJs%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/"/>
      <url>/blog/2023/02/06/ThreeJs%E5%8A%A8%E7%94%BB%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="动画系统四大要素"><a href="#动画系统四大要素" class="headerlink" title="动画系统四大要素"></a>动画系统四大要素</h2><ul><li><p><strong>动画片段（AnimationClip）</strong></p><p>  是一个由不同的关键帧轨道组成的数组类型</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建位置关键帧对象</span></span><br><span class="line"><span class="keyword">const</span> posTrack = <span class="keyword">new</span> t.<span class="title class_">KeyframeTrack</span>(<span class="string">&#x27;Box.position&#x27;</span>, times, values)</span><br><span class="line"><span class="comment">// 创建颜色关键帧对象</span></span><br><span class="line"><span class="keyword">const</span> c = box.<span class="property">material</span>.<span class="property">color</span></span><br><span class="line"><span class="keyword">const</span> colTrack = <span class="keyword">new</span> t.<span class="title class_">KeyframeTrack</span>(<span class="string">&#x27;Box.material.color&#x27;</span>, [<span class="number">10</span>, <span class="number">20</span>], [c.<span class="property">r</span>, c.<span class="property">g</span>, c.<span class="property">b</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"><span class="comment">// 创建缩放关键帧对象</span></span><br><span class="line"><span class="keyword">const</span> scaTrack = <span class="keyword">new</span> t.<span class="title class_">KeyframeTrack</span>(<span class="string">&#x27;Ball.scale&#x27;</span>, [<span class="number">0</span>, <span class="number">20</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 动画持续事件</span></span><br><span class="line"><span class="keyword">const</span> duraction = <span class="number">20</span></span><br><span class="line"><span class="keyword">const</span> clip = <span class="keyword">new</span> t.<span class="title class_">AnimationClip</span>(<span class="string">&#x27;change&#x27;</span>, duraction, [posTrack, colTrack, scaTrack])</span><br></pre></td></tr></table></figure></li><li><p><strong>关键帧轨道（KeyframeTrace）</strong></p><p>  描述网格等某一属性随时间变化的状态</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> c = box.<span class="property">material</span>.<span class="property">color</span></span><br><span class="line"><span class="keyword">const</span> colTrack = <span class="keyword">new</span> t.<span class="title class_">KeyframeTrack</span>(<span class="string">&#x27;Box.material.color&#x27;</span>, [<span class="number">10</span>, <span class="number">20</span>], [c.<span class="property">r</span>, c.<span class="property">g</span>, c.<span class="property">b</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure></li><li><p><strong>动画混合器（AnimationMixer）</strong></p><p>  可以用来获取主角<strong>Animation Actions，从而操作动画，动画的播放必须要调用mixer.update()方法来推进时间</strong></p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mixer.<span class="title function_">update</span>(clock.<span class="title function_">getDelta</span>())</span><br></pre></td></tr></table></figure></li><li><p><strong>动画行为（AniamtionAction）</strong></p><p>  主要用来控制动画的行为，从而决定动画何时播放，何时快进等等。</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">AnimationAction</span> = mixer.<span class="title function_">clipAction</span>(clip);</span><br><span class="line"><span class="comment">//通过操作Action设置播放方式</span></span><br><span class="line"><span class="title class_">AnimationAction</span>.<span class="property">timeScale</span> = <span class="number">20</span>;<span class="comment">//默认1，可以调节播放速度</span></span><br><span class="line"><span class="comment">// AnimationAction.loop = THREE.LoopOnce; //不循环播放</span></span><br><span class="line"><span class="title class_">AnimationAction</span>.<span class="title function_">play</span>();<span class="comment">//开始播放</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> ThreeJs </tag>
            
            <tag> WebGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreeJs几何体</title>
      <link href="/blog/2023/02/06/ThreeJs%E5%87%A0%E4%BD%95%E4%BD%93/"/>
      <url>/blog/2023/02/06/ThreeJs%E5%87%A0%E4%BD%95%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h2 id="BufferGeometry"><a href="#BufferGeometry" class="headerlink" title="BufferGeometry"></a>BufferGeometry</h2><p>three中的几何体，例如：长方体BoxGeometry、球体SphereGeometry等几何体都是基于BufferGeometry构建的，BufferGeometry是一个没有任何形状的空几何体，你可以通过BufferGeometry自定义任何几何形状，具体一点说就是定义顶点数据。</p><h2 id="BufferAttribute"><a href="#BufferAttribute" class="headerlink" title="BufferAttribute"></a>BufferAttribute</h2><h3 id="顶点位置"><a href="#顶点位置" class="headerlink" title="顶点位置"></a>顶点位置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个BUffer类型的几何体对象</span></span><br><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferGeometry</span>()</span><br><span class="line"><span class="comment">// 类型数组创建顶点数据</span></span><br><span class="line"><span class="keyword">var</span> vertices = <span class="keyword">new</span> <span class="title class_">Float32Array</span>([</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点1坐标</span></span><br><span class="line">    <span class="number">50</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点2坐标</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="comment">//顶点3坐标</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="comment">//顶点4坐标</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="comment">//顶点5坐标</span></span><br><span class="line">    <span class="number">50</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="comment">//顶点6坐标</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建缓冲区对象</span></span><br><span class="line"><span class="keyword">var</span> attribute = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferAttribute</span>(vertices, <span class="number">3</span>) <span class="comment">// 三个一组表示顶点的xyz坐标</span></span><br><span class="line"><span class="comment">// 设置几何体attributes属性的位置属性</span></span><br><span class="line">geometry.<span class="property">attributes</span>.<span class="property">position</span> = attribute;</span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PointsMaterial</span>(&#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="number">0x00ff00</span>,</span><br><span class="line">    <span class="attr">size</span>: <span class="number">10.0</span> <span class="comment">//点对象像素尺寸</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> points = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Points</span>(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">scene.<span class="title function_">add</span>(points)</span><br></pre></td></tr></table></figure><h3 id="顶点颜色"><a href="#顶点颜色" class="headerlink" title="顶点颜色"></a>顶点颜色</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> colors = <span class="keyword">new</span> <span class="title class_">Float32Array</span>([</span><br><span class="line">    <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点1颜色</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="comment">//顶点2颜色</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="comment">//顶点3颜色</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="comment">//顶点4颜色</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="comment">//顶点5颜色</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="comment">//顶点6颜色</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">geometry.<span class="property">attributes</span>.<span class="property">color</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferAttribute</span>(colors, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于材质的属性.vertexColors可以查看Material文档介绍，</span></span><br><span class="line"><span class="comment">// 属性.vertexColors的默认值是THREE.NoColors，这也就是说模</span></span><br><span class="line"><span class="comment">// 型的颜色渲染效果取决于材质属性.color，如果把材质属性.vertexColors</span></span><br><span class="line"><span class="comment">// 的值设置为THREE.VertexColors,threejs渲染模型的时候就会使用几何体</span></span><br><span class="line"><span class="comment">// 的顶点颜色数据geometry.attributes.color。</span></span><br><span class="line"><span class="comment">// 开启点渲染模式</span></span><br><span class="line"><span class="keyword">var</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PointsMaterial</span>(&#123;</span><br><span class="line">    <span class="comment">// color: 0x00ff00,</span></span><br><span class="line">    <span class="attr">vertexColors</span>: <span class="literal">true</span>, <span class="comment">//以顶点颜色为准</span></span><br><span class="line">    <span class="attr">size</span>: <span class="number">10.0</span> <span class="comment">//点对象像素尺寸</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> points = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Points</span>(geometry, material); <span class="comment">//网格模型对象Mesh</span></span><br><span class="line">scene.<span class="title function_">add</span>(points)</span><br></pre></td></tr></table></figure><h3 id="顶点索引"><a href="#顶点索引" class="headerlink" title="顶点索引"></a>顶点索引</h3><p>网格模型Mesh对应的几何体BufferGeometry，拆分为多个三角后，很多三角形重合的顶点位置坐标是相同的，这时候如果你想减少顶点坐标数据量，可以借助几何体顶点索引geometry.index来实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有索引下的顶点位置坐标数据</span></span><br><span class="line"><span class="keyword">const</span> vertices = <span class="keyword">new</span> <span class="title class_">Float32Array</span>([</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点1坐标</span></span><br><span class="line">    <span class="number">80</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点2坐标</span></span><br><span class="line">    <span class="number">80</span>, <span class="number">80</span>, <span class="number">0</span>, <span class="comment">//顶点3坐标</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点4坐标   和顶点1位置相同</span></span><br><span class="line">    <span class="number">80</span>, <span class="number">80</span>, <span class="number">0</span>, <span class="comment">//顶点5坐标  和顶点3位置相同</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">80</span>, <span class="number">0</span>, <span class="comment">//顶点6坐标</span></span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 有索引下的顶点坐标数据</span></span><br><span class="line"><span class="keyword">const</span> vertices = <span class="keyword">new</span> <span class="title class_">Float32Array</span>([</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点1坐标</span></span><br><span class="line">    <span class="number">80</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="comment">//顶点2坐标</span></span><br><span class="line">    <span class="number">80</span>, <span class="number">80</span>, <span class="number">0</span>, <span class="comment">//顶点3坐标</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">80</span>, <span class="number">0</span>, <span class="comment">//顶点4坐标</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>索引的写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Uint16Array类型数组创建顶点索引数据</span></span><br><span class="line"><span class="keyword">const</span> indexes = <span class="keyword">new</span> <span class="title class_">Uint16Array</span>([</span><br><span class="line">    <span class="comment">// 下面索引值对应顶点位置数据中的顶点坐标</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 索引数据赋值给几何体的index属性</span></span><br><span class="line">geometry.<span class="property">index</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferAttribute</span>(indexes, <span class="number">1</span>); <span class="comment">//1个为一组</span></span><br></pre></td></tr></table></figure><h3 id="顶点法线"><a href="#顶点法线" class="headerlink" title="顶点法线"></a>顶点法线</h3><p>顶点的法线数据往往描述一个几何体对光照等效果的反应情况。一般不需要程序员自己设置，一般由模型进行导出。</p><h2 id="Curve"><a href="#Curve" class="headerlink" title="Curve"></a>Curve</h2><p>Curve并不是几何体，它可以通过给定点绘制一条曲线，然后再通过getPoints(n)将点数据拿到，并通过setFromPoints将点数据赋值给BufferGeometry</p><h3 id="样条曲线CatmullRomCurve3"><a href="#样条曲线CatmullRomCurve3" class="headerlink" title="样条曲线CatmullRomCurve3"></a>样条曲线CatmullRomCurve3</h3><p>样条曲线是穿过所有样例点的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三维样条曲线  Catmull-Rom算法</span></span><br><span class="line"><span class="keyword">var</span> curve = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">CatmullRomCurve3</span>([</span><br><span class="line">  <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(-<span class="number">50</span>, <span class="number">20</span>, <span class="number">90</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(-<span class="number">10</span>, <span class="number">40</span>, <span class="number">40</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">60</span>, -<span class="number">60</span>, <span class="number">0</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">70</span>, <span class="number">0</span>, <span class="number">80</span>)</span><br><span class="line">]);</span><br><span class="line"><span class="comment">//getPoints是基类Curve的方法，返回一个vector3对象作为元素组成的数组</span></span><br><span class="line"><span class="keyword">var</span> points = curve.<span class="title function_">getPoints</span>(<span class="number">100</span>); <span class="comment">//分段数100，返回101个顶点</span></span><br><span class="line"><span class="comment">// setFromPoints方法从points中提取数据改变几何体的顶点属性vertices</span></span><br><span class="line">geometry.<span class="title function_">setFromPoints</span>(points);</span><br></pre></td></tr></table></figure><h3 id="贝塞尔曲线CubicBezierCurve3"><a href="#贝塞尔曲线CubicBezierCurve3" class="headerlink" title="贝塞尔曲线CubicBezierCurve3"></a>贝塞尔曲线CubicBezierCurve3</h3><p>与样条曲线不同的是，贝塞尔曲线多了一个控制点，控制点不在贝塞尔曲线上。<br><a href="https://imgse.com/i/pScU3qO"><img src="https://s1.ax1x.com/2023/02/06/pScU3qO.png" alt="pScU3qO.png"></a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三维三次贝赛尔曲线</span></span><br><span class="line"><span class="keyword">var</span> curve = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">CubicBezierCurve3</span>(p1, p2, p3, p4);</span><br></pre></td></tr></table></figure><h3 id="组合曲线CurvePath"><a href="#组合曲线CurvePath" class="headerlink" title="组合曲线CurvePath"></a>组合曲线CurvePath</h3><p>将多个曲线组合，形成一条曲线</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建组合曲线对象CurvePath</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">CurvePath</span> = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">CurvePath</span>();</span><br><span class="line"><span class="comment">// 把多个线条插入到CurvePath中</span></span><br><span class="line"><span class="title class_">CurvePath</span>.<span class="property">curves</span>.<span class="title function_">push</span>(line1, arc, line2);</span><br></pre></td></tr></table></figure><h2 id="一些特殊的几何体"><a href="#一些特殊的几何体" class="headerlink" title="一些特殊的几何体"></a>一些特殊的几何体</h2><h3 id="曲线管道成型TubeGeometry"><a href="#曲线管道成型TubeGeometry" class="headerlink" title="曲线管道成型TubeGeometry"></a>曲线管道成型TubeGeometry</h3><p>形成一条曲线形状的管道</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">TubeGeometry</span>(path, <span class="number">40</span>, <span class="number">2</span>, <span class="number">25</span>);</span><br></pre></td></tr></table></figure><p>参数值<br>path扫描路径，基本类是Curve的路径构造函数<br>tubularSegments路径方向细分数，默认64<br>radius管道半径，默认1<br>radiusSegments管道圆弧细分数，默认8<br>closedBoolean值，管道是否闭合</p><h3 id="旋转成型LatheGeometry"><a href="#旋转成型LatheGeometry" class="headerlink" title="旋转成型LatheGeometry"></a>旋转成型LatheGeometry</h3><p><a href="https://imgse.com/i/pScauTg"><img src="https://s1.ax1x.com/2023/02/06/pScauTg.png" alt="pScauTg.png"></a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">LatheGeometry</span>(points,<span class="number">30</span>);</span><br></pre></td></tr></table></figure><h3 id="轮廓填充ShapeGeometry"><a href="#轮廓填充ShapeGeometry" class="headerlink" title="轮廓填充ShapeGeometry"></a>轮廓填充ShapeGeometry</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过顶点定义轮廓</span></span><br><span class="line"><span class="keyword">var</span> shape = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Shape</span>(points);</span><br><span class="line"><span class="comment">// shape可以理解为一个需要填充轮廓</span></span><br><span class="line"><span class="comment">// 所谓填充：ShapeGeometry算法利用顶点计算出三角面face3数据填充轮廓</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">ShapeGeometry</span>(shape, <span class="number">25</span>);</span><br></pre></td></tr></table></figure><h3 id="拉伸扫描成型ExtrudeGeometry"><a href="#拉伸扫描成型ExtrudeGeometry" class="headerlink" title="拉伸扫描成型ExtrudeGeometry"></a>拉伸扫描成型ExtrudeGeometry</h3><p><a href="https://imgse.com/i/pScaI1I"><img src="https://s1.ax1x.com/2023/02/06/pScaI1I.png" alt="pScaI1I.png"></a></p><p>参数含义<br>amount拉伸长度，默认100<br>bevelEnabled是否使用倒角<br>bevelSegments倒角细分数，默认3<br>bevelThickness倒角尺寸(经向)<br>curveSegments拉伸轮廓细分数<br>steps拉伸方向细分数<br>extrudePath扫描路径THREE.CurvePath，默认Z轴方向<br>material前后面材质索引号<br>extrudeMaterial拉伸面、倒角面材质索引号<br>bevelSize倒角尺寸(拉伸方向)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建扫描网格模型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> shape = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Shape</span>();</span><br><span class="line"><span class="comment">/**四条直线绘制一个矩形轮廓*/</span></span><br><span class="line">shape.<span class="title function_">moveTo</span>(<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//起点</span></span><br><span class="line">shape.<span class="title function_">lineTo</span>(<span class="number">0</span>,<span class="number">10</span>);<span class="comment">//第2点</span></span><br><span class="line">shape.<span class="title function_">lineTo</span>(<span class="number">10</span>,<span class="number">10</span>);<span class="comment">//第3点</span></span><br><span class="line">shape.<span class="title function_">lineTo</span>(<span class="number">10</span>,<span class="number">0</span>);<span class="comment">//第4点</span></span><br><span class="line">shape.<span class="title function_">lineTo</span>(<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//第5点</span></span><br><span class="line"><span class="comment">/**创建轮廓的扫描轨迹(3D样条曲线)*/</span></span><br><span class="line"><span class="keyword">var</span> curve = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">SplineCurve3</span>([</span><br><span class="line">   <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>( -<span class="number">10</span>, -<span class="number">50</span>, -<span class="number">50</span> ),</span><br><span class="line">   <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>( <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span> ),</span><br><span class="line">   <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>( <span class="number">8</span>, <span class="number">50</span>, <span class="number">50</span> ),</span><br><span class="line">   <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>( -<span class="number">5</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">ExtrudeGeometry</span>(<span class="comment">//拉伸造型</span></span><br><span class="line">   shape,<span class="comment">//二维轮廓</span></span><br><span class="line">   <span class="comment">//拉伸参数</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="attr">bevelEnabled</span>:<span class="literal">false</span>,<span class="comment">//无倒角</span></span><br><span class="line">       <span class="attr">extrudePath</span>:curve,<span class="comment">//选择扫描轨迹</span></span><br><span class="line">       <span class="attr">steps</span>:<span class="number">50</span><span class="comment">//扫描方向细分数</span></span><br><span class="line">   &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ThreeJs </tag>
            
            <tag> WebGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreeJs层级模型</title>
      <link href="/blog/2023/02/06/ThreeJs%E5%B1%82%E7%BA%A7%E6%A8%A1%E5%9E%8B/"/>
      <url>/blog/2023/02/06/ThreeJs%E5%B1%82%E7%BA%A7%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是层级模型"><a href="#什么是层级模型" class="headerlink" title="什么是层级模型"></a>什么是层级模型</h2><p>对于前端而言，层级模型并不陌生，例如HTML的DOM树结构，一些MVVM框架的父子组件组成的树结构等等。<br>Threejs中也有树结构，场景scene为根节点，Group、Object3D、Mesh等组成的树结构。<br>如下图所示:<br><a href="https://imgse.com/i/pSctfts"><img src="https://s1.ax1x.com/2023/02/06/pSctfts.png" alt="pSctfts.png"></a></p><h2 id="层级模型中的增删改查"><a href="#层级模型中的增删改查" class="headerlink" title="层级模型中的增删改查"></a>层级模型中的增删改查</h2><h3 id="增add"><a href="#增add" class="headerlink" title="增add"></a>增add</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">group.<span class="title function_">add</span>()</span><br></pre></td></tr></table></figure><h3 id="删remove"><a href="#删remove" class="headerlink" title="删remove"></a>删remove</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">group.<span class="title function_">remove</span>(mesh1)</span><br></pre></td></tr></table></figure><h3 id="模型命名-name"><a href="#模型命名-name" class="headerlink" title="模型命名.name"></a>模型命名.name</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mesh1.<span class="property">name</span> = <span class="string">&#x27;机器人眼睛&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="查找-getObjectById-、-getObjectByName"><a href="#查找-getObjectById-、-getObjectByName" class="headerlink" title="查找.getObjectById()、.getObjectByName()"></a>查找.getObjectById()、.getObjectByName()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历查找scene中复合条件的子对象，并返回id对应的对象</span></span><br><span class="line"><span class="keyword">var</span> idNode = scene.<span class="property">getObjectById</span> ( <span class="number">4</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(idNode);</span><br><span class="line"><span class="comment">// 遍历查找对象的子对象，返回name对应的对象（name是可以重名的，返回第一个）</span></span><br><span class="line"><span class="keyword">var</span> nameNode = scene.<span class="property">getObjectByName</span> ( <span class="string">&quot;左腿&quot;</span> );</span><br><span class="line">nameNode.<span class="property">material</span>.<span class="property">color</span>.<span class="title function_">set</span>(<span class="number">0xff0000</span>);</span><br></pre></td></tr></table></figure><h3 id="遍历traverse"><a href="#遍历traverse" class="headerlink" title="遍历traverse"></a>遍历traverse</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">scene.<span class="title function_">traverse</span>(<span class="keyword">function</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.<span class="property">type</span> === <span class="string">&quot;Group&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (obj.<span class="property">type</span> === <span class="string">&quot;Mesh&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;  &#x27;</span> + obj.<span class="property">name</span>);</span><br><span class="line">    obj.<span class="property">material</span>.<span class="property">color</span>.<span class="title function_">set</span>(<span class="number">0xffff00</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (obj.<span class="property">name</span> === <span class="string">&quot;左眼&quot;</span> | obj.<span class="property">name</span> === <span class="string">&quot;右眼&quot;</span>) &#123;</span><br><span class="line">    obj.<span class="property">material</span>.<span class="property">color</span>.<span class="title function_">set</span>(<span class="number">0x000000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 打印id属性</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">id</span>);</span><br><span class="line">  <span class="comment">// 打印该对象的父对象</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">parent</span>);</span><br><span class="line">  <span class="comment">// 打印该对象的子对象</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">children</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="本地位置坐标与世界位置坐标"><a href="#本地位置坐标与世界位置坐标" class="headerlink" title="本地位置坐标与世界位置坐标"></a>本地位置坐标与世界位置坐标</h2><p>获取本地坐标.position()<br>获取世界坐标.getWorldPosition()<br>由于上文所讲的树结构的关系，本地坐标可以理解为：子组件的世界观里只有父组件，其position是基于父组件而言的。而世界坐标是基于全局的坐标系而言的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ThreeJs </tag>
            
            <tag> WebGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreeJs几何体</title>
      <link href="/blog/2023/02/06/ThreeJs%E6%9D%90%E8%B4%A8/"/>
      <url>/blog/2023/02/06/ThreeJs%E6%9D%90%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="主要的材质种类"><a href="#主要的材质种类" class="headerlink" title="主要的材质种类"></a>主要的材质种类</h2><p><a href="https://imgse.com/i/pScepOx"><img src="https://s1.ax1x.com/2023/02/06/pScepOx.png" alt="pScepOx.png"></a></p><h2 id="对光照有效果的材质"><a href="#对光照有效果的材质" class="headerlink" title="对光照有效果的材质"></a>对光照有效果的材质</h2><p>MeshPhongMaterial高光材质（镜面反射）<br>MeshLambertMaterial粗糙材质（漫反射）</p>]]></content>
      
      
      
        <tags>
            
            <tag> ThreeJs </tag>
            
            <tag> WebGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreeJs模型对象</title>
      <link href="/blog/2023/02/06/ThreeJs%E6%A8%A1%E5%9E%8B%E5%AF%B9%E8%B1%A1/"/>
      <url>/blog/2023/02/06/ThreeJs%E6%A8%A1%E5%9E%8B%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://imgse.com/i/pScmK29"><img src="https://s1.ax1x.com/2023/02/06/pScmK29.png" alt="pScmK29.png"></a></p><h2 id="点模型Points"><a href="#点模型Points" class="headerlink" title="点模型Points"></a>点模型Points</h2><p>THREE.Points渲染点模型<br>默认是一些正方形的点</p><ul><li>Points</li></ul><h2 id="线模型Line"><a href="#线模型Line" class="headerlink" title="线模型Line"></a>线模型Line</h2><p>实现一些实线虚线效果</p><ul><li>Line线</li><li>LineLoop闭环线</li><li>LineSegments间断线</li></ul><h2 id="网格模型Mesh"><a href="#网格模型Mesh" class="headerlink" title="网格模型Mesh"></a>网格模型Mesh</h2><p>由一个个三角面构成的</p><ul><li>Mesh</li></ul><h2 id="模型基类Object3D"><a href="#模型基类Object3D" class="headerlink" title="模型基类Object3D"></a>模型基类Object3D</h2><p>上述的Points、Line、Mesh都继承自Object3D</p><h2 id="Clone与Copy"><a href="#Clone与Copy" class="headerlink" title="Clone与Copy"></a>Clone与Copy</h2><p>Clone是克隆出一个一摸一样的模型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mesh=<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(box,material);<span class="comment">//网格模型对象</span></span><br><span class="line"><span class="keyword">var</span> mesh2 = mesh.<span class="title function_">clone</span>();<span class="comment">//克隆网格模型</span></span><br></pre></td></tr></table></figure><p>Copy往往是将某个几何模型的某些属性赋值给另一个几何模型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">1.2</span>,<span class="number">2.6</span>,<span class="number">3.2</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Vector3</span>(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>);</span><br><span class="line">p2.<span class="title function_">copy</span>(p1)</span><br><span class="line"><span class="comment">// p2向量的xyz变为p1的xyz值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ThreeJs </tag>
            
            <tag> WebGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreeJs相机</title>
      <link href="/blog/2023/02/06/ThreeJs%E7%9B%B8%E6%9C%BA/"/>
      <url>/blog/2023/02/06/ThreeJs%E7%9B%B8%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p><a href="https://imgse.com/i/pScax9s"><img src="https://s1.ax1x.com/2023/02/06/pScax9s.png" alt="pScax9s.png"></a></p><h2 id="正交相机（正投影相机）OrthographicCamera"><a href="#正交相机（正投影相机）OrthographicCamera" class="headerlink" title="正交相机（正投影相机）OrthographicCamera"></a>正交相机（正投影相机）OrthographicCamera</h2><p>影子相机就是一个正交相机<br><a href="https://imgse.com/i/pScdiHU"><img src="https://s1.ax1x.com/2023/02/06/pScdiHU.png" alt="pScdiHU.png"></a><br>参数(属性)含义<br>left渲染空间的左边界<br>right渲染空间的右边界<br>top渲染空间的上边界<br>bottom渲染空间的下边界<br>nearnear属性表示的是从距离相机多远的位置开始渲染，一般情况会设置一个很小的值。 默认值0.1<br>farfar属性表示的是距离相机多远的位置截止渲染，如果设置的值偏小小，会有部分场景看不到。 默认值1000</p><h2 id="透视相机PerspectiveCamera"><a href="#透视相机PerspectiveCamera" class="headerlink" title="透视相机PerspectiveCamera"></a>透视相机PerspectiveCamera</h2><p>模拟人眼近大远小的特点，符合透视规律<br><a href="https://imgse.com/i/pScdQHO"><img src="https://s1.ax1x.com/2023/02/06/pScdQHO.png" alt="pScdQHO.png"></a><br>参数含义默认值<br>fovfov表示视场，所谓视场就是能够看到的角度范围，人的眼睛大约能够看到180度的视场，视角大小设置要根据具体应用，一般游戏会设置60~90度45<br>aspectaspect表示渲染窗口的长宽比，如果一个网页上只有一个全屏的canvas画布且画布上只有一个窗口，那么aspect的值就是网页窗口客户区的宽高比window.innerWidth&#x2F;window.innerHeight<br>nearnear属性表示的是从距离相机多远的位置开始渲染，一般情况会设置一个很小的值。0.1<br>farfar属性表示的是距离相机多远的位置截止渲染，如果设置的值偏小，会有部分场景看不到1000</p><h2 id="窗口大小变化自适应渲染"><a href="#窗口大小变化自适应渲染" class="headerlink" title="窗口大小变化自适应渲染"></a>窗口大小变化自适应渲染</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正交相机</span></span><br><span class="line"><span class="comment">// onresize 事件会在窗口被调整大小时发生</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onresize</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 重置渲染器输出画布canvas尺寸</span></span><br><span class="line">  renderer.<span class="title function_">setSize</span>(<span class="variable language_">window</span>.<span class="property">innerWidth</span>,<span class="variable language_">window</span>.<span class="property">innerHeight</span>);</span><br><span class="line">  <span class="comment">// 重置相机投影的相关参数</span></span><br><span class="line">  k = <span class="variable language_">window</span>.<span class="property">innerWidth</span>/<span class="variable language_">window</span>.<span class="property">innerHeight</span>;<span class="comment">//窗口宽高比</span></span><br><span class="line">  camera.<span class="property">left</span> = -s*k;</span><br><span class="line">  camera.<span class="property">right</span> = s*k;</span><br><span class="line">  camera.<span class="property">top</span> = s;</span><br><span class="line">  camera.<span class="property">bottom</span> = -s;</span><br><span class="line">  <span class="comment">// 渲染器执行render方法的时候会读取相机对象的投影矩阵属性projectionMatrix</span></span><br><span class="line">  <span class="comment">// 但是不会每渲染一帧，就通过相机的属性计算投影矩阵(节约计算资源)</span></span><br><span class="line">  <span class="comment">// 如果相机的一些属性发生了变化，需要执行updateProjectionMatrix ()方法更新相机的投影矩阵</span></span><br><span class="line">  camera.<span class="property">updateProjectionMatrix</span> ();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 透视相机</span></span><br><span class="line"><span class="comment">// onresize 事件会在窗口被调整大小时发生</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onresize</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 重置渲染器输出画布canvas尺寸</span></span><br><span class="line">  renderer.<span class="title function_">setSize</span>(<span class="variable language_">window</span>.<span class="property">innerWidth</span>,<span class="variable language_">window</span>.<span class="property">innerHeight</span>);</span><br><span class="line">  <span class="comment">// 全屏情况下：设置观察范围长宽比aspect为窗口宽高比</span></span><br><span class="line">  camera.<span class="property">aspect</span> = <span class="variable language_">window</span>.<span class="property">innerWidth</span>/<span class="variable language_">window</span>.<span class="property">innerHeight</span>;</span><br><span class="line">  <span class="comment">// 渲染器执行render方法的时候会读取相机对象的投影矩阵属性projectionMatrix</span></span><br><span class="line">  <span class="comment">// 但是不会每渲染一帧，就通过相机的属性计算投影矩阵(节约计算资源)</span></span><br><span class="line">  <span class="comment">// 如果相机的一些属性发生了变化，需要执行updateProjectionMatrix ()方法更新相机的投影矩阵</span></span><br><span class="line">  camera.<span class="property">updateProjectionMatrix</span> ();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ThreeJs </tag>
            
            <tag> WebGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端竞态问题</title>
      <link href="/blog/2023/02/06/%E5%89%8D%E7%AB%AF%E7%AB%9E%E6%80%81%E9%97%AE%E9%A2%98/"/>
      <url>/blog/2023/02/06/%E5%89%8D%E7%AB%AF%E7%AB%9E%E6%80%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是竞态问题"><a href="#什么是竞态问题" class="headerlink" title="什么是竞态问题"></a>什么是竞态问题</h2><p>由于js是单线程执行的方式，因此对于一批网络请求，我们可以掌握其执行的顺序，但是其返回的顺序是我们不可控的。<br>因此，对于一些需要严格返回顺序的需求，例如分页、搜索等，我们需要考虑请求的竞态问题。</p><h2 id="目前的两大解决方法"><a href="#目前的两大解决方法" class="headerlink" title="目前的两大解决方法"></a>目前的两大解决方法</h2><h3 id="一、终止"><a href="#一、终止" class="headerlink" title="一、终止"></a>一、终止</h3><p>也就是在本次请求发起前，终止上一次请求。<br>主要的实现原理是利用xhr的abort方法，对于axios来说，是利用让其内部调用reject与 xhr.abort，因此我们需要对reject的catch错误处理进行特殊判断。</p><h3 id="二、忽略"><a href="#二、忽略" class="headerlink" title="二、忽略"></a>二、忽略</h3><p>也就是在本次请求发起过程中，忽略之前网络请求返回的结果。<br>主要的实现原理就是，每次请求之前生成一个request id，只接受本次id返回的执行结果。</p><h2 id="利弊分析"><a href="#利弊分析" class="headerlink" title="利弊分析"></a>利弊分析</h2><p>终止：可以减少sever的消耗，减轻其压力。<br>忽略：不依赖请求的api，更加通用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 技术文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC与序列化？？</title>
      <link href="/blog/2023/01/16/RPC%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/blog/2023/01/16/RPC%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="RPC与序列化？？"><a href="#RPC与序列化？？" class="headerlink" title="RPC与序列化？？"></a>RPC与序列化？？</h2><h3 id="什么是RPC？"><a href="#什么是RPC？" class="headerlink" title="什么是RPC？"></a>什么是RPC？</h3><p>RPC协议的主要目的是做到不同服务方法间调用做到像调用相同服务间的本地方法一样。</p><p>以我所在的公司业务而言，公司的业务是数据库，用户想要通过一些api操作数据库中数据，就需要调用server那边的一些方法，因此采用了websocket协议，通过函数名+参数的方式告知远程server，我要调用哪个方法来操纵数据库，因此，就需要传递方法名和参数给server，但是又有一些问题，在参数传递的过程中，字符串和数字参数还好，要是对象参数呢，这时候就需要序列化对象。</p><h3 id="什么是序列化？"><a href="#什么是序列化？" class="headerlink" title="什么是序列化？"></a>什么是序列化？</h3><p>序列化就是将对象的状态信转化为可存储可传输的形式的过程</p><p>例如原生的js中，存在JSON.stringify将对象序列化成JSON字符串，这也是一种序列化方式，</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>图形学基础知识</title>
      <link href="/blog/2022/12/25/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/blog/2022/12/25/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="视锥体"><a href="#视锥体" class="headerlink" title="视锥体"></a>视锥体</h2><p>视锥体是对透视相机而言的<br>如图所示：<br><a href="https://imgse.com/i/zxFnbQ"><img src="https://s1.ax1x.com/2022/12/25/zxFnbQ.png" alt="zxFnbQ.png"></a><br>视锥体是由近截面、远截面、锥体围成的一个图形，在视锥体之外的物体均不可见。<br>fov视角，也就是锥体的角度</p><h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><p>使用控制器查看3d物体<br>以轨道控制器为例(OrbitControls)<br>可以控制摄像机(Camera)的移动，从而实现鼠标左键转动、右键移动，滚轮缩放的实现。</p><h2 id="坐标轴辅助器-AxesHelper"><a href="#坐标轴辅助器-AxesHelper" class="headerlink" title="坐标轴辅助器(AxesHelper)"></a>坐标轴辅助器(AxesHelper)</h2><p>用于简单模拟3个坐标轴的对象.<br>红色代表 X 轴. 绿色代表 Y 轴. 蓝色代表 Z 轴.</p><h2 id="元素状态"><a href="#元素状态" class="headerlink" title="元素状态"></a>元素状态</h2><ul><li>position位置</li><li>rotation角度</li><li>scale缩放</li></ul><h2 id="GSAP"><a href="#GSAP" class="headerlink" title="GSAP"></a>GSAP</h2><p>GreenSock动画平台，（GSAP）可以对JavaScript可以操作的所有内容进行动画处理（CSS属性，SVG，React，画布，通用对象等），同时解决了不同浏览器上存在的兼容性问题，而且速度极快（比jQuery 快20倍）。大约有1000万个站点和许多主要品牌都使用 GSAP。</p><p>动画其实是每秒多次改变元素属性值，元素看起来就仿佛在动一样，比如淡入淡出，旋转，移动等。而GSAP捕捉一个起始值和一个结束值，然后每秒在它们之间插值60次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = gsap.<span class="title function_">from</span>(cube.<span class="property">position</span>, &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">duration</span>: <span class="number">5</span> &#125;)</span><br><span class="line">gsap.<span class="title function_">to</span>(cube.<span class="property">rotation</span>, &#123; <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">duration</span>: <span class="number">25</span> &#125;)</span><br><span class="line">a.<span class="title function_">isActive</span>() <span class="comment">// 动画是否暂停</span></span><br><span class="line">a.<span class="title function_">pause</span>() <span class="comment">// 暂停</span></span><br><span class="line">a.<span class="title function_">resume</span>() <span class="comment">// 恢复动画</span></span><br></pre></td></tr></table></figure><h2 id="样条曲线与贝塞尔曲线"><a href="#样条曲线与贝塞尔曲线" class="headerlink" title="样条曲线与贝塞尔曲线"></a>样条曲线与贝塞尔曲线</h2><p>样条曲线与贝塞尔曲线都是一种让计算机识别的描述曲线的一种方式。</p><h3 id="样条曲线"><a href="#样条曲线" class="headerlink" title="样条曲线"></a>样条曲线</h3><p>采用Catmull-Rom算法，从一系列的点创建一条平滑的三维样条曲线。<br>其中构造出来的光滑曲线穿过所给的点列</p><h3 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h3><p>贝塞尔曲线与样条曲线不同，多了一个控制点的概念，控制点不在贝塞尔曲线上</p>]]></content>
      
      
      
        <tags>
            
            <tag> ThreeJs </tag>
            
            <tag> WebGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreeJs初探</title>
      <link href="/blog/2022/12/19/ThreeJs%E5%88%9D%E6%8E%A2/"/>
      <url>/blog/2022/12/19/ThreeJs%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="ThreeJs官网DEMO总结"><a href="#ThreeJs官网DEMO总结" class="headerlink" title="ThreeJs官网DEMO总结"></a>ThreeJs官网DEMO总结</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>My first three.js app<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/three.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 创建场景相机渲染器</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> scene = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Scene</span>()</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 使用透视相机</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// paramps1事业角度</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// paramps2 长宽比</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// paramps3 4 近截面与远截面 </span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> camera = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PerspectiveCamera</span>(<span class="number">75</span>, <span class="variable language_">window</span>.<span class="property">innerWidth</span> / <span class="variable language_">window</span>.<span class="property">innerHeight</span>, <span class="number">0.1</span>, <span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> renderer = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">WebGLRenderer</span>();</span></span><br><span class="line"><span class="language-javascript">        renderer.<span class="title function_">setSize</span>(<span class="variable language_">window</span>.<span class="property">innerWidth</span>, <span class="variable language_">window</span>.<span class="property">innerHeight</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(renderer.<span class="property">domElement</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 初始步骤搭建完毕，下面创建绘图</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 创建一个立方体对象</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BoxGeometry</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 创建一个材质</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123; <span class="attr">color</span>: <span class="number">0xffffff</span> &#125;);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 创建一个网格</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 之所以会有网格这种东西是因为：几何体是不能被渲染的，只有几何体和材质结合成网格才能被渲染到屏幕上</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> cube = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry, material);</span></span><br><span class="line"><span class="language-javascript">        scene.<span class="title function_">add</span>(cube);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 由于默认scene.add会将物体放在0，0，0位置，与相机重叠，因此需要移动相机位置</span></span></span><br><span class="line"><span class="language-javascript">        camera.<span class="property">position</span>.<span class="property">z</span> = <span class="number">5</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 开始真正渲染场景了</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 创建渲染函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">animate</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            cube.<span class="property">rotation</span>.<span class="property">x</span> += <span class="number">0.01</span>;</span></span><br><span class="line"><span class="language-javascript">            cube.<span class="property">rotation</span>.<span class="property">y</span> += <span class="number">0.01</span>;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 会在浏览器下次重绘之前执行该回调函数</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">requestAnimationFrame</span>(animate);</span></span><br><span class="line"><span class="language-javascript">            renderer.<span class="title function_">render</span>(scene, camera);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">animate</span>();</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>ThreeJs三大要素：场景、相机、渲染器</li><li>将渲染器DOM节点插入DOM中（cnavas），放入场景和相机进行渲染</li><li>单独创建一个几何体放到场景中是看不见的，只有结合体结合材质形成网格之后才能出现在场景中。</li><li>采用window.requestAnimationFrame代替使用setTimeout,在重绘之前执行动画函数。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> ThreeJs </tag>
            
            <tag> WebGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-Router(8)</title>
      <link href="/blog/2022/12/11/React-router/"/>
      <url>/blog/2022/12/11/React-router/</url>
      
        <content type="html"><![CDATA[<h2 id="React-Router"><a href="#React-Router" class="headerlink" title="React-Router"></a>React-Router</h2><p>先来一个demo</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BrowserRouter</span>, <span class="title class_">Routes</span>, <span class="title class_">Route</span>, <span class="title class_">Link</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MRouterHome</span> <span class="keyword">from</span> <span class="string">&#x27;./MRouterHome&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MRouterAbout</span> <span class="keyword">from</span> <span class="string">&#x27;./MRouterAbout&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">MRouter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="comment">// history模式</span></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#123;</span>&quot;/&quot; | &quot;/<span class="attr">home</span>&quot;&#125; <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">MRouterHome</span>&gt;</span><span class="tag">&lt;/<span class="name">MRouterHome</span>&gt;</span>&#125;&gt;<span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">MRouterAbout</span>&gt;</span><span class="tag">&lt;/<span class="name">MRouterAbout</span>&gt;</span>&#125;&gt;<span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="HashRouter和BrowerRouter"><a href="#HashRouter和BrowerRouter" class="headerlink" title="HashRouter和BrowerRouter"></a><strong>HashRouter和BrowerRouter</strong></h3><p>也就是Hash模式和History模式<br>一般一个React应用该标签只引入一次</p><h3 id="Link"><a href="#Link" class="headerlink" title="Link"></a><strong>Link</strong></h3><p>指定跳转地址</p><h3 id="Routes"><a href="#Routes" class="headerlink" title="Routes"></a><strong>Routes</strong></h3><p>定义路由出口，满足条件的路由组件会渲染到其内部</p><h3 id="Route"><a href="#Route" class="headerlink" title="Route"></a><strong>Route</strong></h3><p>完成路由匹配的</p><h3 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a><strong>编程式路由导航</strong></h3><p>通过useNavigate钩子函数进行跳转</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> navigate = <span class="title function_">useNavigate</span>()</span><br><span class="line"><span class="title function_">navigate</span>(<span class="string">&#x27;/login&#x27;</span>)</span><br></pre></td></tr></table></figure><p>searchParamps传参</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传参</span></span><br><span class="line"><span class="title function_">navigate</span>(<span class="string">&#x27;/about?id=ae123432sdc4646c&#x27;</span>)</span><br><span class="line"><span class="comment">// 取参</span></span><br><span class="line"><span class="keyword">let</span> [paramps] = <span class="title function_">useSearchParamps</span>()</span><br><span class="line"><span class="keyword">let</span> id = paramps.<span class="title function_">get</span>(<span class="string">&#x27;id&#x27;</span>)</span><br></pre></td></tr></table></figure><p>paramps传参</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传参</span></span><br><span class="line">about/:id</span><br><span class="line"><span class="title function_">navigate</span>(<span class="string">&#x27;/about/ae123432sdc4646c&#x27;</span>)</span><br><span class="line"><span class="comment">// 取参</span></span><br><span class="line"><span class="keyword">let</span> paramps = <span class="title function_">useParamps</span>()</span><br><span class="line"><span class="keyword">let</span> id = paramps.<span class="property">id</span></span><br></pre></td></tr></table></figure><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p>Route标签里面嵌套Route<br>Outlet定义二级路由出口</p><h3 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h3><p>使用index代替path</p><h3 id="404匹配"><a href="#404匹配" class="headerlink" title="404匹配"></a>404匹配</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path = <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ts类型体操</title>
      <link href="/blog/2022/12/08/Ts%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D/"/>
      <url>/blog/2022/12/08/Ts%E7%B1%BB%E5%9E%8B%E4%BD%93%E6%93%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="Ts类型体操"><a href="#Ts类型体操" class="headerlink" title="Ts类型体操"></a>Ts类型体操</h2><p><strong>该篇博文主要记录自己刷Ts类型体操的过程。</strong><br><a href="https://github.com/type-challenges/type-challenges/blob/main/README.zh-CN.md">附上刷题链接</a></p><h3 id="实现Pick"><a href="#实现Pick" class="headerlink" title="实现Pick"></a>实现Pick</h3><p>实现 TS 内置的 Pick&lt;T, K&gt;，但不可以使用它。从类型 T 中选择出属性 K，构造成一个新的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Pick</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">    [p <span class="keyword">in</span> K]:T[p]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现Readonly"><a href="#实现Readonly" class="headerlink" title="实现Readonly"></a>实现Readonly</h3><p>该 Readonly 会接收一个 泛型参数，并返回一个完全一样的类型，只是所有属性都会被 readonly 所修饰。也就是不可以再对该对象的属性赋值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyReadonly</span>&lt;T&gt; = &#123;</span><br><span class="line">    <span class="keyword">readonly</span> [k <span class="keyword">in</span> keyof T]: T[k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="元组转换为对象"><a href="#元组转换为对象" class="headerlink" title="元组转换为对象"></a>元组转换为对象</h3><p>传入一个元组类型，将这个元组类型转换为对象类型，这个对象类型的键&#x2F;值都是从元组中遍历出来。<br>例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tuple = [<span class="string">&#x27;tesla&#x27;</span>, <span class="string">&#x27;model 3&#x27;</span>, <span class="string">&#x27;model X&#x27;</span>, <span class="string">&#x27;model Y&#x27;</span>] <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line"><span class="keyword">type</span> result = <span class="title class_">TupleToObject</span>&lt;<span class="keyword">typeof</span> tuple&gt; <span class="comment">// expected &#123; &#x27;tesla&#x27;: &#x27;tesla&#x27;, &#x27;model 3&#x27;: &#x27;model 3&#x27;, &#x27;model X&#x27;: &#x27;model X&#x27;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TupleToObject</span>&lt;T <span class="keyword">extends</span> <span class="keyword">readonly</span> <span class="built_in">any</span>[]&gt; = &#123;</span><br><span class="line">    [i <span class="keyword">in</span> T[<span class="built_in">number</span>]]: T[<span class="built_in">number</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> tuple = [<span class="string">&#x27;tesla&#x27;</span>, <span class="string">&#x27;model 3&#x27;</span>, <span class="string">&#x27;model X&#x27;</span>, <span class="string">&#x27;model Y&#x27;</span>] <span class="keyword">as</span> <span class="keyword">const</span></span><br><span class="line"><span class="keyword">type</span> result = <span class="title class_">TupleToObject</span>&lt;<span class="keyword">typeof</span> tuple&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">aa</span>: result = &#123;</span><br><span class="line">    <span class="string">&#x27;tesla&#x27;</span>: <span class="string">&#x27;tesla&#x27;</span>, <span class="string">&#x27;model 3&#x27;</span>: <span class="string">&#x27;model 3&#x27;</span>, <span class="string">&#x27;model X&#x27;</span>: <span class="string">&#x27;model X&#x27;</span>,</span><br><span class="line">    <span class="string">&quot;model Y&quot;</span>: <span class="string">&quot;tesla&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第一个元素"><a href="#第一个元素" class="headerlink" title="第一个元素"></a>第一个元素</h3><p>实现一个通用First<T>，它接受一个数组T并返回它的第一个元素的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">First</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T[<span class="string">&#x27;length&#x27;</span>] <span class="keyword">extends</span> <span class="number">0</span> ? <span class="built_in">never</span> : T[<span class="number">0</span>] </span><br></pre></td></tr></table></figure><h3 id="获取元组长度"><a href="#获取元组长度" class="headerlink" title="获取元组长度"></a>获取元组长度</h3><p>创建一个通用的Length，接受一个readonly的数组，返回这个数组的长度。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Length</span>&lt;T <span class="keyword">extends</span> <span class="keyword">readonly</span> <span class="built_in">unknown</span>[]&gt; = T[<span class="string">&#x27;length&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="Exclude"><a href="#Exclude" class="headerlink" title="Exclude"></a>Exclude</h3><p>从联合类型T中排除U的类型成员，来构造一个新的类型。<br>例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">MyExclude</span>&lt;<span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27;b&#x27;</span> | <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&gt; <span class="comment">// &#x27;b&#x27; | &#x27;c&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyExclude</span>&lt;T, U <span class="keyword">extends</span> T&gt; = T <span class="keyword">extends</span> U ? <span class="built_in">never</span> : T</span><br></pre></td></tr></table></figure><p>是不是很反直觉？<br>对于联合类型使用extends，ts会进行分配类型，也就是将T的每一个累心与extends后边类型进行extends，返回每一个结果的联合类型。</p><h3 id="Awaited"><a href="#Awaited" class="headerlink" title="Awaited"></a>Awaited</h3><p>假如我们有一个 Promise 对象，这个 Promise 对象会返回一个类型。在 TS 中，我们用 Promise 中的 T 来描述这个 Promise 返回的类型。请你实现一个类型，可以获取这个类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ExampleType</span> = <span class="title class_">Promise</span>&lt;<span class="built_in">string</span>&gt;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">MyAwaited</span>&lt;<span class="title class_">ExampleType</span>&gt; <span class="comment">// string</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MyAwaited</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Promise</span>&lt;<span class="built_in">any</span>&gt;&gt; = <span class="title class_">Awaited</span>&lt;T&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="If"><a href="#If" class="headerlink" title="If"></a>If</h3><p>实现一个 IF 类型，它接收一个条件类型 C ，一个判断为真时的返回类型 T ，以及一个判断为假时的返回类型 F。 C 只能是 true 或者 false， T 和 F 可以是任意类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">If</span>&lt;C <span class="keyword">extends</span> <span class="built_in">boolean</span>, T, F&gt; = C <span class="keyword">extends</span> <span class="literal">true</span> ? T : F</span><br></pre></td></tr></table></figure><h3 id="Concat"><a href="#Concat" class="headerlink" title="Concat"></a>Concat</h3><p>在类型系统里实现 JavaScript 内置的 Array.concat 方法，这个类型接受两个参数，返回的新数组类型应该按照输入参数从左到右的顺序合并为一个新的数组。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Concat</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], U <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = [...T, ...U]</span><br></pre></td></tr></table></figure><h3 id="Includes"><a href="#Includes" class="headerlink" title="Includes"></a>Includes</h3><p>在类型系统里实现 JavaScript 的 <code>Array.includes</code> 方法，这个类型接受两个参数，返回的类型要么是 <code>true</code> 要么是 <code>false</code>。<br>例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> isPillarMen = <span class="title class_">Includes</span>&lt;[<span class="string">&#x27;Kars&#x27;</span>, <span class="string">&#x27;Esidisi&#x27;</span>, <span class="string">&#x27;Wamuu&#x27;</span>, <span class="string">&#x27;Santana&#x27;</span>], <span class="string">&#x27;Dio&#x27;</span>&gt; <span class="comment">// expected to be `false`</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Includes</span>&lt;T <span class="keyword">extends</span> <span class="keyword">readonly</span> <span class="built_in">unknown</span>[], U&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> [infer <span class="title class_">First</span>, ...infer <span class="title class_">Rest</span>] </span><br><span class="line">    ? <span class="title class_">Equal</span>&lt;<span class="title class_">First</span>, U&gt; <span class="keyword">extends</span> <span class="literal">true</span> ? <span class="literal">true</span> : <span class="title class_">Includes</span>&lt;<span class="title class_">Rest</span>, U&gt;</span><br><span class="line">    : <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h3><p>在类型系统里实现通用的 <code>Array.push</code> 。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Push</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[],  U <span class="keyword">extends</span> <span class="built_in">any</span>[]|<span class="built_in">any</span>&gt; = [...T,U]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Ts </tag>
            
            <tag> Js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ts魅力</title>
      <link href="/blog/2022/12/08/Ts%E7%9A%84%E9%AD%85%E5%8A%9B/"/>
      <url>/blog/2022/12/08/Ts%E7%9A%84%E9%AD%85%E5%8A%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="Ts魅力"><a href="#Ts魅力" class="headerlink" title="Ts魅力"></a>Ts魅力</h2><p><strong>本文只适合对Ts有一定基础，想要进一步提升Ts实力的人看！！！</strong></p><h3 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h3><p><strong>用于返回指定对象键值的联合类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> b = keyof p</span><br><span class="line"><span class="comment">// 类型b的取值只能是x或者y</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: b = <span class="string">&#x27;x&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="extends不只有继承"><a href="#extends不只有继承" class="headerlink" title="extends不只有继承"></a>extends不只有继承</h3><p><strong>extends还可以进行类型判断,如果extends前面的类型能够赋值给extends后面的类型，那么表达式判断为真，否则为假。</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A1 &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> A2 <span class="keyword">extends</span> A1 &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A = <span class="variable constant_">A2</span> <span class="keyword">extends</span> <span class="variable constant_">A1</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="comment">// 无报错说明x类型是true，也就是A1 extends A2成立</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">x</span>: A = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="定义类型时使用-P-in-K-这种方式"><a href="#定义类型时使用-P-in-K-这种方式" class="headerlink" title="定义类型时使用[P in K]这种方式"></a>定义类型时使用[P in K]这种方式</h3><p><strong>用于遍历联合类型，作为当前类型的键值</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Union</span> = <span class="string">&#x27;name&#x27;</span> | <span class="string">&#x27;age&#x27;</span> | <span class="string">&#x27;sex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> X = &#123;</span><br><span class="line">    [K <span class="keyword">in</span> <span class="title class_">Union</span>]: <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">c</span>: X = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Aran&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">12</span>,</span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="readonly只读修饰符"><a href="#readonly只读修饰符" class="headerlink" title="readonly只读修饰符"></a>readonly只读修饰符</h3><p><strong>实现一个类型，接收一个泛型，返回的该类型就是传入的该泛型的只读模式</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MReadonly</span>&lt;T&gt; = &#123;</span><br><span class="line">    <span class="keyword">readonly</span> [k <span class="keyword">in</span> keyof T]: T[k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="typeof-关键字"><a href="#typeof-关键字" class="headerlink" title="typeof 关键字"></a>typeof 关键字</h3><p><strong>指的是构造出与typeof后边类型一致的类型</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cd = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> P = <span class="keyword">typeof</span> cd</span><br><span class="line"><span class="keyword">const</span> <span class="attr">po</span>: P = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Ts断言与类型守卫"><a href="#Ts断言与类型守卫" class="headerlink" title="Ts断言与类型守卫"></a>Ts断言与类型守卫</h3><p><strong>所谓断言就是断定、确定、绝对的意思；所以简单来讲，类型断言就是保证数据类型一定是所要求的类型</strong><br><strong>类型推断：</strong></p><ol><li>TypeScript里，在有些没有明确指出类型的地方，类型推论会帮助提供类型</li><li>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查<br><strong>类型断言：</strong></li><li>类型断言可以将一个联合类型的变量，指定为一个更加具体的类型</li><li>不能将联合类型断言为不存在的类型</li><li>非空断言!代表对象是非 null 非 undefined<br>类型守卫函数<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isUser</span>(<span class="params">arg: <span class="built_in">any</span></span>): arg is <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> arg.<span class="property">name</span> == <span class="string">&#x27;string&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> arg.<span class="property">age</span> == <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>经过这样的类型断言后就不会报错了<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_">isUser</span>(errorType)) &#123;</span><br><span class="line">    <span class="title function_">showUser</span>(errorType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="unknow、void、never-类型"><a href="#unknow、void、never-类型" class="headerlink" title="unknow、void、never 类型"></a>unknow、void、never 类型</h3><p><strong>与any类型区别是：当 unknown 类型被确定是某个类型之前,它不能被进行任何操作</strong><br><strong>void代表值为空，因为只能为它赋值null 和 undefined</strong><br><strong>拥有 never 返回值类型的函数无法正常返回，无法终止或会抛出异常</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Ts </tag>
            
            <tag> Js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>意大利面的做法</title>
      <link href="/blog/2022/12/07/%E6%84%8F%E5%A4%A7%E5%88%A9%E9%9D%A2%E7%9A%84%E5%81%9A%E6%B3%95/"/>
      <url>/blog/2022/12/07/%E6%84%8F%E5%A4%A7%E5%88%A9%E9%9D%A2%E7%9A%84%E5%81%9A%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="意大利面"><a href="#意大利面" class="headerlink" title="意大利面"></a>意大利面</h2><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><h3 id="配方"><a href="#配方" class="headerlink" title="配方"></a>配方</h3><ul><li>意大利面</li><li>肉</li><li>洋葱</li><li>海盐</li><li>黑胡椒</li><li>酱油</li><li>十三香</li></ul><h3 id="制作步骤"><a href="#制作步骤" class="headerlink" title="制作步骤"></a>制作步骤</h3><ol><li>煮面</li><li>制作黑胡椒酱<ol><li>切小肉丁、洋葱丁、姜片备用</li><li>向砂锅倒油，小火</li><li>将肉丁、洋葱丁、姜片放入锅中匀炒</li><li>放海盐、黑胡椒、十三香、酱油（两小勺）、4-8小勺水，小火慢熬，中火收汤</li></ol></li><li>装盘</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 菜谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛奶焗虾的做法</title>
      <link href="/blog/2022/12/07/%E7%89%9B%E5%A5%B6%E7%84%97%E8%99%BE%E7%9A%84%E5%81%9A%E6%B3%95/"/>
      <url>/blog/2022/12/07/%E7%89%9B%E5%A5%B6%E7%84%97%E8%99%BE%E7%9A%84%E5%81%9A%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="牛奶焗虾的做法"><a href="#牛奶焗虾的做法" class="headerlink" title="牛奶焗虾的做法"></a>牛奶焗虾的做法</h2><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><a href="https://imgse.com/i/zgifIO"><img src="https://s1.ax1x.com/2022/12/07/zgifIO.jpg" alt="zgifIO.jpg"></a></p><h3 id="配方"><a href="#配方" class="headerlink" title="配方"></a>配方</h3><ul><li>牛奶半袋</li><li>黑胡椒</li><li>海盐</li><li>大虾</li><li>洋葱碎</li><li>面粉一勺</li><li>西芹碎(非必须)</li></ul><h3 id="制作步骤"><a href="#制作步骤" class="headerlink" title="制作步骤"></a>制作步骤</h3><ol><li>热锅烧油</li><li>放入大虾，煎至两面全红</li><li>撒上少许海盐、黑胡椒</li><li>加入一勺面粉，翻炒使其均匀挂在大虾上</li><li>加入半袋牛奶、圆葱，大火收汤</li><li>装盘</li><li>撒上少许西芹碎</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 菜谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蛋炒饭的做法</title>
      <link href="/blog/2022/12/07/%E8%9B%8B%E7%82%92%E9%A5%AD%E7%9A%84%E5%81%9A%E6%B3%95/"/>
      <url>/blog/2022/12/07/%E8%9B%8B%E7%82%92%E9%A5%AD%E7%9A%84%E5%81%9A%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="蛋炒饭的做法"><a href="#蛋炒饭的做法" class="headerlink" title="蛋炒饭的做法"></a>蛋炒饭的做法</h2><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><a href="https://imgse.com/i/zgFkwV"><img src="https://s1.ax1x.com/2022/12/07/zgFkwV.jpg" alt="zgFkwV.jpg"></a></p><h3 id="配方"><a href="#配方" class="headerlink" title="配方"></a>配方</h3><ul><li>米饭</li><li>鸡蛋液（两个鸡蛋）</li><li>十三香</li><li>食盐</li><li>酱油</li><li>大虾（非必须）</li></ul><h3 id="制作步骤"><a href="#制作步骤" class="headerlink" title="制作步骤"></a>制作步骤</h3><ol><li>热锅烧油</li><li>煎大虾至两面变红</li><li>加入鸡蛋液，等待其凝固</li><li>加入米饭、食盐、十三香、酱油，中火翻炒</li><li>装盘</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 菜谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-Redux(7)</title>
      <link href="/blog/2022/12/03/React-Redux/"/>
      <url>/blog/2022/12/03/React-Redux/</url>
      
        <content type="html"><![CDATA[<h2 id="React-Redux"><a href="#React-Redux" class="headerlink" title="React-Redux"></a>React-Redux</h2><p>是基于React封装的Redux库，仅支持react</p><h3 id="三大核心概念"><a href="#三大核心概念" class="headerlink" title="三大核心概念"></a>三大核心概念</h3><p><strong>1. state</strong><br>存放公共状态</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">todos</span>: [&#123;</span><br><span class="line">     <span class="attr">text</span>: <span class="string">&#x27;Eat food&#x27;</span>,</span><br><span class="line">     <span class="attr">completed</span>: <span class="literal">true</span></span><br><span class="line"> &#125;, &#123;</span><br><span class="line">     <span class="attr">text</span>: <span class="string">&#x27;Exercise&#x27;</span>,</span><br><span class="line">     <span class="attr">completed</span>: <span class="literal">false</span></span><br><span class="line"> &#125;],</span><br><span class="line"> <span class="attr">visibilityFilter</span>: <span class="string">&#x27;SHOW_COMPLETED&#x27;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>2. action</strong><br>就是一个普通js对象，用来描述发生了什么。<br>强制使用 action 来描述所有变化带来的好处是可以清晰地知道应用中到底发生了什么。如果一些东西改变了，就可以知道为什么变。<br><strong>action相当于描述发生什么的指示器。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">type</span>: <span class="string">&#x27;ADD_TODO&#x27;</span>, <span class="attr">text</span>: <span class="string">&#x27;Go to swimming pool&#x27;</span> &#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">&#x27;TOGGLE_TODO&#x27;</span>, <span class="attr">index</span>: <span class="number">1</span> &#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">&#x27;SET_VISIBILITY_FILTER&#x27;</span>, <span class="attr">filter</span>: <span class="string">&#x27;SHOW_ALL&#x27;</span> &#125;</span><br></pre></td></tr></table></figure><p><strong>3. reducer</strong><br>将action和state串联起来，开发一些函数，真正按照action的指示来改变state</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">visibilityFilter</span>(<span class="params">state = <span class="string">&#x27;SHOW_ALL&#x27;</span>, action</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.<span class="property">type</span> === <span class="string">&#x27;SET_VISIBILITY_FILTER&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> action.<span class="property">filter</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">todos</span>(<span class="params">state = [], action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;ADD_TODO&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> state.<span class="title function_">concat</span>([&#123; <span class="attr">text</span>: action.<span class="property">text</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;]);</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;TOGGLE_TODO&#x27;</span>:</span><br><span class="line">    <span class="keyword">return</span> state.<span class="title function_">map</span>(<span class="function">(<span class="params">todo, index</span>) =&gt;</span></span><br><span class="line">      action.<span class="property">index</span> === index ?</span><br><span class="line">        &#123; <span class="attr">text</span>: todo.<span class="property">text</span>, <span class="attr">completed</span>: !todo.<span class="property">completed</span> &#125; :</span><br><span class="line">        todo</span><br><span class="line">   )</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三大原则"><a href="#三大原则" class="headerlink" title="三大原则"></a>三大原则</h3><ul><li>单一数据源<br>所有state存放到一起</li><li>State只读<br>唯一改变state的方法就是触发action，用于描述已发生事件的普通对象。</li><li>使用传函数来执行修改<br>需要编写reducers真正修改state，Reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state。</li></ul><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>action创建函数，返回一个action对象，一些action示例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * action 类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">ADD_TODO</span> = <span class="string">&#x27;ADD_TODO&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">TOGGLE_TODO</span> = <span class="string">&#x27;TOGGLE_TODO&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">SET_VISIBILITY_FILTER</span> = <span class="string">&#x27;SET_VISIBILITY_FILTER&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 其它的常量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">VisibilityFilters</span> = &#123;</span><br><span class="line">  <span class="attr">SHOW_ALL</span>: <span class="string">&#x27;SHOW_ALL&#x27;</span>,</span><br><span class="line">  <span class="attr">SHOW_COMPLETED</span>: <span class="string">&#x27;SHOW_COMPLETED&#x27;</span>,</span><br><span class="line">  <span class="attr">SHOW_ACTIVE</span>: <span class="string">&#x27;SHOW_ACTIVE&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * action 创建函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">addTodo</span>(<span class="params">text</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: <span class="variable constant_">ADD_TODO</span>, text &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">toggleTodo</span>(<span class="params">index</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: <span class="variable constant_">TOGGLE_TODO</span>, index &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">setVisibilityFilter</span>(<span class="params">filter</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: <span class="variable constant_">SET_VISIBILITY_FILTER</span>, filter &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><p>Reducer本质上就是这种形式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(state1, action)=&gt;&#123;</span><br><span class="line">    <span class="comment">// 根据action指示生成新的state2</span></span><br><span class="line">    <span class="keyword">return</span> stste2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个Reducer的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="variable constant_">ADD_TODO</span>,</span><br><span class="line">  <span class="variable constant_">TOGGLE_TODO</span>,</span><br><span class="line">  <span class="variable constant_">SET_VISIBILITY_FILTER</span>,</span><br><span class="line">  <span class="title class_">VisibilityFilters</span></span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;./actions&#x27;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">todoApp</span>(<span class="params">state = initialState, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">SET_VISIBILITY_FILTER</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, state, &#123;</span><br><span class="line">        <span class="attr">visibilityFilter</span>: action.<span class="property">filter</span></span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">ADD_TODO</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, state, &#123;</span><br><span class="line">        <span class="attr">todos</span>: [</span><br><span class="line">          ...state.<span class="property">todos</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">text</span>: action.<span class="property">text</span>,</span><br><span class="line">            <span class="attr">completed</span>: <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">TOGGLE_TODO</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, state, &#123;</span><br><span class="line">        <span class="attr">todos</span>: state.<span class="property">todos</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">todo, index</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (index === action.<span class="property">index</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, todo, &#123;</span><br><span class="line">              <span class="attr">completed</span>: !todo.<span class="property">completed</span></span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> todo</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>拆分Reducer</strong><br>可以将上边的示例代码中对一些逻辑进行单独封装成一个新的reducer</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">todos</span>(<span class="params">state = [], action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">ADD_TODO</span>:</span><br><span class="line">      <span class="keyword">return</span> [</span><br><span class="line">        ...state,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">text</span>: action.<span class="property">text</span>,</span><br><span class="line">          <span class="attr">completed</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">TOGGLE_TODO</span>:</span><br><span class="line">      <span class="keyword">return</span> state.<span class="title function_">map</span>(<span class="function">(<span class="params">todo, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index === action.<span class="property">index</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, todo, &#123;</span><br><span class="line">            <span class="attr">completed</span>: !todo.<span class="property">completed</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> todo</span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">visibilityFilter</span>(<span class="params">state = SHOW_ALL, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">SET_VISIBILITY_FILTER</span>:</span><br><span class="line">      <span class="keyword">return</span> action.<span class="property">filter</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">todoApp</span>(<span class="params">state = &#123;&#125;, action</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">visibilityFilter</span>: <span class="title function_">visibilityFilter</span>(state.<span class="property">visibilityFilter</span>, action),</span><br><span class="line">    <span class="attr">todos</span>: <span class="title function_">todos</span>(state.<span class="property">todos</span>, action)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述示例只有todoApp返回了完整的state，因此是主Reducer，负责联合子Reducer模块<br>Redux提供API——<strong>combineReducers</strong>也可以实现该功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todoApp = <span class="title function_">combineReducers</span>(&#123;</span><br><span class="line">  visibilityFilter,</span><br><span class="line">  todos</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> todoApp</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> reducers <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todoApp = <span class="title function_">combineReducers</span>(reducers)</span><br></pre></td></tr></table></figure><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>Store负责将reducer、action、state联系到一起<br>Store有以下职责：</p><ul><li>维持应用的 state；</li><li>提供 getState() 方法获取 state；</li><li>提供 dispatch(action) 方法更新 state；</li><li>通过 subscribe(listener) 注册监听器;</li><li>通过 subscribe(listener) 返回的函数注销监听器。<br>创建一个store<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> todoApp <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"><span class="keyword">let</span> store = <span class="title function_">createStore</span>(todoApp)</span><br><span class="line"><span class="comment">// createStore第二个参数可选，用于初始化state</span></span><br></pre></td></tr></table></figure>发起Action<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  addTodo,</span><br><span class="line">  toggleTodo,</span><br><span class="line">  setVisibilityFilter,</span><br><span class="line">  <span class="title class_">VisibilityFilters</span></span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;./actions&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印初始状态</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(store.<span class="title function_">getState</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次 state 更新时，打印日志</span></span><br><span class="line"><span class="comment">// 注意 subscribe() 返回一个函数用来注销监听器</span></span><br><span class="line"><span class="keyword">const</span> unsubscribe = store.<span class="title function_">subscribe</span>(<span class="function">() =&gt;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(store.<span class="title function_">getState</span>())</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起一系列 action</span></span><br><span class="line">store.<span class="title function_">dispatch</span>(<span class="title function_">addTodo</span>(<span class="string">&#x27;Learn about actions&#x27;</span>))</span><br><span class="line">store.<span class="title function_">dispatch</span>(<span class="title function_">addTodo</span>(<span class="string">&#x27;Learn about reducers&#x27;</span>))</span><br><span class="line">store.<span class="title function_">dispatch</span>(<span class="title function_">addTodo</span>(<span class="string">&#x27;Learn about store&#x27;</span>))</span><br><span class="line">store.<span class="title function_">dispatch</span>(<span class="title function_">toggleTodo</span>(<span class="number">0</span>))</span><br><span class="line">store.<span class="title function_">dispatch</span>(<span class="title function_">toggleTodo</span>(<span class="number">1</span>))</span><br><span class="line">store.<span class="title function_">dispatch</span>(<span class="title function_">setVisibilityFilter</span>(<span class="title class_">VisibilityFilters</span>.<span class="property">SHOW_COMPLETED</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止监听 state 更新</span></span><br><span class="line"><span class="title function_">unsubscribe</span>();</span><br></pre></td></tr></table></figure></li></ul><h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p><strong>严格的单项数据流</strong>是Redux架构的设计核心<br>应用数据生命周期遵循以下四个步骤：</p><ol><li>调用store.dispatch</li><li>Redux store 调用传入的reducer函数</li><li>根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树</li><li>Redux store 保存了根 reducer 返回的完整 state 树</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-项目脚手架(7)</title>
      <link href="/blog/2022/12/02/React-%E9%A1%B9%E7%9B%AE%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
      <url>/blog/2022/12/02/React-%E9%A1%B9%E7%9B%AE%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="React脚手架"><a href="#React脚手架" class="headerlink" title="React脚手架"></a>React脚手架</h2><h3 id="使用create-react-app创建react项目"><a href="#使用create-react-app创建react项目" class="headerlink" title="使用create-react-app创建react项目"></a>使用create-react-app创建react项目</h3><p>全局安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g create-react-app</span><br></pre></td></tr></table></figure><p>构建项目脚手架</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-react-app hello-react</span><br></pre></td></tr></table></figure><p>运行项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><p>react-cli默认隐藏webpack配置，可以通过以下不可逆指令显示webpack配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn eject</span><br></pre></td></tr></table></figure><h3 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h3><p><strong>public —- 静态资源文件夹</strong></p><p>favicon.icon —— 网站页签图标</p><p><strong>index.html ——– 主页面（1）</strong></p><p>logo192.png ——- logo图</p><p>logo512.png ——- logo图</p><p>manifest.json —– 应用加壳的配置文件</p><p>robots.txt ——– 爬虫协议文件</p><p><strong>src —- 源码文件夹</strong></p><p>App.css ——– App组件的样式</p><p><strong>App.js ——— App组件</strong></p><p>App.test.js —- 用于给App做测试</p><p>index.css —— 全局样式</p><p><strong>index.js ——- 入口文件（1）</strong></p><p>logo.svg ——- logo图</p><p>reportWebVitals.js</p><p>— 页面性能分析文件(需要web-vitals库的支持)</p><p>setupTests.js</p><p>—- 组件单元测试的文件(需要jest-dom库的支持)</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>组件名称必须要首字母大写</li><li>src 必须要有入口文件index.js</li><li>jsx中html里面的class变成className、for变成htmlFor、行内style使用{}传入一个对象并以前的”-“连字符使用驼峰命名法。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-进阶(6)</title>
      <link href="/blog/2022/11/30/React-%E8%BF%9B%E9%98%B6/"/>
      <url>/blog/2022/11/30/React-%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>第一种方式</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">import</span>(<span class="string">&quot;./math&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">math</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(math.<span class="title function_">add</span>(<span class="number">16</span>, <span class="number">26</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第二种方式</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Suspense</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">OtherComponent</span> = <span class="title class_">React</span>.<span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;./OtherComponent&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;/* 懒加载组件使用Suspense组件包裹 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">OtherComponent</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p><strong>Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。</strong><br><strong>Context 提供了一种在组件之间共享值的方式，而不必显式地通过组件树的逐层传递 props。</strong></p><h3 id="使用Context的场景"><a href="#使用Context的场景" class="headerlink" title="使用Context的场景"></a>使用Context的场景</h3><p>Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言。举个例子，在下面的代码中，我们通过一个 “theme” 属性手动调整一个按钮组件的样式：</p><p>在没使用Conext之前遇到的问题</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Toolbar</span> <span class="attr">theme</span>=<span class="string">&quot;dark&quot;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Toolbar</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="comment">// Toolbar 组件接受一个额外的“theme”属性，然后传递给 ThemedButton 组件。</span></span><br><span class="line">  <span class="comment">// 如果应用中每一个单独的按钮都需要知道 theme 的值，这会是件很麻烦的事，</span></span><br><span class="line">  <span class="comment">// 因为必须将这个值层层传递所有组件。</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ThemedButton</span> <span class="attr">theme</span>=<span class="string">&#123;props.theme&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThemedButton</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">theme</span>=<span class="string">&#123;this.props.theme&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Context就可避免这种情况</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。</span></span><br><span class="line"><span class="comment">// 为当前的 theme 创建一个 context（“light”为默认值）。</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="string">&#x27;light&#x27;</span>);</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 使用一个 Provider 来将当前的 theme 传递给以下的组件树。</span></span><br><span class="line">    <span class="comment">// 无论多深，任何组件都能读取这个值。</span></span><br><span class="line">    <span class="comment">// 在这个例子中，我们将 “dark” 作为当前的值传递下去。</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Provider</span> <span class="attr">value</span>=<span class="string">&quot;dark&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Toolbar</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ThemeContext.Provider</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间的组件再也不必指明往下传递 theme 了。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Toolbar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ThemedButton</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThemedButton</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">// 指定 contextType 读取当前的 theme context。</span></span><br><span class="line">  <span class="comment">// React 会往上找到最近的 theme Provider，然后使用它的值。</span></span><br><span class="line">  <span class="comment">// 在这个例子中，当前的 theme 值为 “dark”。</span></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;</span></span><br><span class="line"><span class="language-xml">          (val)=&gt; &#123;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Button</span> <span class="attr">theme</span>=<span class="string">&#123;val&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="language-xml">          &#125;</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>要谨慎使用Context，会导致组件复用性变差.</strong></p><h2 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h2><p>起初的函数式组件的特点：</p><ol><li>无生命周期</li><li>没有this</li><li>没有state状态</li></ol><h3 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h3><p><strong>Hook只能用在函数组件的最顶层</strong></p><p><strong>官方Hook：</strong></p><ol><li>useState<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// 通过setCount修改count值</span></span><br></pre></td></tr></table></figure>渲染参数只会在组件首次渲染时使用，再次更新时会被忽略。如果初始值需要计算，则可以使用回调函数的方式进行返回值计算。</li><li>useEffect<br>副作用，什么是副作用？<br>对于主作用，就是数据更新，视图重新渲染。其他都是副作用，例如生命周期、ajax、手动修改DOM、localStorage操作等。<br>能够模仿以下生命周期钩子</li></ol><ul><li>mounted</li><li>updated</li><li>beforeDestory<br>第一个参数是回调函数，挂载时会触发该函数，第二个参数是数组，会对数组中变量的变化进行监听，从而调用相应回调函数。<strong>如果第二个参数传一个空数组，则该副作用不会感知变量的更新。</strong><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count1, setCount1] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> [count2, setCount2] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;模拟mounted挂载完成&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;count1和count2初始化或更新&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;模拟beforeDestory&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, [count1, count2])</span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;模拟mounted挂载完成&#x27;</span>);</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure><strong>执行时机永远都是组件DOM渲染更新之后</strong><br>两个参数</li><li>默认状态，首次执行，每次组件更新执行（无第二个参数）</li><li>首次执行（添加[]）</li><li>首次执行，特定依赖项变化后执行（添加形如[count, num]）</li></ul><ol start="3"><li><p>useContext</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; createContext, useContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title function_">createContext</span>()</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Son</span>&gt;</span><span class="tag">&lt;/<span class="name">Son</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> val = <span class="title function_">useContext</span>(<span class="title class_">MyContext</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#x27;通过Context传递过来的值：&#x27; + val&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Context</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">MyContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;</span>&#x27;<span class="attr">aaa</span>&#x27;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Father</span>&gt;</span><span class="tag">&lt;/<span class="name">Father</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">MyContext.Provider</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>useRef<br>获取DOM节点<br>使用步骤：</p></li></ol><ul><li>导入useRef函数</li><li>执行useRef函数传入null，返回值为一个对象，内部有current属性存放拿到的DOM对象</li><li>通过ref绑定要获取的组件或元素</li></ul><ol><li>useCallback、memo与useMemo<br>这三者是用来性能优化的</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flex布局详解</title>
      <link href="/blog/2022/11/30/flex%E5%B8%83%E5%B1%80%E8%AF%A6%E8%A7%A3/"/>
      <url>/blog/2022/11/30/flex%E5%B8%83%E5%B1%80%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><ol><li><p>flex-direction定义轴线<br>flex分为主轴和交叉轴两个概念，通过<strong>flex-direction</strong>来定义主轴，默认row为主轴。</p></li><li><p>flex-wrap定义是否换行</p></li><li><p>flex属性<br>首先有一个剩余空间的概念，假设在 1 个 500px 的容器中，我们有 3 个 100px 宽的元素，那么这 3 个元素需要占 300px 的宽，剩下 200px 的可用空间。在默认情况下，flexbox 的行为会把这 200px 的空间留在最后一个元素的后面。</p><p>flex元素的作用就是决定如何分配可用空间。</p><ol><li>flex-grow<br> flex-grow 若被赋值为一个正整数，flex 元素会以 flex-basis 为基础，沿主轴方向增长尺寸。这会使该元素延展，并占据此方向轴上的可用空间（available space）。如果有其他元素也被允许延展，那么他们会各自占据可用空间的一部分。<br> 如果我们给上例中的所有元素设定 flex-grow 值为 1，容器中的可用空间会被这些元素平分。它们会延展以填满 容器主轴方向上的空间。<br> flex-grow属性可以按比例分配空间。如果第一个元素 flex-grow 值为 2，其他元素值为 1，则第一个元素将占有 2&#x2F;4（上例中，即为 200px 中的 100px）, 另外两个元素各占有 1&#x2F;4（各 50px）。</li><li>flex-shrink<br>flex-grow属性是处理 flex 元素在主轴上增加空间的问题，相反flex-shrink属性是处理 flex 元素收缩的问题。如果我们的容器中没有足够排列 flex 元素的空间，那么可以把 flex 元素flex-shrink属性设置为正整数来缩小它所占空间到flex-basis以下。与flex-grow属性一样，可以赋予不同的值来控制 flex 元素收缩的程度 —— 给flex-shrink属性赋予更大的数值可以比赋予小数值的同级元素收缩程度更大。</li><li>flex-basis</li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue原理-MVVM原理</title>
      <link href="/blog/2022/11/28/Vue%E5%8E%9F%E7%90%86-MVVM%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/blog/2022/11/28/Vue%E5%8E%9F%E7%90%86-MVVM%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><a href="https://imgse.com/i/zUHbon"><img src="https://s1.ax1x.com/2022/11/28/zUHbon.png" alt="zUHbon.png"></a></p><p>Vue是采用数据劫持监听变化，配合发布订阅设计模式来通知观察者更新视图。</p><p><strong>Observer</strong>通过Object.defineProperty()来劫持各个属性的setter和getter，在数据变动时，发布消息给以来收集器(<strong>Dep</strong>)，用以来收集器告知观察者(<strong>Watcher</strong>)，调用更新器(<strong>Updater</strong>)来更新视图，<strong>Compile</strong>也会利用Watcher订阅数据变化，绑定更新函数。</p><p>MVVM作为绑定的入口，整合Observer、Compile、Watcher三者，通过Observer劫持各个属性，从而监听各个属性的变化，通过Compile来编译模板指令，最终通过Watcher来搭起Observer与Compile之间的桥梁，从而实现数据变化 -&gt; 视图更新的效果。</p><h2 id="关键类功能介绍"><a href="#关键类功能介绍" class="headerlink" title="关键类功能介绍"></a>关键类功能介绍</h2><h3 id="Compile类"><a href="#Compile类" class="headerlink" title="Compile类"></a>Compile类</h3><p>负责编译el指向的代码片段上的指令、插值表达式。</p><p>拥有CompileUtil工具类，负责对每个以v-开头的指令进行处理，例如：v-on绑定函数、v-html渲染html等。</p><h2 id="Updater"><a href="#Updater" class="headerlink" title="Updater"></a>Updater</h2><p>负责初始化视图、更新视图。例如当Compile解析到v-html或插值表达式时，就需要使用Uprater来更新视图。</p><h2 id="Observer类"><a href="#Observer类" class="headerlink" title="Observer类"></a>Observer类</h2><p>负责劫持vm实例上data上属性，从而感知data上属性的操作。</p><h2 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h2><p>订阅器，负责存储所有观察者，以用来后续数据更新时告知观察者。</p><h2 id="Watcher类"><a href="#Watcher类" class="headerlink" title="Watcher类"></a>Watcher类</h2><p>每个Watcher上可以绑定响应回调函数，一般是视图更新函数，当Observer监听到变化后，会告知Dep，Dep从而通知相应Watcher去更新视图。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-state与生命周期(4)</title>
      <link href="/blog/2022/11/27/React-state%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/blog/2022/11/27/React-state%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>引入react官方网的一个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">date</span>: <span class="keyword">new</span> <span class="title class_">Date</span>() &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">timerID</span> = <span class="built_in">setInterval</span>(</span><br><span class="line">            <span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">tick</span>(),</span><br><span class="line">            <span class="number">1000</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">timerID</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">tick</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            <span class="attr">date</span>: <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">h2</span>&gt;</span>It is &#123;this.state.date.toLocaleTimeStr</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        );</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml">ReactDOM.render(</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Clock</span> /&gt;</span>,</span></span><br><span class="line"><span class="language-xml">    document.getElementById(&#x27;root&#x27;)</span></span><br><span class="line"><span class="language-xml">);</span></span><br></pre></td></tr></table></figure><h2 id="使用State的原则"><a href="#使用State的原则" class="headerlink" title="使用State的原则"></a>使用State的原则</h2><ol><li>不要直接修改state，要想监听变化，必须使用setState来修改。</li><li>state值的更新需要对比变化后再更新，因此是异步更新的，所以不应该依赖他们的值来直接更新下一个状态。因此如果需要当前state值来更新之后的state值，可以采用传入回调函数的形式：<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">state, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">counter</span>: state.<span class="property">counter</span> + props.<span class="property">increment</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></li><li>state的更新会被合并，而不是直接覆盖。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-基础(5)</title>
      <link href="/blog/2022/11/27/React-%E5%9F%BA%E7%A1%80/"/>
      <url>/blog/2022/11/27/React-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><p>react中事件绑定如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;activateLasers&#125;&gt;</span><br><span class="line">  <span class="title class_">Activate</span> <span class="title class_">Lasers</span></span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure><h3 id="事件绑定中的this指向问题"><a href="#事件绑定中的this指向问题" class="headerlink" title="事件绑定中的this指向问题"></a>事件绑定中的this指向问题</h3><p>示例如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Toggle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">isToggleOn</span>: <span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了在回调中使用 `this`，这个绑定是必不可少的</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">isToggleOn</span>: !prevState.<span class="property">isToggleOn</span></span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="comment">// 这里面handleClick的this指向是undefined</span></span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.state.isToggleOn ? &#x27;ON&#x27; : &#x27;OFF&#x27;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你必须谨慎对待 JSX 回调函数中的 this，在 JavaScript 中，class 的方法默认不会绑定 this。如果你忘记绑定 this.handleClick 并把它传入了 onClick，当你调用这个函数的时候 this 的值为 undefined。<br>该问题可以通过三种方式解决：</p><ol><li>使用bind绑定this<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)&#125;&gt;</span><br><span class="line">    &#123;<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">isToggleOn</span> ? <span class="string">&#x27;ON&#x27;</span> : <span class="string">&#x27;OFF&#x27;</span>&#125;</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure></li><li>使用回调函数的方式<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">handleClick</span>()&#125;&gt;</span><br><span class="line">    &#123;<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">isToggleOn</span> ? <span class="string">&#x27;ON&#x27;</span> : <span class="string">&#x27;OFF&#x27;</span>&#125;</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure></li><li>在定义handelClick函数时使用箭头函数<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">isToggleOn</span>: !prevState.<span class="property">isToggleOn</span></span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="传参问题"><a href="#传参问题" class="headerlink" title="传参问题"></a>传参问题</h3><p>正常传参即可</p><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p>在渲染组件时插入条件逻辑：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isLoggedIn) &#123;</span><br><span class="line">    button = <span class="language-xml"><span class="tag">&lt;<span class="name">LogoutButton</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleLogoutClick&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    button = <span class="language-xml"><span class="tag">&lt;<span class="name">LoginButton</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleLoginClick&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过return null的方式组织组件渲染</p><h2 id="列表-amp-Key"><a href="#列表-amp-Key" class="headerlink" title="列表 &amp; Key"></a>列表 &amp; Key</h2><p>可以通过map的方式，将数组中的元素渲染成React中的元素：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> listItems = numbers.<span class="title function_">map</span>(<span class="function">(<span class="params">number</span>) =&gt;</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;number.toString()&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;number&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>数组的每一项必须加上一个唯一的标识Key</strong></p><h3 id="Key的作用"><a href="#Key的作用" class="headerlink" title="Key的作用"></a>Key的作用</h3><p>key帮助react识别哪些元素改变了，比如被添加或删除。不建议使用index作为key值，这样做会导致性能变差，还可能引起组件的状态问题。</p><h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>此表单具有默认的 HTML 表单行为，即在用户提交表单后浏览到新页面。如果你在 React 中执行相同的代码，它依然有效。但大多数情况下，使用 JavaScript 函数可以很方便的处理表单的提交， 同时还可以访问用户填写的表单数据。实现这种效果的标准方式是使用“受控组件”。</p><h3 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h3><p>也就是将表单组件原来已有的内部数据源移交给React state进行管理，这样React能感知表单数据变化。</p><p>一个受控组件的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NameForm</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">value</span>: <span class="string">&#x27;&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleChange</span> = <span class="variable language_">this</span>.<span class="property">handleChange</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleSubmit</span> = <span class="variable language_">this</span>.<span class="property">handleSubmit</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleChange</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">value</span>: event.<span class="property">target</span>.<span class="property">value</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleSubmit</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;提交的名字: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">value</span>);</span><br><span class="line">    <span class="comment">// 阻止默认提交事件 </span></span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          名字:</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h2><p>在 React 应用中，任何可变数据应当只有一个相对应的唯一“数据源”。通常，state 都是首先添加到需要渲染数据的组件中去。然后，如果其他组件也需要这个 state，那么你可以将它提升至这些组件的最近共同父组件中。你应当依靠自上而下的数据流，而不是尝试在不同组件间同步 state。</p><h2 id="组合VS继承"><a href="#组合VS继承" class="headerlink" title="组合VS继承"></a>组合VS继承</h2><p>React更希望使用组合的方式确立组件之间的关系，而非继承。</p><h3 id="特殊的children-props"><a href="#特殊的children-props" class="headerlink" title="特殊的children props"></a>特殊的children props</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 容器组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FancyBorder</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>&#x27;<span class="attr">FancyBorder</span> <span class="attr">FancyBorder-</span>&#x27; + <span class="attr">props.color</span>&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;props.children&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">WelcomeDialog</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">FancyBorder</span> <span class="attr">color</span>=<span class="string">&quot;blue&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;Dialog-title&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Welcome</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">className</span>=<span class="string">&quot;Dialog-message&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Thank you for visiting our spacecraft!</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">FancyBorder</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是放在容器组件之间的React元素都默认放在了容器组件的props.children属性中。</p><h3 id="React里面的”插槽”"><a href="#React里面的”插槽”" class="headerlink" title="React里面的”插槽”"></a>React里面的”插槽”</h3><p>插槽的概念是在Vue中的，但是在React中并没有插槽的概念，但是React props属性的强大完全代替了Vue里面的插槽的概念，由于React使用jsx，因此props可以传递一些类似HTML片段的对象。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SplitPane</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;SplitPane&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;SplitPane-left&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;props.left&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;SplitPane-right&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;props.right&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">SplitPane</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">left</span>=<span class="string">&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &lt;<span class="attr">Contacts</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml">      right=&#123;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Chat</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#125; /&gt;</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="React哲学"><a href="#React哲学" class="headerlink" title="React哲学"></a>React哲学</h2><p>也就是教你封装组件的思想。</p>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-JSX(2)</title>
      <link href="/blog/2022/11/26/React-JSX/"/>
      <url>/blog/2022/11/26/React-JSX/</url>
      
        <content type="html"><![CDATA[<h2 id="一个简单的组件"><a href="#一个简单的组件" class="headerlink" title="一个简单的组件"></a>一个简单的组件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>,</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="什么是JSX"><a href="#什么是JSX" class="headerlink" title="什么是JSX"></a>什么是JSX</h2><p>jsx可以理解为是js语言的一个扩展，React建议使用jsx，jsx拥有js的全部功能。</p><h2 id="在JSX中嵌入表达式"><a href="#在JSX中嵌入表达式" class="headerlink" title="在JSX中嵌入表达式"></a>在JSX中嵌入表达式</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 花括号中甚至可以是函数表达式等</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Josh Perez&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  element,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="JSX添加属性"><a href="#JSX添加属性" class="headerlink" title="JSX添加属性"></a>JSX添加属性</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通字符串</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">tabIndex</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line"><span class="comment">// 使用花括号在属性值中插入一个js表达式</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><h2 id="JSX防注入"><a href="#JSX防注入" class="headerlink" title="JSX防注入"></a>JSX防注入</h2><p>可以安全地在jsx中插入用户输入内容<br>因为ReactDOM在渲染所有输入内容之前会进行转移，所有内容在渲染之前都会转成字符串，防止XSS攻击。</p>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-元素与组件(3)</title>
      <link href="/blog/2022/11/26/React-%E5%85%83%E7%B4%A0%E4%B8%8E%E7%BB%84%E4%BB%B6/"/>
      <url>/blog/2022/11/26/React-%E5%85%83%E7%B4%A0%E4%B8%8E%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h2><p><strong>元素是构成React应用的最小砖块，元素可以是HTML标签，也可以是React组件</strong><br>与浏览器DOM不同，React元素是创建开销极小的普通对象。ReactDOM只负责更新DOM来与React元素保持一致。</p><p><strong>ReactDOM.render()<strong>函数用来将React元素</strong>渲染</strong>到根DOM中，也负责<strong>更新</strong>已渲染的元素。</p><p><strong>React只会更新它需要更新的部分</strong><br>React DOM 会将元素和它的子元素与它们之前的状态进行比较，并只会进行必要的更新来使 DOM 达到预期的状态。</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。</p><h3 id="类式组件"><a href="#类式组件" class="headerlink" title="类式组件"></a>类式组件</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Welcome</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件传参"><a href="#组件传参" class="headerlink" title="组件传参"></a>组件传参</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">&quot;Sara&quot;</span> /&gt;</span></span>;</span><br><span class="line">root.<span class="title function_">render</span>(element);</span><br></pre></td></tr></table></figure><p><strong>Props是只读的，组件不能修改自身props的值。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-引入(1)</title>
      <link href="/blog/2022/11/26/React-%E5%BC%95%E5%85%A5/"/>
      <url>/blog/2022/11/26/React-%E5%BC%95%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="步骤-1：添加一个DOM容器到HTML"><a href="#步骤-1：添加一个DOM容器到HTML" class="headerlink" title="步骤 1：添加一个DOM容器到HTML"></a>步骤 1：添加一个DOM容器到HTML</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;react-container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="步骤-2：添加-Script-标签"><a href="#步骤-2：添加-Script-标签" class="headerlink" title="步骤 2：添加 Script 标签"></a>步骤 2：添加 Script 标签</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- ... 其它 HTML ... --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 加载 React。--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 注意: 部署时，将 &quot;development.js&quot; 替换为 &quot;production.min.js&quot;。--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@16/umd/react.development.js&quot;</span> <span class="attr">crossorigin</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;</span> <span class="attr">crossorigin</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 加载我们的 React 组件。--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;like_button.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="步骤-3：创建一个-React-组件"><a href="#步骤-3：创建一个-React-组件" class="headerlink" title="步骤 3：创建一个 React 组件"></a>步骤 3：创建一个 React 组件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> e = <span class="title class_">React</span>.<span class="property">createElement</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LikeButton</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">liked</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">liked</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;You liked this.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">e</span>(</span><br><span class="line">            <span class="string">&#x27;button&#x27;</span>,</span><br><span class="line">            &#123; <span class="attr">onClick</span>: <span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">liked</span>: <span class="literal">true</span> &#125;) &#125;,</span><br><span class="line">            <span class="string">&#x27;Like&#x27;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> domContainer = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#react-container&#x27;</span>);</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="title function_">e</span>(<span class="title class_">LikeButton</span>), domContainer);</span><br></pre></td></tr></table></figure><h2 id="步骤-4：代替原生，使用jsx"><a href="#步骤-4：代替原生，使用jsx" class="headerlink" title="步骤 4：代替原生，使用jsx"></a>步骤 4：代替原生，使用jsx</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. CDN引入babel --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2. 修改标签如下 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span> <span class="attr">src</span>=<span class="string">&quot;like_button.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 修改render函数返回值如下</span></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">liked</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;You liked this.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.setState(&#123; liked: true &#125;)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">                Like</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>开启服务器模式运行html代码。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典算法-快排</title>
      <link href="/blog/2022/11/25/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-%E5%BF%AB%E6%8E%92/"/>
      <url>/blog/2022/11/25/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95-%E5%BF%AB%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<h2 id="快速排序quickSort"><a href="#快速排序quickSort" class="headerlink" title="快速排序quickSort"></a>快速排序quickSort</h2><p>基本思想是，每一次选取一个基数，将原数组分割成三部分：基数、比基数小的新数组，比基数大的新数组。<br>之后递归执行，递归结束条件是传入的数组长度&lt;&#x3D;1。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> left = [], right = [], base = arr[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; base) &#123;</span><br><span class="line">            left.<span class="title function_">push</span>(arr[i])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right.<span class="title function_">push</span>(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">quickSort</span>(left).<span class="title function_">concat</span>([base], <span class="title function_">quickSort</span>(right))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-发布订阅模式</title>
      <link href="/blog/2022/11/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2022/11/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><p>该设计模式思想：比如DOM的事件监听，Vue-EventBus等<br>发布订阅模式，首先要有一个<strong>事件中心</strong>，用于管控所有事件，<strong>订阅者</strong>事件中心订阅事件A，当事件A<strong>发布</strong>时，事件中心会告知所有订阅者事件A已经发布，可以选择执行订阅者传的回调函数。<br>事件中心对所有事件的管控可以用MAP进行管理。<br>具体代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">events</span> = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">on</span>(<span class="params">eventName, eventFunction</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">get</span>(eventName)) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">set</span>(eventName, [eventFunction])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">get</span>(eventName).<span class="title function_">push</span>(eventFunction)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">emit</span>(<span class="params">eventName, ...args</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> eventList = <span class="variable language_">this</span>.<span class="property">events</span>.<span class="title function_">get</span>(eventName)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> event <span class="keyword">of</span> eventList) &#123;</span><br><span class="line">            event.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...args)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Subject</span>()</span><br><span class="line">s.<span class="title function_">on</span>(<span class="string">&#x27;a&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;event a is begin&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">s.<span class="title function_">on</span>(<span class="string">&#x27;a&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;event a is start&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">s.<span class="title function_">on</span>(<span class="string">&#x27;b&#x27;</span>, <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b);</span><br><span class="line">&#125;)</span><br><span class="line">s.<span class="title function_">on</span>(<span class="string">&#x27;b&#x27;</span>, <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a * b);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">s.<span class="title function_">emit</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">s.<span class="title function_">emit</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-观察者模式</title>
      <link href="/blog/2022/11/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2022/11/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h2><p>该设计模式的思想比如：Vue监听data中的数据改变后更新视图，Vue里面的Watcher等<br>观察者模式，首先要有一个<strong>被观察者</strong>，被观察者里面存放被观察数据，一旦数据改变（因此需要一个改变数据的方法），则告知所有<strong>观察者</strong>。观察者可以通过注册的方式注册到被观察者身上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = <span class="number">100</span> <span class="comment">// 被观察数据</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">observers</span> = [] <span class="comment">// 观察者</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">addObservers</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">push</span>(...args)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">setState</span>(<span class="params">s</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> oldValue = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = s</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">o</span> =&gt;</span> &#123;</span><br><span class="line">            o.<span class="title function_">update</span>(<span class="variable language_">this</span>.<span class="property">state</span>, oldValue)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">update</span>(<span class="params">newValue, oldValue</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;oldValue&#125;</span>-&gt;<span class="subst">$&#123;newValue&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Subject</span>()</span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="string">&#x27;医生&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> n = <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="string">&#x27;护士&#x27;</span>)</span><br><span class="line">s.<span class="title function_">addObservers</span>(d, n)</span><br><span class="line">s.<span class="title function_">setState</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经总结</title>
      <link href="/blog/2022/11/24/%E9%9D%A2%E8%AF%95%E5%A4%87%E6%88%98-%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/"/>
      <url>/blog/2022/11/24/%E9%9D%A2%E8%AF%95%E5%A4%87%E6%88%98-%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="字节商业变现"><a href="#字节商业变现" class="headerlink" title="字节商业变现"></a>字节商业变现</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line"> <span class="title function_">resolve</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">i</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(i);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">a</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">i</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 上面打印 0</span></span><br><span class="line"><span class="comment">// 下面打印 10（因为使用 var 定义是函数作用域，不会为每一个 i 保存一块内存）</span></span><br><span class="line"><span class="comment">// 这里一开始说错了，完全反过来，面试官还引导我说定义了一个函数而不是立即执行，太幸运了</span></span><br><span class="line"><span class="number">0.1</span>+<span class="number">0.2</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(a, b, precision)</span><br></pre></td></tr></table></figure><p>DOM事件机制<br>target&#x2F;currentTarget</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比如现在有如下结构：</span><br><span class="line">.parent&gt;.children</span><br><span class="line">现在点击children，则parent和children都会监听到点击事件</span><br><span class="line">对于target，两次都是children</span><br><span class="line">但是对与currentTarget，第一次是childern，第二次是parent</span><br></pre></td></tr></table></figure><p>tcp三次握手、四次挥手</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">三次挥手：</span><br><span class="line">首先sc双方均处于closed状态</span><br><span class="line">1. c向s发送SYN包，和初始序号seq，请求同步连接，c改变为SYN-SENT状态。</span><br><span class="line">2. s收到SYN包后，改变状态为SYN-RECV状态，并将SYN包，ACK标志位置为1表示接收同步请求，seq，ack应答发送给c</span><br><span class="line">3. c收到s发来的ACK标志位，发现同意，则发送ACK标志位为1，seq，ack发送给s</span><br><span class="line">4. 双方进入ESTABLISHED状态</span><br><span class="line"></span><br><span class="line">四次挥手：</span><br><span class="line">首先sc双方均处于ESTABLISHED状态</span><br><span class="line">1. c向s发送FIN包，和seq</span><br><span class="line">2. 但由于s可能还有数据未发送完，所以并不会立即发送FIN包来响应c，而是发送ACK，表示我收到了你的FIN，但现在还不能终止。</span><br><span class="line">3. s数据发送完毕后，会发送FIN包给c</span><br><span class="line">4. c收到FIN包后，会告知s，ACK，表示c收到了s的FIN包</span><br><span class="line">5. 此后c会等待2MSL，这个状态是为了确保s收到了c的确认信息</span><br><span class="line">为什么是2MSL？</span><br><span class="line">MSL指的是报文最大生成时间，目的是保证本次连接所用的数据包完全在网络中小时，以免影响之后的连接。</span><br></pre></td></tr></table></figure><p>new Function()过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先，会创建一个对象实例，该实例的__proto__属性指向Function的property属性，创建之后，将Function的this指向绑定为该对象，进行执行，若Function返回结果是引用类型，则会返回该引用类型给，否则会返回该实例。</span><br></pre></td></tr></table></figure><p>编程实现<br>还原扁平的树结构，结构如下，id表示当前节点id，parentId表示其父节点id。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> listTree = [</span><br><span class="line">&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">parentId</span>: <span class="number">2</span> &#125;,</span><br><span class="line">&#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">parentId</span>: <span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">parentId</span>: <span class="number">4</span> &#125;,</span><br><span class="line">&#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">parentId</span>: <span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="attr">id</span>: <span class="number">5</span>, <span class="attr">parentId</span>: <span class="number">4</span> &#125;,</span><br><span class="line">&#123; <span class="attr">id</span>: <span class="number">6</span>, <span class="attr">parentId</span>: <span class="number">2</span> &#125;,</span><br><span class="line">&#123; <span class="attr">id</span>: <span class="number">7</span>, <span class="attr">parentId</span>: <span class="number">2</span> &#125;,</span><br><span class="line">&#123; <span class="attr">id</span>: <span class="number">8</span>, <span class="attr">parentId</span>: <span class="number">3</span> &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> listTree = [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">parentId</span>: <span class="number">2</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">parentId</span>: <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">parentId</span>: <span class="number">4</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">parentId</span>: <span class="number">0</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">5</span>, <span class="attr">parentId</span>: <span class="number">4</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">6</span>, <span class="attr">parentId</span>: <span class="number">2</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">7</span>, <span class="attr">parentId</span>: <span class="number">2</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="number">8</span>, <span class="attr">parentId</span>: <span class="number">3</span> &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">buildTree</span>(<span class="params">listTree</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> tree = &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">children</span>: []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">findChid</span>(<span class="params">parentNode</span>) &#123;</span><br><span class="line">        parentNode.<span class="property">children</span> = listTree.<span class="title function_">filter</span>(<span class="function"><span class="params">node</span> =&gt;</span> node.<span class="property">parentId</span> === parentNode.<span class="property">id</span>)</span><br><span class="line">        <span class="keyword">if</span> (!parentNode.<span class="property">children</span>) <span class="keyword">return</span></span><br><span class="line">        parentNode.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">findChid</span>(node)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">findChid</span>(tree)</span><br><span class="line">    <span class="keyword">return</span> tree</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">buildTree</span>(listTree));</span><br></pre></td></tr></table></figure><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>为什么 JS 的基本数据类型能够拥有方法，为什么对基本数据类型添加属性或者方法不生效</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;test&#x27;</span></span><br><span class="line"><span class="keyword">let</span> str2 = str.<span class="title function_">substring</span>(<span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str2) <span class="comment">// st</span></span><br><span class="line"><span class="keyword">const</span> me=<span class="string">&#x27;bytedance&#x27;</span>;</span><br><span class="line">me.<span class="property">age</span>=<span class="number">9</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(me.<span class="property">age</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于基本类型，js会对该基本类型进行包装，其实其方法均在String.prototype上，对基本数据类型添加属性不生效是因为，在调用结束后会销毁改包装类型，要想添加方法，可以在String.prototype上添加，这样在调用普通字符串方法时，js会创建一个临时的实例，该实例在找自定义的这个方法时，就会去原型对象上去找，然后在摧毁这个临时实例。</span><br></pre></td></tr></table></figure><p>看输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Q1</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">print</span> () &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">print</span>() <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// Q2</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line"><span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line"><span class="attr">print</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">print</span>(); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// Q3</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> () &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">8</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">print</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)&#125;</span><br><span class="line"><span class="keyword">return</span> &#123;<span class="attr">a</span>: <span class="number">9</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">a</span>) <span class="comment">// 9</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="title function_">print</span>()) <span class="comment">// 报错，返回的对象中没有 print 方法</span></span><br><span class="line"><span class="comment">// Q4</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">print</span> () &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">print</span>() <span class="comment">// 报错 不能给 undefined 添加属性</span></span><br></pre></td></tr></table></figure><p>期间聊了关于 symbol、BigInt、&#x3D;&#x3D;、&#x3D;&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">symble可以生成一个独一无二的值，Symbol()和Symbol.for()虽然都是创建独一无二的值，但for会事先在全局表中查括号里面的值对应的独一无二，若找到，则不再创建。</span><br><span class="line">BigInt可以计算任意长度的整数，且仅支持整数。</span><br></pre></td></tr></table></figure><p>写题，一道插花的贪心题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insideFlowers</span>(<span class="params">num, tem</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = num - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = tem.<span class="property">length</span> - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tem[i] === <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            res += (i - count)</span><br><span class="line">            count--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">insideFlowers</span>(<span class="number">3</span>, <span class="string">&#x27;101010&#x27;</span>));</span><br></pre></td></tr></table></figure><p>写 bind 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">ctx, ...args1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> fn = <span class="title class_">Symbol</span>()</span><br><span class="line">        ctx[fn] = <span class="variable language_">this</span></span><br><span class="line">        <span class="keyword">let</span> res = ctx[fn](...args1, ...args2)</span><br><span class="line">        <span class="keyword">delete</span> ctx[fn]</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(ctx);</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="comment">// console.log(this);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span> + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">9</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">myBind</span>(b, <span class="number">1</span>, <span class="number">3</span>)());</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br></pre></td></tr></table></figure><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str  =  <span class="string">&#x27;my name is &#123;&#123;name&#125;&#125;, age is &#123;&#123;age&#125;&#125;&#x27;</span></span><br><span class="line"><span class="keyword">let</span> data = &#123;<span class="attr">name</span>: <span class="string">&#x27;tom&#x27;</span>, <span class="attr">age</span>: <span class="number">16</span> &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">template</span>(<span class="params">str, data</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="keyword">let</span> reg = <span class="regexp">/[\&#123;]&#123;2&#125;([\w]+)[\&#125;]&#123;2&#125;/g</span>;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">replace</span>(reg, <span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">        <span class="keyword">const</span> _item = item.<span class="title function_">slice</span>(<span class="number">2</span>, item.<span class="property">length</span> - <span class="number">2</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(_item);</span><br><span class="line">        <span class="keyword">if</span> (data[_item]) &#123;</span><br><span class="line">            <span class="keyword">return</span> data[_item]; <span class="comment">// </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;undefined&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、箭头函数有哪些不适用的场景？</p><p>构造函数<br>this 绑定<br>与 this 相关都需要注意<br>5、HTTP 常用响应码介绍<br>1<strong>：表示服务器收到，需要进一步操作<br>2</strong>：表示响应成功<br>200： ok<br>3<strong>：表示重定向（304表示资源未改变）<br>301： 永久重定向<br>302：临时重定向<br>304：资源未更改（在缓存中使用）<br>4</strong>：表示客户端发生错误<br>400：客户端错误<br>401：身份认证错误<br>403：资源不允许访问<br>404：资源未找到<br>5**：表示服务器发生错误<br>500：服务器内部错误<br>6、TCP 和 UDP 区别<br>TCP 可靠，面向链接， 1对1， 字节流  HTTP<br>UDP 不可靠，尽全量交付 1对1  1对多，面向bao’w  DNS</p><p>7、HTTPS过程 ？<br>http + ssl<br>对称加密<br>非对称加密<br>CA机构</p><p>8、实现一个自己 axois()</p><p>用 Promise 封装 xhr 写了一下<br>9、fetch 和 xhr 区别？</p><p>fetch返回 promise<br>xhr 有 abort<br>fetch 需要调用 json text方法才能获取数据，链式；<br>10、常用的设计模式介绍？  实现一个发布订阅；</p><p>单例<br>发布订阅&#x2F;观察者<br>代理</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/blog/2022/11/23/%E9%9D%A2%E8%AF%95%E5%A4%87%E6%88%98-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2022/11/23/%E9%9D%A2%E8%AF%95%E5%A4%87%E6%88%98-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文参考掘金博主<strong>九思</strong> <a href="https://juejin.cn/post/6844904032826294286">文章地址</a></p><p>设计模式代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。<br>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。</p><h2 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a>设计模式原则</h2><p>S - 单一职责原则</p><ul><li>一个程序只做好一件事</li><li>功能复杂就拆分，保证每个部分独立<br>O - 开闭原则</li><li>对外扩展开放，对修改封闭</li><li>增加需求时，扩展代码，而非修改已有代码<br>L - 李氏替换原则</li><li>子类能覆盖父类</li><li>父类能出现的地方子类就能出现<br>I - 接口隔离</li><li>保持接口的单一独立<br>D - 依赖倒置</li><li>面向接口编程，依赖于抽象而不依赖于具体</li><li>使用方法只关注接口，而不关注具体实现</li></ul><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><p><strong>创建型</strong></p><ul><li>单例模式</li><li>原型模式</li><li>工厂模式</li><li>抽象工厂模式</li><li>建造者模式</li></ul><p><strong>结构型</strong></p><ul><li>适配器模式</li><li>装饰器模式</li><li>代理模式</li><li>外观模式</li><li>桥接模式</li><li>组合模式</li><li>享元模式</li></ul><p><strong>行为型</strong></p><ul><li>观察者模式</li><li>迭代器模式</li><li>策略模式</li><li>模板方法模式</li><li>职责链模式</li><li>命令模式</li><li>备忘录模式</li><li>状态模式</li><li>访问者模式</li><li>中介者模式</li><li>解释器模式</li></ul><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">init</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;init&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fun</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fun&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="title function_">create</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Product</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use</span></span><br><span class="line"><span class="keyword">let</span> factory = <span class="keyword">new</span> <span class="title class_">Factory</span>()</span><br><span class="line"><span class="keyword">let</span> p = factory.<span class="title function_">create</span>(<span class="string">&#x27;p1&#x27;</span>)</span><br><span class="line">p.<span class="title function_">init</span>()</span><br><span class="line">p.<span class="title function_">fun</span>()</span><br></pre></td></tr></table></figure><p>适用场景</p><p>如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择<br>将new操作简单封装，遇到new的时候就应该考虑是否用工厂模式；<br>需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦合，提供更大的灵活性</p><p>优点</p><p>创建对象的过程可能很复杂，但我们只需要关心创建结果。<br>构造函数和创建者分离, 符合“开闭原则”<br>一个调用者想创建一个对象，只要知道其名称就可以了。<br>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</p><p>缺点</p><p>添加新产品时，需要编写新的具体产品类,一定程度上增加了系统的复杂度<br>考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度</p><p>什么时候不用<br>当被应用到错误的问题类型上时,这一模式会给应用程序引入大量不必要的复杂性.除非为创建对象提供一个接口是我们编写的库或者框架的一个设计上目标,否则我会建议使用明确的构造器,以避免不必要的开销。<br>由于对象的创建过程被高效的抽象在一个接口后面的事实,这也会给依赖于这个过程可能会有多复杂的单元测试带来问题。<br>例子</p><p>曾经我们熟悉的JQuery的$()就是一个工厂函数，它根据传入参数的不同创建元素或者去寻找上下文中的元素，创建成相应的jQuery对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">jQuery</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">selector</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(selector)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 此处省略若干API</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">$</span> = <span class="keyword">function</span>(<span class="params">selector</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">jQuery</span>(selector)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vue 的异步组件</p><p>在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;async-example&#x27;</span>, <span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 向 `resolve` 回调传递组件定义</span></span><br><span class="line">    <span class="title function_">resolve</span>(&#123;</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;I am async!&lt;/div&gt;&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>一个类只有一个实例，并且提供一个访问他的全局访问点。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LoginForm</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;hide&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;show&#x27;</span>) &#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&#x27;已经显示&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;show&#x27;</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;登录框显示成功&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">hide</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;hide&#x27;</span>) &#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&#x27;已经隐藏&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;hide&#x27;</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;登录框隐藏成功&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title class_">LoginForm</span>.<span class="property">getInstance</span> = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">     <span class="keyword">let</span> instance</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LoginForm</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="title class_">LoginForm</span>.<span class="title function_">getInstance</span>()</span><br><span class="line">obj1.<span class="title function_">show</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="title class_">LoginForm</span>.<span class="title function_">getInstance</span>()</span><br><span class="line">obj2.<span class="title function_">hide</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1 === obj2)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优点</p><ul><li>划分命名空间，减少全局变量</li><li>增强模块性，把自己的代码组织在一个全局变量名下，放在单一位置，便于维护</li><li>且只会实例化一次。简化了代码的调试和维护</li></ul><p>缺点</p><p>由于单例模式提供的是一种单点访问，所以它有可能导致模块间的强耦合 从而不利于单元测试。无法单独测试一个调用了来自单例的方法的类，而只能把它与那个单例作为一个单元一起测试。</p><p>场景例子</p><ul><li>定义命名空间和实现分支型方法</li><li>登录框</li><li>vuex 和 redux中的store</li></ul><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>将一个类的接口转化为另外一个接口，以满足用户需求，使类接口之间不兼容问题通过适配器得以解决。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Plug</span> &#123;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;iphone充电头&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">plug</span> = <span class="keyword">new</span> <span class="title class_">Plug</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">plug</span>.<span class="title function_">getName</span>() + <span class="string">&#x27; 适配器Type-c充电头&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> target = <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line">target.<span class="title function_">getName</span>(); <span class="comment">// iphone充电头 适配器转Type-c充电头</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优点</p><ul><li>可以让任何两个没有关联的类一起运行。</li><li>提高了类的复用。</li><li>适配对象，适配库，适配数据</li></ul><p>缺点</p><ul><li>额外对象的创建，非直接调用，存在一定的开销（且不像代理模式在某些功能点上可实现性能优化)</li><li>如果没必要使用适配器模式的话，可以考虑重构，如果使用的话，尽量把文档完善</li></ul><p>场景</p><ul><li>整合第三方SDK</li><li>封装旧接口</li><li>Vue的computed</li></ul><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><ul><li>动态地给某个对象添加一些额外的职责，是一种实现继承的替代方案。</li><li>在不改变原对象的基础上，对其进行包装扩展，使原有对象可以满足用户更复杂的需求，而不会影响从这个类派生的其他对象。</li></ul><p>场景例子</p><ul><li>比如现在有4 种型号的自行车，我们为每种自行车都定义了一个单独的类。现在要给每种自行车都装上前灯、尾灯和铃铛这3 种配件。如果使用继承的方式来给每种自行车创建子类，则需要 4×3 &#x3D; 12 个子类。但是如果把前灯、尾灯、铃铛这些对象动态组合到自行车上面，则只需要额外增加3 个类</li><li>ES7 Decorator 阮一峰</li><li>core-decorators</li></ul><p>优点</p><ul><li>装饰类和被装饰类都只关心自身的核心业务，实现了解耦。</li><li>方便动态的扩展功能，且提供了比继承更多的灵活性。</li></ul><p>缺点</p><ul><li>多层装饰比较复杂。</li><li>常常会引入许多小对象，看起来比较相似，实际功能大相径庭，从而使得我们的应用程序架构变得复杂起来</li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>是为一个对象提供一个代用品或占位符，以便控制对它的访问】</p><p>优点</p><ul><li>代理模式能将代理对象与被调用对象分离，降低了系统的耦合度。代理模式在客户端和目标对象之间起到一个中介作用，这样可以起到保护目标对象的作用</li><li>代理对象可以扩展目标对象的功能；通过修改代理对象就可以了，符合开闭原则；</li></ul><p>缺点</p><ul><li>处理请求速度可能有差别，非直接访问存在开销</li></ul><p>不同点</p><ul><li>装饰者模式实现上和代理模式类似</li><li>装饰者模式：  扩展功能，原有功能不变且可直接使用</li><li>代理模式： 显示原有功能，但是经过限制之后的</li></ul><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使它们能够自动更新自己，当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式。</p><ul><li>发布订阅</li><li>一对多</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主题 保存状态，状态变化之后触发所有观察者对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="number">0</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span> = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getState</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">setState</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = state</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">notifyAllObservers</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">notifyAllObservers</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">      observer.<span class="title function_">update</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">attach</span>(<span class="params">observer</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">push</span>(observer)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, subject</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subject</span> = subject</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subject</span>.<span class="title function_">attach</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> update, state: <span class="subst">$&#123;<span class="variable language_">this</span>.subject.getState()&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Subject</span>()</span><br><span class="line"><span class="keyword">let</span> o1 = <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="string">&#x27;o1&#x27;</span>, s)</span><br><span class="line"><span class="keyword">let</span> o2 = <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="string">&#x27;02&#x27;</span>, s)</span><br><span class="line"></span><br><span class="line">s.<span class="title function_">setState</span>(<span class="number">12</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>场景</p><ul><li>websocket中有玩家进入房间，也就是房间状态改变了，需要告知此房间中的每一位玩家。</li></ul><p>优点</p><ul><li>支持简单的广播通信，自动通知所有已经订阅过的对象</li><li>目标对象与观察者之间的抽象耦合关系能单独扩展以及重用</li><li>增加了灵活性</li><li>观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。</li></ul><p>缺点</p><p>过度使用会导致对象与对象之间联系弱化，会导致程序难以跟踪维护和理解。</p><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>允许一个对象在其内部状态改变的时候改变它的行为，对象看起来似乎修改了它的类</p><p>持续更新中…</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue</title>
      <link href="/blog/2022/11/16/%E9%9D%A2%E8%AF%95%E5%A4%87%E6%88%98-Vue/"/>
      <url>/blog/2022/11/16/%E9%9D%A2%E8%AF%95%E5%A4%87%E6%88%98-Vue/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue2、3响应式原理"><a href="#Vue2、3响应式原理" class="headerlink" title="Vue2、3响应式原理"></a>Vue2、3响应式原理</h2><p>Vue2使用Object.defineProperty,而Vue3使用Es6 Proxy </p><ul><li>前者无法对数组监听起到很好的效果，且无法监听对象添加了属性，通过下标方式修改数组数据</li><li>前者只能劫持对象的属性</li><li>后者不但可以劫持对象，数组，且支持劫持新增的属性</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="comment">// 数据描述符</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;key&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span>, <span class="comment">// 设置初始值</span></span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>, <span class="comment">// 设置是否可写</span></span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="comment">// 设置是否可循环</span></span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="comment">// 属性是否可删除</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.<span class="property">key</span> = <span class="number">2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">key</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj2, <span class="string">&#x27;key&#x27;</span>, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行了get操作&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行了set操作&#x27;</span>);</span><br><span class="line">        val++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">key</span>);</span><br><span class="line">obj2.<span class="property">key</span> = <span class="number">3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">key</span>);</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;aran&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">school</span>: &#123;</span><br><span class="line">        <span class="attr">aign</span>: <span class="string">&#x27;no1&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装一个监听数据变化的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineProperty</span>(<span class="params">obj, key, val</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果监听的值是对象，则也需要进行观察</span></span><br><span class="line"></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="title function_">observer</span>(val)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="title function_">observer</span>(val)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set&#x27;</span>);</span><br><span class="line">            val = newVal</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">observer</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给对象每个属性都设置响应式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="title function_">defineProperty</span>(obj, i, obj[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">observer</span>(obj)</span><br><span class="line">obj.<span class="property">name</span> = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">school</span>);</span><br></pre></td></tr></table></figure><h2 id="Hash模式和History模式"><a href="#Hash模式和History模式" class="headerlink" title="Hash模式和History模式"></a>Hash模式和History模式</h2><p>更新视图但不重新请求界面，Vue通过监听地址栏的变化，将匹配的组件加载到对应的router-view中。</p><ul><li>在url表现上hash有#</li><li>原理上，Hash是浏览器监听<strong>onhashchange</strong>事件的</li><li>history是通过修改浏览器历史记录进行修改，但不会立即对后端进行请求，<strong>pushState()</strong>, <strong>replaceState()</strong> 通过<strong>popState</strong>事件监听</li><li>history模式会占用服务器资源，而hash不利于seo优化</li></ul><h2 id="什么是MVVM、MVC、MVP"><a href="#什么是MVVM、MVC、MVP" class="headerlink" title="什么是MVVM、MVC、MVP"></a>什么是MVVM、MVC、MVP</h2><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>M代表数据</p><p>V代表组件</p><p>VM代表同步View和Model的对象</p><p>MVC与MVVM区别其实并不大，都是一种设计思想，主要是vm与c的不同，vue基于数据驱动，数据改变，自动更新视图，而不是告知view去操作DOM更新视图</p><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><ul><li>M数据</li><li>V视图</li><li>C控制器（用于监听用户与应用的响应操作，一旦用户与页面进行交互，controller触发器会告知model去修改数据，model再通知view更新视图）</li></ul><h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>实现了v与M的解耦，原来的C无法去更新View，但是MVP模式下，P(Presenter)代替了C，可以将视图和数据进行同步更新</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>每个Vue组件实例在创建时都会经历一系列的初始化步骤，比如<strong>设置数据侦听</strong>，<strong>编译模板</strong>，挂<strong>载实例到DOM</strong>，<strong>数据更新时修改DOM</strong>。在这些过程中会运行特定的声明周期钩子来做一些事情。</p><p>顺序如下：</p><ul><li>setup 第一个调用，此时还没有初始化</li><li>beforeCreate Vue实例创建完毕之前执行</li><li>created Vue实例创建完毕之后执行</li><li>beforeMount 模板渲染在页面之前执行</li><li>mounted 模板渲染在页面之后执行</li><li>beforeUnmount组件销毁前执行</li><li>unmounted组件销毁后执行</li><li>beforeUpdate 数据更新前执行</li><li>updated数据更新后执行</li></ul><h2 id="常见的事件修饰符"><a href="#常见的事件修饰符" class="headerlink" title="常见的事件修饰符"></a>常见的事件修饰符</h2><ul><li>stop 阻止事件冒泡</li><li>prevent 阻止默认事件</li><li>capture 开启事件捕获模式</li><li>self 只触发自身范围内的事件</li><li>once 只会触发一次</li></ul><h2 id="如何保存页面当前的状态"><a href="#如何保存页面当前的状态" class="headerlink" title="如何保存页面当前的状态"></a>如何保存页面当前的状态</h2><p>分为两种情况：</p><ul><li>前组件会被卸载<ul><li>用h5web存储来记录组件卸载前的状态</li><li>路由传值</li></ul></li><li>前组件不会被卸载<ul><li>要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。</li></ul></li></ul><p>keep-alive保存状态</p><h2 id="Data为什么是函数"><a href="#Data为什么是函数" class="headerlink" title="Data为什么是函数"></a>Data为什么是函数</h2><p>为了组件复用，每次获取一个新的data，避免data数据域污染</p><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a>$nextTick</h2><p>由于vue是异步渲染的，因此改变DOM之后，立即获取DOM信息是不准确的，因此需要调用nextTick函数，在DOM异步渲染完毕之后，再调用nextTick中的回调函数来获取DOM信息。</p><p>使用场景：</p><ul><li>在数据变化后执行某个操作</li><li>created钩子中，由于DOM还没渲染，所以此时如果想要操纵DOM，必须将操作代码放在nextTick回调函数中。</li><li>比如我现在点击按钮，修改组件的文字，然后立即获取该组件，并打印，发现打印出的组件文字并没有修改。想要获取修改之后的组件需要使用nextTick函数，并传递一个回调函数，修改组件之后会调用该回调函数。</li></ul><h2 id="单页面（spa）多页面（mpa）"><a href="#单页面（spa）多页面（mpa）" class="headerlink" title="单页面（spa）多页面（mpa）"></a>单页面（spa）多页面（mpa）</h2><ul><li>单页面，只有一个主页面应用，一开始只需要加载一次相关资源。每次切换仅刷新局部资源。</li><li>多页面，有多个独立页面，每个页面必须重复加载资源，页面跳转需要多次加载资源，整页资源刷新。</li></ul><p><a href="https://imgse.com/i/z3uAOI"><img src="https://s1.ax1x.com/2022/11/22/z3uAOI.png" alt="z3uAOI.png"></a></p><h2 id="Vue-Template到render的过程"><a href="#Vue-Template到render的过程" class="headerlink" title="Vue Template到render的过程"></a>Vue Template到render的过程</h2><p>解析、优化、生成</p><ol><li>调用parase方法将template解析为AST抽象语法树</li><li>对静态节点做优化，进行标记，避免每次重复渲染静态节点</li><li>将AST转化为render函数字符串</li></ol><h2 id="Vue-data值发生改变会直接同步执行渲染函数吗？"><a href="#Vue-data值发生改变会直接同步执行渲染函数吗？" class="headerlink" title="Vue data值发生改变会直接同步执行渲染函数吗？"></a>Vue data值发生改变会直接同步执行渲染函数吗？</h2><p>不会立即同步执行重新渲染。 Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。 Vue 在更新 DOM 时是异步执行的。 只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</p><p>如果同一个watcher被多次触发，只会被推入到队列中一次。 这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。 然后，在下一个的事件循环tick中，Vue 刷新队列并执行实际（已去重的）工作。</p><h2 id="mixin、extends"><a href="#mixin、extends" class="headerlink" title="mixin、extends"></a><strong>mixin、extends</strong></h2><p>mixin混入，Vue3明确表示可以使用组合式api代替mixin的使用，目的是复用组件逻辑</p><p>extends，组件继承，与mixin类似，复用组件逻辑</p><h2 id="delete和Vue-delete删除数组的区别"><a href="#delete和Vue-delete删除数组的区别" class="headerlink" title="delete和Vue.delete删除数组的区别"></a><strong>delete和Vue.delete删除数组的区别</strong></h2><p>前者只是将数组当前下标数据置为空，后者是直接移除数组元素，后边往前移</p><h2 id="如何理解SSR服务端渲染"><a href="#如何理解SSR服务端渲染" class="headerlink" title="如何理解SSR服务端渲染"></a>如何理解SSR服务端渲染</h2><p>也就是服务端渲染，将Vue在客户端标签渲染程HTML的工作放到服务端完成后，返回给客户端。</p><p>优点：</p><ul><li>SEO优化</li><li>首屏加载速度更快</li></ul><p>缺点：</p><ul><li>服务端负载</li><li>对Node.js环境要求更高</li><li>服务端只支持beforeCreated和created两个钩子</li></ul><h2 id="Vue性能优化"><a href="#Vue性能优化" class="headerlink" title="Vue性能优化"></a>Vue性能优化</h2><p>编码阶段</p><ul><li>尽量减少data中的数据段</li><li>v-if和v-for不能连用，但是v3之后提升了v-if的优先级，使得可以连用</li><li>使用事件委托的方式为v-for每一项绑定事件</li><li>SPA应用采用keep-alive缓存组件</li><li>更多情况使用v-if代替v-show</li><li>懒加载，异步组件</li><li>防抖节流</li><li>第三方模块按需引入</li><li>图片懒加载</li><li>长列表滚动到可视区域动态加载（可以使用自定义组件的方式）</li></ul><p>SEO优化</p><ul><li>预渲染</li><li>服务端渲染</li></ul><p>用户体验</p><ul><li>骨架屏</li></ul><h2 id="解决Vue加载花屏问题"><a href="#解决Vue加载花屏问题" class="headerlink" title="解决Vue加载花屏问题"></a>解决Vue加载花屏问题</h2><ol><li>添加v-cloak，当解析完成后，vue会自动删除v-cloak属性，因此可以配合css属性选择器</li><li>在根元素添加<strong>style&#x3D;”display: none;” :style&#x3D;”{display: ‘block’}”</strong></li></ol><h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><ul><li>Vuex</li><li>props&#x2F;emit</li><li>ingect&#x2F;provide</li><li>$attrs&#x2F;$listeners</li><li>$children&#x2F;$parent</li><li>eventbus事件总线</li><li>$refs获取组件实例</li></ul><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><ul><li>箭头函数+import引入</li><li>箭头函数+require动态加载</li><li>webpack</li></ul><h2 id="Hash与History"><a href="#Hash与History" class="headerlink" title="Hash与History"></a>Hash与History</h2><p>Hash实现原理是通过监听onHashChange事件来切换页面，可以称之为严格意义上的前端路由，因为完全不和后端进行交互，浏览器支持度高。</p><p>history实现原理是通过H5 history api 新增的pushState() 与 replaceState()方法，对浏览器历史记录进行修改，修改url并不会立即刷新页面，但是手动刷新会报404，必须后端同志配合。</p><h2 id="route与router"><a href="#route与router" class="headerlink" title="route与router"></a>route与router</h2><p>route是路由信息对象，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数</p><p>router是路由实例对象，包括了路由的跳转方法，钩子函数等。</p><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><ol><li><p><strong>params方式</strong></p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在APP.vue中</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#x27;/user/&#x27;+ userId&quot;</span> replace&gt;用户&lt;/router-link&gt;    </span><br><span class="line"></span><br><span class="line"><span class="comment">//在index.js</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">path</span>: <span class="string">&#x27;/user/:userid&#x27;</span>,</span><br><span class="line">   <span class="attr">component</span>: <span class="title class_">User</span>,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1：</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123; name: &#x27;users&#x27;, params: &#123; uname: wade &#125;&#125;&quot;</span>&gt;</span>按钮&lt;/router-link</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">// 方法2：</span></span><br><span class="line"><span class="language-xml">this.$router.push(&#123;name:&#x27;users&#x27;,params:&#123;uname:wade&#125;&#125;)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">// 方法3：</span></span><br><span class="line"><span class="language-xml">this.$router.push(&#x27;/user/&#x27; + wade)</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">// 参数获取</span></span><br><span class="line"><span class="language-xml">$route.params.userid</span></span><br></pre></td></tr></table></figure></li><li><p><strong>query模式</strong></p></li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置路由</span></span><br><span class="line">普通配置即可</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由跳转</span></span><br><span class="line"><span class="comment">// 方法1：</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123; name: &#x27;users&#x27;, query: &#123; uname: james &#125;&#125;&quot;</span>&gt;按钮&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2：</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;users&#x27;</span>, <span class="attr">query</span>:&#123; <span class="attr">uname</span>:james &#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3：</span></span><br><span class="line">&lt;router-link :to=<span class="string">&quot;&#123; path: &#x27;/user&#x27;, query: &#123; uname:james &#125;&#125;&quot;</span>&gt;按钮&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法4：</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;/user&#x27;</span>, <span class="attr">query</span>:&#123; <span class="attr">uname</span>:james &#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法5：</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&#x27;/user?uname=&#x27;</span> + jsmes)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取参数</span></span><br><span class="line">$route.<span class="property">query</span></span><br></pre></td></tr></table></figure><h2 id="触发钩子的完整顺序"><a href="#触发钩子的完整顺序" class="headerlink" title="触发钩子的完整顺序"></a>触发钩子的完整顺序</h2><p>假设组件A、B都被keep-alive组件包裹，从A组件首次进入B组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteLeave → beforeEach → beforeEnter → beforeRouteEnter → beforeResolve → </span><br><span class="line">afterEach → beforeCreated → created → beforeMounted → deactivated → mounted → </span><br><span class="line">activited → beforeRouterEnter-next中的回调函数 </span><br></pre></td></tr></table></figure><h2 id="Vue-router跳转和location-href有什么区别"><a href="#Vue-router跳转和location-href有什么区别" class="headerlink" title="Vue-router跳转和location.href有什么区别"></a><strong>Vue-router跳转和location.href有什么区别</strong></h2><p>location.href 跳转刷新了页面，而router.push()并没有刷新页面</p><p>在history模式中，history.pushState(XXX)跳转和router.push(XXX)跳转本质上没区别。</p><h2 id="对前端路由的理解"><a href="#对前端路由的理解" class="headerlink" title="对前端路由的理解"></a>对前端路由的理解</h2><p>起初阶段，每个页面对应一个url，每次切换页面需要从浏览器重新加载资源并刷新页面</p><p>随着Ajax(可以在不刷新页面发起请求)的出现，催生出了SPA页面的概念，但是在SPA诞生之初，切换页面url始终保持不变，浏览器无法准确记录访问历时，因此出现了前端路由，也就是浏览器展示的组件与url的一个映射关系，从而实现JS切换展示组件的功能，并且能记录历时记录。</p><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><ul><li>State用来存放公共状态</li><li>Getter相当于Vuex的计算属性<ul><li>普通访问</li><li>函数访问</li></ul></li><li>Mutation存放函数用于变更状态<ul><li>Mutation中必须存放同步代码，不可以异步修改State的值</li><li>采用commit的方式唤醒Mutation事件</li></ul></li><li>Action用于异步提交Mutation事件从而变更State状态<ul><li>采用派发dispatch的方式唤醒Action事件</li></ul></li><li>Module允许将臃肿的Vuex分模块</li></ul><h2 id="Vue3升级了什么"><a href="#Vue3升级了什么" class="headerlink" title="Vue3升级了什么"></a>Vue3升级了什么</h2><ol><li><p>检测机制改变</p><p> 有原来的Object.defineProperty变为了ES6 Proxy，Proxy最大的好处就是可以一次对整个对象监听，不用再一次遍历对象属性进行监听。其次就是支持数组、Map、Set等更多的数据类型监听</p></li><li><p>提升了v-if优先级，高于v-for</p></li><li><p>将作用域插槽改成了函数的方式，当插槽改变，父组件不用跟着重新渲染了</p></li><li><p>新增了组合式api，更好抽离业务逻辑，解决了原来的this指向问题</p></li></ol><h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><p>Virtual Dom实际上式一个JS对象，通过对象的方式来表示DOM结构，配合不同的渲染工具，使跨平台成为可能。通过将多次Dom修改的结果一次性更新到页面上，从而减少页面的渲染次数。</p><p>再每次数据发生变化之前，虚拟DOM都会将新旧VDOM通过diff算法进行对比，从而改变真实DOM。</p><h2 id="虚拟DOM对比真实DOM"><a href="#虚拟DOM对比真实DOM" class="headerlink" title="虚拟DOM对比真实DOM"></a>虚拟DOM对比真实DOM</h2><p>真实DOM：生成HTML字符串、重建所有DOM元素</p><p>虚拟DOM：生成Node、diff算法、更新必要DOM</p><p>虚拟DOM首次加载DOM更慢，但是在真实DOM针对特定优化下更快</p><h2 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h2><p>不会跨级对比，只会在新旧VDOM树的同一层去对比。</p><p>深度遍历的过程</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS</title>
      <link href="/blog/2022/11/12/%E5%89%8D%E7%AB%AF%E5%A4%87%E6%88%98-CSS/"/>
      <url>/blog/2022/11/12/%E5%89%8D%E7%AB%AF%E5%A4%87%E6%88%98-CSS/</url>
      
        <content type="html"><![CDATA[<h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>当一个元素拥有了BFC属性，这个元素就可以看成一个隔离了的容器。容器里面的元素不会影响到外边的元素。</p><p>触发BFC的条件:</p><ul><li>html根元素</li><li>浮动元素</li><li>绝对定位元素</li><li>大多数的display</li><li>overflow值不为visible块元素</li><li>contain值为layout、content、paint的元素（可以将页面小饰件和整个页面隔离开）</li><li>多列容器</li></ul><p>用处：</p><ul><li>清除浮动</li><li>解决外边距合并问题</li><li>可以阻止元素被浮动元素覆盖</li></ul><h2 id="CSS3动画"><a href="#CSS3动画" class="headerlink" title="CSS3动画"></a>CSS3动画</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">html</span> lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;<span class="selector-tag">a</span>&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    <span class="selector-class">.a</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">        <span class="attribute">background</span>: <span class="number">#f40</span>;</span><br><span class="line">        <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">        <span class="comment">/*动画名称*/</span></span><br><span class="line">        <span class="attribute">animation-name</span>: mymove;</span><br><span class="line">        <span class="comment">/*动画持续时间*/</span></span><br><span class="line">        <span class="attribute">animation-duration</span>: <span class="number">2s</span>;</span><br><span class="line">        <span class="comment">/* 动画效果 */</span></span><br><span class="line">        <span class="attribute">animation-timing-function</span>: ease-in-out;</span><br><span class="line">        <span class="comment">/* 动画延迟时间 */</span></span><br><span class="line">        <span class="attribute">animation-delay</span>: <span class="number">1s</span>;</span><br><span class="line">        <span class="comment">/* 动画执行次数 */</span></span><br><span class="line">        <span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line">        <span class="comment">/* 动画播放情况，正向、反向、正反交替等 */</span></span><br><span class="line">        <span class="attribute">animation-direction</span>: normal;</span><br><span class="line">        <span class="comment">/* 动画状态，暂停还是播放 */</span></span><br><span class="line">        <span class="attribute">animation-play-state</span>: running;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 定义动画帧 */</span></span><br><span class="line">    <span class="keyword">@keyframes</span> mymove &#123;</span><br><span class="line">        <span class="number">0%</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="number">50%</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="number">100%</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/<span class="selector-tag">html</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="常见图片格式以及使用场景"><a href="#常见图片格式以及使用场景" class="headerlink" title="常见图片格式以及使用场景"></a>常见图片格式以及使用场景</h2><ul><li>BMP，是无损的，通常是较大的文件（直接色与索引色）</li><li>GIF，是无损的，文件小，支持动画以及透明。但是gif色彩值不高（索引色）</li><li>JPEG，有损的，色彩更丰富，常常用来存储企业logo（ 直接色）</li><li>PNG-8，无损的，非常好的gif格式替代者，支持透明度的调节（索引色）</li><li>PNG-24，无损，相当于BMP的压缩版，更小，但还是比其他的大（直接色）</li><li>SVG，无损矢量图，放大不会失真</li><li>WebP，同时支持有损和无损，相同质量的图片，webp有更小的体积</li></ul><h2 id="像素的知识"><a href="#像素的知识" class="headerlink" title="像素的知识"></a>像素的知识</h2><p>物理像素：设备实际像素点个数</p><p>逻辑像素：css px</p><p>n倍图：一个css像素对应n个物理像素</p><p>要想不失真，一个图片像素至少对应一个物理像素也就是倍图</p><h2 id="优化CSS的方式"><a href="#优化CSS的方式" class="headerlink" title="优化CSS的方式"></a>优化CSS的方式</h2><p><strong>加载性能：</strong></p><ul><li>css压缩</li><li>尽量减少使用@import</li><li>css单一样式</li></ul><p><strong>选择器性能：</strong></p><p>合理利用选择器</p><ul><li>减少使用后代选择器，标签选择器</li><li>尽量使用类选择器</li><li>避免使用通配符选择器</li></ul><p>渲染性能：</p><ul><li>减少浮动定位</li><li>减少浏览器重绘回流</li></ul><p>可维护性，健壮性</p><ul><li>样式抽离</li><li>外部引入</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebRTC初体验</title>
      <link href="/blog/2022/11/12/WebRTC/"/>
      <url>/blog/2022/11/12/WebRTC/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>一项实时通讯技术，允许互联网应用或站点，在不借助中间媒体的情况下，建立浏览器点对点之间的连接，实现视频流，音频流等其他任意数据的传输。用户在无需安装任何插件或第三方软件的情况下，创建点对点的<strong>数据分享</strong>和<strong>电话会议</strong>成为可能。</p><h2 id="底层协议与连接原理"><a href="#底层协议与连接原理" class="headerlink" title="底层协议与连接原理"></a>底层协议与连接原理</h2><p>基于<strong>ICE（交互式连接建立）协议</strong>，穿透防火墙，从而实现端到端建立连接。</p><h3 id="媒体协商-SDP"><a href="#媒体协商-SDP" class="headerlink" title="媒体协商(SDP)"></a>媒体协商(SDP)</h3><p>由于不同浏览器媒体编解码能力不同，因此需要协商出共有的编解码方案。</p><h3 id="网络协商-CANDIDATE"><a href="#网络协商-CANDIDATE" class="headerlink" title="网络协商(CANDIDATE)"></a>网络协商(CANDIDATE)</h3><p>理想情况下，每个浏览器都有一个自己的公网IP但实际上需要NAT技术动态分配IP</p><p><strong>STUN（NAT会话穿越程序）</strong>允许位于NAT后的客户端找到自己的公网地址。</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/84abfcee-f515-4664-9f87-3a8ba7fa6e37/Untitled.png" alt="Untitled"></p><p><strong>TURN</strong> 当STUN会话穿越失败时，TURN会请求公网IP地址作为中继服务器进行分配。</p><p><strong>ICE整合了STUN与TURN</strong></p><h3 id="信令服务器"><a href="#信令服务器" class="headerlink" title="信令服务器"></a>信令服务器</h3><p>两个设备建立WebRTC连接需要一个信令服务器来实现双方通过网络进行连接。其作用是帮助连接双方在尽可能少暴露隐私的情况下建立连接。</p><p>内容对信令服务器而言一点也不重要，其只负责传递这些内容。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="打开摄像头"><a href="#打开摄像头" class="headerlink" title="打开摄像头"></a>打开摄像头</h3><p><strong>navigator.mediaDevices.getUserMedia(</strong><code>constraints</code><strong>)</strong></p><p>返回一个promise，其中constraints传参如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">audio</span>: <span class="literal">true</span>, <span class="attr">video</span>: <span class="literal">true</span> &#125; <span class="comment">// 音视频</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">audio</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">video</span>: &#123; <span class="attr">width</span>: <span class="number">1280</span>, <span class="attr">height</span>: <span class="number">720</span> &#125; <span class="comment">// 设置分辨率</span></span><br><span class="line">&#125;</span><br><span class="line">。。。</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">mediaDevices</span>.<span class="title function_">getUserMedia</span>(constraints).<span class="title function_">then</span>(<span class="function"><span class="params">stream</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#local-video&#x27;</span>).<span class="property">srcObject</span> = stream</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="拍照"><a href="#拍照" class="headerlink" title="拍照"></a>拍照</h3><p>原理实现就是通过canvas  <strong>drawImage</strong>方法，将当前视频画面绘制入canvas页面，通过<strong>toDataURL</strong>方法，将画面转化为base64格式，放入Image src中。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">takePhoto</span>(<span class="params">vdo, pto</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> canvas = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;canvas&#x27;</span>)</span><br><span class="line">    canvas.<span class="property">width</span> = vdo.<span class="property">videoWidth</span></span><br><span class="line">    canvas.<span class="property">height</span> = vdo.<span class="property">videoHeight</span></span><br><span class="line">    <span class="keyword">const</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line">    ctx.<span class="title function_">drawImage</span>(vdo, <span class="number">0</span>, <span class="number">0</span>, canvas.<span class="property">width</span>, canvas.<span class="property">height</span>)</span><br><span class="line">    pto.<span class="property">src</span> = canvas.<span class="title function_">toDataURL</span>(<span class="string">&#x27;image/png&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="切换摄像头"><a href="#切换摄像头" class="headerlink" title="切换摄像头"></a>切换摄像头</h3><p>思路是通过**navigator.mediaDevices.enumerateDevices()**方法，获取所用设备，再进行筛选，通过设备ID引用设备。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有视频输入设备</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getDevices</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> devices = <span class="keyword">await</span> navigator.<span class="property">mediaDevices</span>.<span class="title function_">enumerateDevices</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;🚀🚀🚀 / devices&#x27;</span>, devices)</span><br><span class="line">  <span class="keyword">let</span> videoDevices = devices.<span class="title function_">filter</span>(<span class="function">(<span class="params">device</span>) =&gt;</span> device.<span class="property">kind</span> === <span class="string">&#x27;videoinput&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 切换设备</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleDeviceChange</span>(<span class="params">deviceId: string</span>) &#123;</span><br><span class="line">  <span class="title function_">getLocalStream</span>()</span><br><span class="line">  <span class="keyword">const</span> stream = <span class="keyword">await</span> navigator.<span class="property">mediaDevices</span>.<span class="title function_">getUserMedia</span>(&#123;</span><br><span class="line">    <span class="attr">audio</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">video</span>: &#123;</span><br><span class="line">      <span class="attr">deviceId</span>: &#123; <span class="attr">exact</span>: deviceId &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="共享屏幕"><a href="#共享屏幕" class="headerlink" title="共享屏幕"></a>共享屏幕</h3><p>思路是通过<strong>navigator.mediaDrvices.getDisplayMedia()<strong>方法，获取屏幕视频流，再通过video的</strong>srcObject</strong>属性展示。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">shareScreen</span>(<span class="params">vdo</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> localStream = <span class="keyword">await</span> navigator.<span class="property">mediaDevices</span>.<span class="title function_">getDisplayMedia</span>(&#123;</span><br><span class="line">            <span class="attr">audio</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">video</span>: &#123;</span><br><span class="line">                <span class="attr">width</span>: <span class="number">350</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">        vdo.<span class="property">srcObject</span> = localStream</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="录制媒体流"><a href="#录制媒体流" class="headerlink" title="录制媒体流"></a>录制媒体流</h3><p>先查看浏览器支持的编码格式，通过**navigator.mediaDevices.MediaRecorder.isTypeSupported()<strong>方法，再通过</strong>mediaRecorder &#x3D; new MediaRecorder(localStream, options)**进行录制。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取浏览器支持的媒体类型</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">getSupportedMimeTypes</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> media = <span class="string">&#x27;video&#x27;</span></span><br><span class="line">        <span class="comment">// 常用的视频格式</span></span><br><span class="line">        <span class="keyword">const</span> types = [</span><br><span class="line">            <span class="string">&#x27;webm&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;mp4&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;ogg&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;mov&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;avi&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;wmv&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;flv&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;mkv&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;ts&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;x-matroska&#x27;</span>,</span><br><span class="line">        ]</span><br><span class="line">        <span class="comment">// 常用的视频编码</span></span><br><span class="line">        <span class="keyword">const</span> codecs = [<span class="string">&#x27;vp9&#x27;</span>, <span class="string">&#x27;vp9.0&#x27;</span>, <span class="string">&#x27;vp8&#x27;</span>, <span class="string">&#x27;vp8.0&#x27;</span>, <span class="string">&#x27;avc1&#x27;</span>, <span class="string">&#x27;av1&#x27;</span>, <span class="string">&#x27;h265&#x27;</span>, <span class="string">&#x27;h264&#x27;</span>]</span><br><span class="line">        <span class="comment">// 支持的媒体类型</span></span><br><span class="line">        <span class="keyword">const</span> supported = []</span><br><span class="line">        <span class="keyword">const</span> isSupported = <span class="title class_">MediaRecorder</span>.<span class="property">isTypeSupported</span></span><br><span class="line">        <span class="comment">// 遍历判断所有的媒体类型</span></span><br><span class="line">        types.<span class="title function_">forEach</span>(<span class="function">(<span class="params">type</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> mimeType = <span class="string">`<span class="subst">$&#123;media&#125;</span>/<span class="subst">$&#123;type&#125;</span>`</span></span><br><span class="line">            codecs.<span class="title function_">forEach</span>(<span class="function">(<span class="params">codec</span>) =&gt;</span></span><br><span class="line">                [</span><br><span class="line">                    <span class="string">`<span class="subst">$&#123;mimeType&#125;</span>;codecs=<span class="subst">$&#123;codec&#125;</span>`</span>,</span><br><span class="line">                    <span class="string">`<span class="subst">$&#123;mimeType&#125;</span>;codecs=<span class="subst">$&#123;codec.toUpperCase()&#125;</span>`</span>,</span><br><span class="line">                ].<span class="title function_">forEach</span>(<span class="function">(<span class="params">variation</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="title function_">isSupported</span>(variation)) supported.<span class="title function_">push</span>(variation)</span><br><span class="line">                &#125;),</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">isSupported</span>(mimeType)) supported.<span class="title function_">push</span>(mimeType)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> supported</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始录制</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">recordingScreen</span>(<span class="params">localStream</span>) &#123;</span><br><span class="line">        blobs = []</span><br><span class="line">        <span class="keyword">const</span> kbps = <span class="number">1024</span></span><br><span class="line">        <span class="keyword">const</span> <span class="title class_">Mbps</span> = kbps * kbps</span><br><span class="line">        <span class="keyword">const</span> options = &#123;</span><br><span class="line">            <span class="attr">audioBitsPerSecond</span>: <span class="number">128000</span>,</span><br><span class="line">            <span class="attr">videoBitsPerSecond</span>: <span class="number">2500000</span>,</span><br><span class="line">            <span class="attr">mimeType</span>: <span class="string">&#x27;video/webm; codecs=&quot;vp8,opus&quot;&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        mediaRecorder = <span class="keyword">new</span> <span class="title class_">MediaRecorder</span>(localStream, options)</span><br><span class="line">        mediaRecorder.<span class="title function_">start</span>(<span class="number">100</span>)</span><br><span class="line">        mediaRecorder.<span class="property">ondataavailable</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 将录制的数据合并成一个 Blob 对象</span></span><br><span class="line">            <span class="comment">// const blob = new Blob([e.data], &#123; type: e.data.type &#125;)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 🌸重点是这个地方，我们不要把获取到的 e.data.type设置成 blob 的 type，而是直接改成 mp4</span></span><br><span class="line">            blobs.<span class="title function_">push</span>(e.<span class="property">data</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 暂停录制</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">stopRecord</span>(<span class="params"></span>) &#123;</span><br><span class="line">        mediaRecorder &amp;&amp; mediaRecorder.<span class="title function_">stop</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回放</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">replay</span>(<span class="params">replayer, blobs</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>(blobs, &#123; <span class="attr">type</span>: <span class="string">&#x27;video/mp4&#x27;</span> &#125;);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(blobs);</span><br><span class="line">        replayer.<span class="property">src</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(blob);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下载</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">downloadVideo</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>(blobs, &#123; <span class="attr">type</span>: <span class="string">&#x27;video/mp4&#x27;</span> &#125;);</span><br><span class="line">        <span class="keyword">var</span> url = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(blob);</span><br><span class="line">        <span class="keyword">var</span> a = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        a.<span class="property">href</span> = url;</span><br><span class="line">        a.<span class="property">download</span> = <span class="string">&#x27;record.mp4&#x27;</span>;</span><br><span class="line">        a.<span class="title function_">click</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="总体demo代码"><a href="#总体demo代码" class="headerlink" title="总体demo代码"></a>总体demo代码</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;video id=&quot;test-video&quot; autoplay playsinline muted&gt; &lt;/video&gt;</span><br><span class="line">    &lt;button id=&quot;open-btn&quot;&gt;打开摄像头&lt;/button&gt;</span><br><span class="line">    &lt;button id=&quot;close-btn&quot;&gt;关闭摄像头&lt;/button&gt;</span><br><span class="line">    &lt;button id=&quot;takephoto-btn&quot;&gt;拍照&lt;/button&gt;</span><br><span class="line">    &lt;button id=&quot;change-cinema-btn&quot;&gt;切换设备&lt;/button&gt;</span><br><span class="line">    &lt;button id=&quot;share-screen-btn&quot;&gt;共享屏幕&lt;/button&gt;</span><br><span class="line">    &lt;button id=&quot;recording-btn&quot;&gt;开始录制&lt;/button&gt;</span><br><span class="line">    &lt;button id=&quot;stop-recording-btn&quot;&gt;停止录制&lt;/button&gt;</span><br><span class="line">    &lt;button id=&quot;review-recording-btn&quot;&gt;回放&lt;/button&gt;</span><br><span class="line">    &lt;button id=&quot;download-btn&quot;&gt;下载录制视频&lt;/button&gt;</span><br><span class="line">    &lt;img id=&quot;photo&quot; src=&quot;&quot; alt=&quot;&quot;&gt;</span><br><span class="line">    &lt;video id=&quot;replay-player&quot; autoplay playsinline muted&gt;&lt;/video&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    const vdo = document.querySelector(&#x27;#test-video&#x27;)</span><br><span class="line">    const o_btn = document.querySelector(&#x27;#open-btn&#x27;)</span><br><span class="line">    const c_btn = document.querySelector(&#x27;#close-btn&#x27;)</span><br><span class="line">    const t_btn = document.querySelector(&#x27;#takephoto-btn&#x27;)</span><br><span class="line">    const g_btn = document.querySelector(&#x27;#change-cinema-btn&#x27;)</span><br><span class="line">    const s_btn = document.querySelector(&#x27;#share-screen-btn&#x27;)</span><br><span class="line">    const r_btn = document.querySelector(&#x27;#recording-btn&#x27;)</span><br><span class="line">    const b_btn = document.querySelector(&#x27;#stop-recording-btn&#x27;)</span><br><span class="line">    const l_btn = document.querySelector(&#x27;#review-recording-btn&#x27;)</span><br><span class="line">    const pto = document.querySelector(&#x27;#photo&#x27;)</span><br><span class="line">    const replayer = document.querySelector(&#x27;#replay-player&#x27;)</span><br><span class="line">    const d_btn = document.querySelector(&#x27;#download-btn&#x27;)</span><br><span class="line">    let blobs = []; // 用于存放录制视频的二进制文件</span><br><span class="line">    let mediaRecorder = null; // 录制对象</span><br><span class="line">    // 获取视频流</span><br><span class="line">    async function getVideoStream(vdo) &#123;</span><br><span class="line">        const content = &#123;</span><br><span class="line">            video: &#123;</span><br><span class="line">                width: 300,</span><br><span class="line">                heigth: 150</span><br><span class="line">            &#125;,</span><br><span class="line">            audio: true</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            const videoStream = await navigator.mediaDevices.getUserMedia(content)</span><br><span class="line">            vdo.srcObject = videoStream</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">            alert(error)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    // 删除视频流</span><br><span class="line">    function removeVideoStream(vdo) &#123;</span><br><span class="line">        vdo.srcObject = null</span><br><span class="line">    &#125;</span><br><span class="line">    // 拍照</span><br><span class="line">    function takePhoto(vdo, pto) &#123;</span><br><span class="line">        const canvas = document.createElement(&#x27;canvas&#x27;)</span><br><span class="line">        canvas.width = vdo.videoWidth</span><br><span class="line">        canvas.height = vdo.videoHeight</span><br><span class="line">        const ctx = canvas.getContext(&#x27;2d&#x27;)</span><br><span class="line">        ctx.drawImage(vdo, 0, 0, canvas.width, canvas.height)</span><br><span class="line">        pto.src = canvas.toDataURL(&#x27;image/png&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    // 切换摄像头</span><br><span class="line">    async function changeCinema() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            const devices = await navigator.mediaDevices.enumerateDevices()</span><br><span class="line">            const videoDevices = devices.filter((device) =&gt; device.kind === &#x27;videoinput&#x27;)</span><br><span class="line">            console.log(videoDevices);</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">            alert(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 共享屏幕</span><br><span class="line">    async function shareScreen(vdo) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            const localStream = await navigator.mediaDevices.getDisplayMedia(&#123;</span><br><span class="line">                audio: true,</span><br><span class="line">                video: &#123;</span><br><span class="line">                    width: 350</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;)</span><br><span class="line">            vdo.srcObject = localStream</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">            alert(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 获取浏览器支持的媒体类型</span><br><span class="line">    function getSupportedMimeTypes() &#123;</span><br><span class="line">        const media = &#x27;video&#x27;</span><br><span class="line">        // 常用的视频格式</span><br><span class="line">        const types = [</span><br><span class="line">            &#x27;webm&#x27;,</span><br><span class="line">            &#x27;mp4&#x27;,</span><br><span class="line">            &#x27;ogg&#x27;,</span><br><span class="line">            &#x27;mov&#x27;,</span><br><span class="line">            &#x27;avi&#x27;,</span><br><span class="line">            &#x27;wmv&#x27;,</span><br><span class="line">            &#x27;flv&#x27;,</span><br><span class="line">            &#x27;mkv&#x27;,</span><br><span class="line">            &#x27;ts&#x27;,</span><br><span class="line">            &#x27;x-matroska&#x27;,</span><br><span class="line">        ]</span><br><span class="line">        // 常用的视频编码</span><br><span class="line">        const codecs = [&#x27;vp9&#x27;, &#x27;vp9.0&#x27;, &#x27;vp8&#x27;, &#x27;vp8.0&#x27;, &#x27;avc1&#x27;, &#x27;av1&#x27;, &#x27;h265&#x27;, &#x27;h264&#x27;]</span><br><span class="line">        // 支持的媒体类型</span><br><span class="line">        const supported = []</span><br><span class="line">        const isSupported = MediaRecorder.isTypeSupported</span><br><span class="line">        // 遍历判断所有的媒体类型</span><br><span class="line">        types.forEach((type) =&gt; &#123;</span><br><span class="line">            const mimeType = `$&#123;media&#125;/$&#123;type&#125;`</span><br><span class="line">            codecs.forEach((codec) =&gt;</span><br><span class="line">                [</span><br><span class="line">                    `$&#123;mimeType&#125;;codecs=$&#123;codec&#125;`,</span><br><span class="line">                    `$&#123;mimeType&#125;;codecs=$&#123;codec.toUpperCase()&#125;`,</span><br><span class="line">                ].forEach((variation) =&gt; &#123;</span><br><span class="line">                    if (isSupported(variation)) supported.push(variation)</span><br><span class="line">                &#125;),</span><br><span class="line">            )</span><br><span class="line">            if (isSupported(mimeType)) supported.push(mimeType)</span><br><span class="line">        &#125;)</span><br><span class="line">        return supported</span><br><span class="line">    &#125;</span><br><span class="line">    // 开始录制</span><br><span class="line">    function recordingScreen(localStream) &#123;</span><br><span class="line">        blobs = []</span><br><span class="line">        const kbps = 1024</span><br><span class="line">        const Mbps = kbps * kbps</span><br><span class="line">        const options = &#123;</span><br><span class="line">            audioBitsPerSecond: 128000,</span><br><span class="line">            videoBitsPerSecond: 2500000,</span><br><span class="line">            mimeType: &#x27;video/webm; codecs=&quot;vp8,opus&quot;&#x27;,</span><br><span class="line">        &#125;</span><br><span class="line">        mediaRecorder = new MediaRecorder(localStream, options)</span><br><span class="line">        mediaRecorder.start(100)</span><br><span class="line">        mediaRecorder.ondataavailable = (e) =&gt; &#123;</span><br><span class="line">            // 将录制的数据合并成一个 Blob 对象</span><br><span class="line">            // const blob = new Blob([e.data], &#123; type: e.data.type &#125;)</span><br><span class="line"></span><br><span class="line">            // 🌸重点是这个地方，我们不要把获取到的 e.data.type设置成 blob 的 type，而是直接改成 mp4</span><br><span class="line">            blobs.push(e.data)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    // 暂停录制</span><br><span class="line">    function stopRecord() &#123;</span><br><span class="line">        mediaRecorder &amp;&amp; mediaRecorder.stop();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    // 回放</span><br><span class="line">    function replay(replayer, blobs) &#123;</span><br><span class="line">        const blob = new Blob(blobs, &#123; type: &#x27;video/mp4&#x27; &#125;);</span><br><span class="line">        console.log(blobs);</span><br><span class="line">        replayer.src = URL.createObjectURL(blob);</span><br><span class="line">    &#125;</span><br><span class="line">    // 下载</span><br><span class="line">    function downloadVideo() &#123;</span><br><span class="line">        var blob = new Blob(blobs, &#123; type: &#x27;video/mp4&#x27; &#125;);</span><br><span class="line">        var url = URL.createObjectURL(blob);</span><br><span class="line">        var a = document.createElement(&#x27;a&#x27;);</span><br><span class="line">        a.href = url;</span><br><span class="line">        a.download = &#x27;record.mp4&#x27;;</span><br><span class="line">        a.click();</span><br><span class="line">    &#125;</span><br><span class="line">    o_btn.onclick = () =&gt; &#123;</span><br><span class="line">        return getVideoStream(vdo)</span><br><span class="line">    &#125;</span><br><span class="line">    c_btn.onclick = () =&gt; &#123;</span><br><span class="line">        return removeVideoStream(vdo)</span><br><span class="line">    &#125;</span><br><span class="line">    t_btn.onclick = () =&gt; &#123;</span><br><span class="line">        return takePhoto(vdo, pto)</span><br><span class="line">    &#125;</span><br><span class="line">    g_btn.onclick = () =&gt; &#123;</span><br><span class="line">        return changeCinema()</span><br><span class="line">    &#125;</span><br><span class="line">    s_btn.onclick = () =&gt; &#123;</span><br><span class="line">        return shareScreen(vdo)</span><br><span class="line">    &#125;</span><br><span class="line">    r_btn.onclick = () =&gt; &#123;</span><br><span class="line">        return recordingScreen(vdo.srcObject)</span><br><span class="line">    &#125;</span><br><span class="line">    b_btn.onclick = () =&gt; &#123;</span><br><span class="line">        return stopRecord()</span><br><span class="line">    &#125;</span><br><span class="line">    l_btn.onclick = () =&gt; &#123;</span><br><span class="line">        return replay(replayer, blobs)</span><br><span class="line">    &#125;</span><br><span class="line">    d_btn.onclick = () =&gt; &#123;</span><br><span class="line">        return downloadVideo(blobs)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="搭建信令服务器"><a href="#搭建信令服务器" class="headerlink" title="搭建信令服务器"></a>搭建信令服务器</h3>]]></content>
      
      
      
        <tags>
            
            <tag> WebRTC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/blog/2022/11/12/%E9%9D%A2%E8%AF%95%E5%A4%87%E6%88%98-Git/"/>
      <url>/blog/2022/11/12/%E9%9D%A2%E8%AF%95%E5%A4%87%E6%88%98-Git/</url>
      
        <content type="html"><![CDATA[<h3 id="git工作流程"><a href="#git工作流程" class="headerlink" title="git工作流程"></a>git工作流程</h3><p>四个工作区：</p><ul><li>工作区</li><li>暂存区</li><li>本地仓库</li><li>远程仓库</li></ul><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/460ac973-ab43-4181-a63c-0404d22bc5ff/Untitled.png" alt="Untitled"></p><h3 id="常见指令"><a href="#常见指令" class="headerlink" title="常见指令"></a>常见指令</h3><ul><li>git clone将存储库克隆到本地</li><li>git init创建新的git仓库</li><li>git remote管理远程仓库<ul><li>git remote -v &#x2F;&#x2F; 查看连接的远程仓库地址<br>  git remote add origin [gitUrl] &#x2F;&#x2F; 为本地仓库添加远程仓库地址<br>  git push -u origin master &#x2F;&#x2F; 将本地仓库的master和远程仓库的master进行关联<br>  git remote origin set-url [gitUrl] &#x2F;&#x2F; 为本地仓库修改远程仓库地址<br>  git remote rm origin &#x2F;&#x2F; 为本地仓库删除远程仓库连接</li></ul></li><li>git branch查看创建删除分支</li><li>git tag创建查看删除标签</li><li>git add 将本地文件添加到暂存区</li><li>git commit将文件添加到本地仓库</li><li>git push将本地分支推送到远程仓库</li><li>git pull从远端拉取并合并本地分支</li><li>git fetch获取远程代码库</li><li>git merge将其他分支内容合并到当前分支</li><li>git reset用于回退版本</li><li>git revert回滚提交</li></ul><h3 id="git-reset-–hard-XXX-恢复被抹除的版本"><a href="#git-reset-–hard-XXX-恢复被抹除的版本" class="headerlink" title="git reset –hard XXX 恢复被抹除的版本"></a>git reset –hard XXX 恢复被抹除的版本</h3><p>思路是：可以使用git reflog命令查看想要恢复的分支版本号，然后在reset以下\</p><h3 id="巧妙使用git-reset-–-soft"><a href="#巧妙使用git-reset-–-soft" class="headerlink" title="巧妙使用git reset – soft"></a>巧妙使用git reset – soft</h3><p>因为soft模式夏git保留当前工作区中的内容，因此当存在多次无意义的小commit时，可以soft reset到一个主要的commit，也就相当于合并commit</p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>git checkout 文件名，可以将修改撤回到上一次add . 或commit的状态 </p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ts小总结</title>
      <link href="/blog/2022/11/12/%E9%9D%A2%E8%AF%95%E5%A4%87%E6%88%98-TS/"/>
      <url>/blog/2022/11/12/%E9%9D%A2%E8%AF%95%E5%A4%87%E6%88%98-TS/</url>
      
        <content type="html"><![CDATA[<h2 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a><strong>声明数组</strong></h2><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="attr">numlist</span>:<span class="built_in">number</span>[] = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>]</span><br></pre></td></tr></table></figure><h2 id="如果元素不同，则是元组"><a href="#如果元素不同，则是元组" class="headerlink" title="如果元素不同，则是元组"></a><strong>如果元素不同，则是元组</strong></h2><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a><strong>联合类型</strong></h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Type1</span>|<span class="title class_">Type2</span>|<span class="title class_">Type3</span></span><br></pre></td></tr></table></figure><h2 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h2><p>一系列抽象方法的声明，是一些方法特征的集合</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">IPerson</span> &#123;</span><br><span class="line">    <span class="attr">firstName</span>: string,</span><br><span class="line">    <span class="attr">lastName</span>: string,</span><br><span class="line">    <span class="attr">sayHi</span>: <span class="function">() =&gt;</span> string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="attr">customer</span>: <span class="title class_">IPerson</span> = &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&quot;Hanks&quot;</span>,</span><br><span class="line">    <span class="attr">sayHi</span>: (): <span class="function"><span class="params">string</span> =&gt;</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Hi there&quot;</span> &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 也可以这样写</span></span><br><span class="line"><span class="comment">// var customer = &lt;IPerson&gt;&#123;</span></span><br><span class="line"><span class="comment">//     firstName: &quot;Tom&quot;,</span></span><br><span class="line"><span class="comment">//     lastName: &quot;Hanks&quot;,</span></span><br><span class="line"><span class="comment">//     sayHi: (): string =&gt; &#123; return &quot;Hi there&quot; &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(customer);</span><br></pre></td></tr></table></figure><p><strong>联合类型+接口</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="title class_">IPerson</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: string | string[]</span><br><span class="line">    <span class="attr">sayHi</span>: <span class="function">() =&gt;</span> string | <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="attr">customer</span>: <span class="title class_">IPerson</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: [<span class="string">&quot;Hanks&quot;</span>, <span class="string">&#x27;aa&#x27;</span>],</span><br><span class="line">    <span class="attr">sayHi</span>: (): <span class="function"><span class="params">void</span> =&gt;</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(customer);</span><br></pre></td></tr></table></figure><p><strong>数组+接口</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface A &#123;</span><br><span class="line">    [<span class="attr">index</span>: number]: string | number</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: A = [<span class="string">&#x27;1&#x27;</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,b);</span><br><span class="line"></span><br><span class="line">interface namelist &#123;</span><br><span class="line">    [<span class="attr">index</span>: number]: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型一致，正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">list2</span>: namelist = [<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>, <span class="string">&quot;Taobao&quot;</span>]</span><br></pre></td></tr></table></figure><p><strong>接口继承</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Child</span>_interface_name <span class="keyword">extends</span> super_interface1_name, super_interface2_name,…,super_interfaceN_name</span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">class_name</span> &#123; </span><br><span class="line">    <span class="comment">// 类作用域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123; </span><br><span class="line">   <span class="comment">// 字段</span></span><br><span class="line">   <span class="attr">engine</span>:string; </span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 构造函数</span></span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params">engine:string</span>) &#123; </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">engine</span> = engine </span><br><span class="line">   &#125;  </span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 方法</span></span><br><span class="line">   <span class="title function_">disp</span>():<span class="keyword">void</span> &#123; </span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;函数中显示发动机型号  :   &quot;</span>+<span class="variable language_">this</span>.<span class="property">engine</span>) </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建一个对象</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;XXSY1&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 访问字段</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;读取发动机型号 :  &quot;</span>+obj.<span class="property">engine</span>)  </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 访问方法</span></span><br><span class="line">obj.<span class="title function_">disp</span>()</span><br></pre></td></tr></table></figure><p><strong>TS一次只支持继承一个类，并不支持一次继承多个类，这一点区别于TS接口</strong></p><p><strong>继承</strong></p><p>super是对父类的直接引用</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">job</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, job: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">job</span> = job</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">doJob</span>(<span class="attr">job</span>: <span class="built_in">string</span> | <span class="built_in">void</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">        job = job || <span class="variable language_">this</span>.<span class="property">job</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我正在做&#x27;</span> + job);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;我正在做&#x27;</span> + job</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Father</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, job: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(name, job)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">doJob</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我正在学&#x27;</span> + <span class="variable language_">this</span>.<span class="property">job</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;我正在学&#x27;</span> + <span class="variable language_">this</span>.<span class="property">job</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fatherJob</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">doJob</span>(<span class="string">&#x27;监督儿子&#x27;</span> + <span class="variable language_">this</span>.<span class="property">job</span> + <span class="string">&#x27;的工作&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> <span class="title class_">Father</span>(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;司机&#x27;</span>)</span><br><span class="line">f.<span class="title function_">doJob</span>()</span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;Mack&#x27;</span>, <span class="string">&#x27;Ts&#x27;</span>)</span><br><span class="line">s.<span class="title function_">doJob</span>()</span><br><span class="line">s.<span class="title function_">fatherJob</span>()</span><br></pre></td></tr></table></figure><p><strong>访问控制</strong></p><ul><li><strong>public（默认）</strong> : 公有，可以在任何地方被访问。</li><li><strong>protected</strong> : 受保护，可以被其自身以及其子类访问。</li><li><strong>private</strong> : 私有，只能被其定义所在的类访问。</li></ul><p><strong>实现接口（implements）</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ILoan</span> &#123; </span><br><span class="line">   <span class="attr">interest</span>:<span class="built_in">number</span> </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgriLoan</span> <span class="keyword">implements</span> <span class="title class_">ILoan</span> &#123; </span><br><span class="line">   <span class="attr">interest</span>:<span class="built_in">number</span> </span><br><span class="line">   <span class="attr">rebate</span>:<span class="built_in">number</span> </span><br><span class="line">   </span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params">interest:<span class="built_in">number</span>,rebate:<span class="built_in">number</span></span>) &#123; </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">interest</span> = interest </span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">rebate</span> = rebate </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">AgriLoan</span>(<span class="number">10</span>,<span class="number">1</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;利润为 : &quot;</span>+obj.<span class="property">interest</span>+<span class="string">&quot;，抽成为 : &quot;</span>+obj.<span class="property">rebate</span> )</span><br></pre></td></tr></table></figure><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ts中对象是事先定义好的模板，不能自己再添加属性</span><br><span class="line"><span class="keyword">const</span> m = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// a: (): void =&gt; &#123; &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">m.<span class="property">a</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上述是不被允许的</span></span><br></pre></td></tr></table></figure><h2 id="type类型别名"><a href="#type类型别名" class="headerlink" title="type类型别名"></a>type类型别名</h2><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">AB</span> = &#123;</span><br><span class="line">    name?: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="string">&#x27;1&#x27;</span> | <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">d</span>: <span class="variable constant_">AB</span> = &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>一个简单的泛型例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> func&lt;T,k&gt;(<span class="attr">a</span>: T, <span class="attr">b</span>: K): k &#123;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">func</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>));</span><br><span class="line"><span class="comment">// ts会自动进行类型推断</span></span><br></pre></td></tr></table></figure><p>泛型接口：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">HasLength</span> &#123;</span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> func&lt;T <span class="keyword">extends</span> <span class="title class_">HasLength</span>&gt;(<span class="attr">a</span>: T): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="property">length</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>(<span class="string">&quot;123&quot;</span>)</span><br><span class="line"><span class="title function_">func</span>(&#123;<span class="attr">length</span>:<span class="number">222</span>&#125;)</span><br><span class="line"><span class="title function_">func</span>(<span class="number">123</span>) <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Ts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vite</title>
      <link href="/blog/2022/11/12/%E9%9D%A2%E8%AF%95%E5%A4%87%E6%88%98-Vite/"/>
      <url>/blog/2022/11/12/%E9%9D%A2%E8%AF%95%E5%A4%87%E6%88%98-Vite/</url>
      
        <content type="html"><![CDATA[<h2 id="出现背景"><a href="#出现背景" class="headerlink" title="出现背景"></a>出现背景</h2><p><a href="https://imgse.com/i/z3uqN8"><img src="https://s1.ax1x.com/2022/11/22/z3uqN8.png" alt="z3uqN8.png"></a></p><h2 id="构建工具做了什么"><a href="#构建工具做了什么" class="headerlink" title="构建工具做了什么"></a>构建工具做了什么</h2><p><a href="https://imgse.com/i/z3KSun"><img src="https://s1.ax1x.com/2022/11/22/z3KSun.png" alt="z3KSun.png"></a></p><p>总的来所，构建工具就是整合不同的语法处理工具，将其按照指定配置文件将不同语法进行统一编译整合，结合热更新，就会让我们每次修改代码之后，不需要手动编译，浏览器自动更新状态。</p><h2 id="Vite的优势"><a href="#Vite的优势" class="headerlink" title="Vite的优势"></a>Vite的优势</h2><p>快</p><h2 id="Vite启动项目初体验"><a href="#Vite启动项目初体验" class="headerlink" title="Vite启动项目初体验"></a>Vite启动项目初体验</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Vite </tag>
            
            <tag> 构建工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack</title>
      <link href="/blog/2022/11/12/%E9%9D%A2%E8%AF%95%E5%A4%87%E6%88%98-Webpack/"/>
      <url>/blog/2022/11/12/%E9%9D%A2%E8%AF%95%E5%A4%87%E6%88%98-Webpack/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.webpackjs.com/">webpack 中文文档 | webpack 中文网 (webpackjs.com)</a></p><h2 id="五大核心概念"><a href="#五大核心概念" class="headerlink" title="五大核心概念"></a>五大核心概念</h2><ul><li><p>entry入口</p><p>  来指示webpack从哪个文件开始打包</p></li><li><p>output输出</p><p>  指定打包后的资源位置</p></li><li><p>modules模块</p><p>  默认wb只能打包js、json等资源，有了加载器就能识别并打包不同模块</p></li><li><p>plugins插件</p><p>  扩展webpack的功能</p></li><li><p>mode模式</p><ul><li>开发模式development</li><li>生产模式production</li></ul></li></ul><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>webpack.config.js</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// 入口文件</span></span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">    <span class="comment">// 出口</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;dist&quot;</span>), <span class="comment">// 绝对路径</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;main.js&#x27;</span> <span class="comment">// 文件名</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 加载器</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            <span class="comment">// loader的配置</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="comment">// 插件的配置</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>npx webpack指令进行打包</p><h2 id="开发模式介绍"><a href="#开发模式介绍" class="headerlink" title="开发模式介绍"></a>开发模式介绍</h2><ul><li><p>处理代码让浏览器能够识别并运行</p></li><li><p>代码质量检查，树立代码规范</p><p>  eslint等代码运行是更加健壮</p></li></ul><h2 id="处理css资源"><a href="#处理css资源" class="headerlink" title="处理css资源"></a>处理css资源</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            <span class="comment">// loader的配置</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="comment">// 正则，检测所有以css结尾的文件</span></span><br><span class="line">                <span class="attr">use</span>: [</span><br><span class="line">                    <span class="string">&#x27;style-loader&#x27;</span>, <span class="comment">// 将commonjs引入的css文件以创建script标签的方式添加到HTML页面中</span></span><br><span class="line">                    <span class="string">&#x27;css-loader&#x27;</span> <span class="comment">// 将css资源编译成commonjs资源</span></span><br><span class="line">                ] <span class="comment">// 从右往左（下-上）一次使用css-loader style-loader</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>less\scss等同理</p><h2 id="处理图片资源"><a href="#处理图片资源" class="headerlink" title="处理图片资源"></a>处理图片资源</h2><ul><li>wp5与wp4有所不用，处理图片资源时，wp5已经内置了图片处理，不像wb4还得加载file-loader和url-loader</li></ul><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p>可以自动生成html文件，并自动修改资源引用路径</p><h3 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h3><p>自动清理dist文件</p><h2 id="开发工具devtools（无法用于生产环境）"><a href="#开发工具devtools（无法用于生产环境）" class="headerlink" title="开发工具devtools（无法用于生产环境）"></a>开发工具devtools（无法用于生产环境）</h2><h3 id="source-map功能"><a href="#source-map功能" class="headerlink" title="source map功能"></a>source map功能</h3><p>可以对打包后的代码映回原始代码</p><h3 id="inline-source-map"><a href="#inline-source-map" class="headerlink" title="inline-source-map"></a>inline-source-map</h3><p>用于追踪打包前错误出现的原始位置</p><h3 id="自动编译代码"><a href="#自动编译代码" class="headerlink" title="自动编译代码"></a>自动编译代码</h3><ol><li><p>webpack’s Watch Mode</p><p> 开启watch模式，自动编译，但需要手动刷新浏览器</p></li><li><p>webpack-dev-server</p><p> 提供一个简单的web服务器</p> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">contentBase</span>: <span class="string">&#x27;./dist&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 以上配置告知 webpack-dev-server，在 localhost:8080 下建立服务，将 dist 目录下的文件，作为可访问文件。</span></span><br></pre></td></tr></table></figure></li><li><p>webpack-dev-middleware</p></li></ol><h2 id="总结开发模式的配置"><a href="#总结开发模式的配置" class="headerlink" title="总结开发模式的配置"></a>总结开发模式的配置</h2><ol><li>entry指定入口文件</li><li>output指定输出文件</li><li>module帮助webpack识别其不能识别的东西</li><li>plugins插件，比如自动填写打包后js文件的引用路径</li><li>devServer，搭建开发服务器，自动编译打包</li><li>mode设置开发模式</li></ol><h2 id="提取CSS形成单独文件"><a href="#提取CSS形成单独文件" class="headerlink" title="提取CSS形成单独文件"></a>提取CSS形成单独文件</h2><p>由于webpack打包之后默认将css打包到js中，再通过引入js再引入css，因此需要提取css成单独文件。</p><p>MiniCssExtractPlugin </p><p>在使用之前需要修改原来的style-loader</p><h3 id="CSS压缩"><a href="#CSS压缩" class="headerlink" title="CSS压缩"></a>CSS压缩</h3><p>css-minimizer-webpack-plugin</p>]]></content>
      
      
      
        <tags>
            
            <tag> 构建工具 </tag>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能优化</title>
      <link href="/blog/2022/11/12/%E9%9D%A2%E8%AF%95%E5%A4%87%E6%88%98-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/blog/2022/11/12/%E9%9D%A2%E8%AF%95%E5%A4%87%E6%88%98-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><ul><li>link代替import</li><li>减少重绘回流<ul><li>回流<ul><li>操作DOM</li><li>元素位置发生改变</li><li>尺寸</li><li>内容</li><li>获取浏览器信息</li><li>浏览器窗口尺寸</li></ul></li><li>减少方式<ul><li>替换class的方式修改样式</li><li>文档碎片</li><li>display：none</li></ul></li></ul></li><li>事件委托</li><li>webworkers</li><li>CSS选择器优化</li><li>flex布局</li><li>使用transform实现动画，避免重绘回流</li></ul><h2 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h2><ul><li><p>图片延迟加载</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;img data-src=<span class="string">&quot;https://avatars0.githubusercontent.com/u/22117876?s=460&amp;u=7bd8f32788df6988833da6bd155c3cfbebc68006&amp;v=4&quot;</span>&gt;</span><br><span class="line"><span class="keyword">const</span> img = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line">img.<span class="property">src</span> = img.<span class="property">dataset</span>.<span class="property">src</span></span><br></pre></td></tr></table></figure></li><li><p>响应式图片</p></li><li><p>降低图片质量</p><ul><li>采用image-webpack-loader</li><li>配置CDN压缩图片</li><li>利用在线网站压缩</li><li>微信（doge）</li></ul></li><li><p>采用webp格式</p></li></ul><h2 id="资源压缩方面"><a href="#资源压缩方面" class="headerlink" title="资源压缩方面"></a>资源压缩方面</h2><ul><li>webpack打包压缩</li><li>采用字体图标代替图片图标</li></ul><h2 id="网络请求方面"><a href="#网络请求方面" class="headerlink" title="网络请求方面"></a>网络请求方面</h2><p>高并发表示系统在短时间内能够处理大批量请求</p><ul><li><p>使用缓存，避免重复请求</p></li><li><p>静态资源上传CDN</p><ul><li><p>CDN原理（内容分发网络）（Content Delivery Network）</p><p>  在现有网络基础上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的调度，使就近用户获取资源，降低网络拥塞，提高用户访问的响应速度和命中率<strong>。</strong></p><p>  <strong>CDN——近距离给用户分发网络内容，加速服务。</strong></p><p>  CDN：拉近距离，加速</p><ul><li>加速：压缩代码</li><li>拉近距离：在全球建立多个CDN服务器，提前备份源服务器资源，在用户请求时，就近分发给用户。</li></ul></li></ul><p>  <a href="https://imgse.com/i/z3VzG9"><img src="https://s1.ax1x.com/2022/11/22/z3VzG9.md.png" alt="z3VzG9.md.png"></a>  </p></li><li><p>避免高频刷新页面，可以每5s刷新一次</p></li><li><p>将多次请求合并为一次、</p><p>  <a href="https://imgse.com/i/z3Vh5Q"><img src="https://s1.ax1x.com/2022/11/22/z3Vh5Q.png" alt="z3Vh5Q.png"></a></p><p>  可以看出资源的下载时间仅仅占了总时间的13.05 &#x2F; 204.16 &#x3D; 6.39%</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器</title>
      <link href="/blog/2022/11/12/%E9%9D%A2%E8%AF%95%E5%A4%87%E6%88%98-%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
      <url>/blog/2022/11/12/%E9%9D%A2%E8%AF%95%E5%A4%87%E6%88%98-%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><p><a href="https://imgse.com/i/z3ZYGj"><img src="https://s1.ax1x.com/2022/11/22/z3ZYGj.md.png" alt="z3ZYGj.md.png"></a></p><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>早期HTTP1.0</p><p>通过<strong>Expires字段</strong>,存在于浏览器返回的响应头中，告诉浏览器这个过程是可以直接从浏览器获取数据，无需再次请求。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Expires</span>: <span class="title class_">Wed</span>, <span class="number">22</span> <span class="title class_">Nov</span> <span class="number">2019</span> <span class="number">08</span>:<span class="number">41</span>:<span class="number">00</span> <span class="variable constant_">GMT</span> </span><br></pre></td></tr></table></figure><p>但是由于服务器和浏览器时间可能并不一致，因此在HTTP1.1中这种操作被废弃了。</p><p><strong>Cache-Control</strong></p><p>区别于Expires的具体的过期时间，前者采用了过期时长来控制。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Cache</span>-<span class="title class_">Control</span>:max-age=<span class="number">3600</span></span><br></pre></td></tr></table></figure><p>还有其他参数</p><ul><li>private只有浏览器进行缓存</li><li>no-cache跳过强缓存，直接进入协商缓存</li><li>no-store不进行缓存</li><li>s-maxage针对代理服务器的缓存时间</li></ul><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>当强缓存失效后，浏览器在请求头中携带相应的缓存tag来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存。</p><p><strong>缓存tag：</strong></p><ul><li><p><strong>Last-Modified最后修改时间</strong></p><p>  服务器在第一次响应后会在响应头添加这个字段，也就是服务器的最后修改时间，浏览器第二次请求会加上浏览器传过来的最后修改时间，若服务器端修改时间改变，则直接更新，返回新的资源。否则返回304，告诉浏览器直接使用缓存</p></li><li><p><strong>ETag文件唯一标识</strong></p><p>  ETag是服务器根据当前文件内容给浏览器添加的唯一标识，第一次请求时，浏览器会将ETag直接放在响应头发送给浏览器，浏览器在下次请求后会将这个值作为<strong>If-None-Match</strong></p><p>  这个字段的内容，将其发送给服务器，服务器再进行对比，并决定浏览器是否使用缓存。</p></li></ul><p><strong>两者对比：</strong></p><p>从精准度来将，ETag显然更高，而从性能来看，Last-Modifie显然更方便。</p><h3 id="缓存存放的位置"><a href="#缓存存放的位置" class="headerlink" title="缓存存放的位置"></a>缓存存放的位置</h3><p>按照优先级高低排列依次是：</p><ul><li><p><strong>Service Worker</strong></p><p>  借鉴了webworker的思路，让js运行在主线程之外，但是脱离了浏览器窗体，不能操纵DOM</p></li><li><p>Memory Cache</p><p>  效率快，但存活时间短</p></li><li><p>Disk Cache</p><p>  效率慢，但存活时间长</p></li><li><p>Push Cache</p><p>  在HTTP2.0才更多的使用</p></li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h3><p><a href="https://imgse.com/i/z3ZBZT"><img src="https://s1.ax1x.com/2022/11/22/z3ZBZT.md.png" alt="z3ZBZT.md.png"></a></p><h2 id="浏览器本地存储"><a href="#浏览器本地存储" class="headerlink" title="浏览器本地存储"></a>浏览器本地存储</h2><p><strong>主要分为：</strong></p><ul><li><p>C<strong>ookie</strong></p><p>  Cookie最早设计出来仅仅是为了弥补HTTP状态管理上的不足</p><p>  本质上就是在浏览器存储一个很小的文本文件（4KB）</p><p>  但是Cookie有很多致命的缺陷：</p><ul><li><strong>容量缺陷</strong>（4K）</li><li><strong>性能缺陷</strong>（Cookie紧跟域名，尽管该域名某些地址下不需要这些Cookie，请求都会携带上完整的Cookie，这个可以通过设置Cookie来配置）</li><li><strong>安全缺陷</strong>（由于Cookie是以纯文本的形式在浏览器和服务器之间传递，因此很容易被非法劫持篡改，在Cookie有效期内重新发送给服务器，这是相当危险的。而且在HttpOnly为false的情况下，可以用js脚本直接获取Cookie）</li></ul></li><li><p><strong>webStorage</strong></p><p>  <strong>localStorage</strong>与Cookie相似，也会针对一个域名存储数据，但是与Cookie区别很大</p><ul><li><strong>容量上线是5M</strong>,而且是持久存储</li><li><strong>只存在客户端</strong>，默认不参与服务端通信，避免了Cookie带来的性能问题和安全问题</li><li><strong>接口封装</strong></li></ul><p>  <strong>sessionStorage页面关闭就会消失</strong></p><ul><li>可以对表单信息进行维护</li><li>可以用来存储本次浏览记录，例如微博就是</li></ul></li><li><p><strong>IndexedDB</strong></p><p>  运行在浏览器的一个非关系型数据库，理论上它的容量没有上线</p><ul><li>键值对存储</li><li>异步操作</li><li>受同源策略影响</li></ul></li></ul><h2 id="输入浏览器到页面呈现发生了什么？"><a href="#输入浏览器到页面呈现发生了什么？" class="headerlink" title="输入浏览器到页面呈现发生了什么？"></a>输入浏览器到页面呈现发生了什么？</h2><h3 id="网络角度"><a href="#网络角度" class="headerlink" title="网络角度"></a>网络角度</h3><p><strong>（1）构建请求</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器会构建请求行</span></span><br><span class="line"><span class="variable constant_">GET</span> / <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br></pre></td></tr></table></figure><p><strong>（2）查找强缓存</strong></p><p>先查找强缓存，若命中则直接使用，否则进入下一步</p><p><strong>（3）DNS解析</strong></p><p>由于输入的是域名，而数据包是通过IP地址传给对方的。因此我们需要得到域名对应的IP地址。也就是域名系统与IP的一个映射。</p><p>浏览器有DNS数据缓存的功能，即一个域名解析过，下次直接走缓存，不再需要DNS解析</p><p><strong>（4）建立TCP连接</strong></p><p>Chrome在同一域名下要求最多只能有6个TCP连接，超过的话剩下的请求就得等待</p><p>建立TCP连接需要经历下面三个阶段</p><ol><li>三次握手建立客户端与服务器之间的连接</li><li>进行数据传输（接收方在接收到数据之后必须向发送方进行确认，如果发送方没接收到这个消息，则判断数据包丢失）</li><li>四次挥手断开连接</li></ol><p><strong>（5）发送HTTP请求</strong></p><p>请求行+请求头+请求体</p><p><strong>总结</strong></p><p><a href="https://imgse.com/i/z3ZRQ1"><img src="https://s1.ax1x.com/2022/11/22/z3ZRQ1.md.png" alt="z3ZRQ1.md.png"></a></p><h3 id="解析算法"><a href="#解析算法" class="headerlink" title="解析算法"></a>解析算法</h3><p>完成了网络请求个响应，如果响应头中Content-Type的值是text&#x2F;html,那么接下来的就是浏览器的解析和渲染工作了。</p><ul><li><p><strong>构建DOM树</strong></p><p>  DOM树本质上是以document为根节点的多叉树</p><p>  HTML文法是上下文有关文法</p><p>  解析算法</p><ul><li>标记化</li><li>建树</li></ul></li><li><p><strong>样式计算</strong></p></li><li><p><strong>生成布局树（Layout Tree）</strong><br><a href="https://imgse.com/i/z3Z5dO"><img src="https://s1.ax1x.com/2022/11/22/z3Z5dO.png" alt="z3Z5dO.png"></a></p></li></ul><h3 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h3><p>在<strong>DOM树</strong> → <strong>布局树（layout tree）</strong>创建之后，浏览器还会创建<strong>图层树（layer tree）</strong></p><p>一般情况下，节点的图层默认属于父亲节点的图层（这些图层也称为<strong>合成层</strong>），那么什么时候节点会提升到单独的图层(<strong>合成层</strong>)呢？<br><a href="https://imgse.com/i/z3ZIoD"><img src="https://s1.ax1x.com/2022/11/22/z3ZIoD.png" alt="z3ZIoD.png"></a></p><ul><li><p><strong>显示合成，如何产生合成层（形成单独的一层）</strong></p><p>  <a href="https://imgse.com/i/z3e9YQ"><img src="https://s1.ax1x.com/2022/11/22/z3e9YQ.png" alt="z3e9YQ.png"></a></p></li><li><p><strong>隐式合成，如何被动的形成合成层</strong></p><p>  当层级比较底的节点被提升为单独的图层之后，那么所有层级比他高的节点都会成为一个单独的图层。<br>  <strong>层爆炸原理</strong>当一个z-index比较低的元素被提升为单独图层之后，层叠在他上面的元素统统会被提升为单独的图层，可能会增加上千个图层，大大增加内存压力！<strong>但是现在浏览器优化做的很好，已经很少存在层爆炸现象了！（层压缩）</strong></p></li><li><p><strong>合成层的优缺点</strong></p><p>  优点：</p><ul><li>合成层的位图会交给GPU合成，比CPU快，减轻CPU负担</li><li>需要repaint时，仅仅重绘本身，不会影响到其他图层</li><li>transform 和 opacity 才不会触发 repaint，如果不是合成层，则其依然会触发 repaint。</li></ul><p>  缺点：</p><ul><li>绘制的图层必须传输到 GPU，这些层的数量和大小达到一定量级后，可能会导致传输非常慢，进而导致一些低端和中端设备上出现闪烁；</li><li>隐式合成容易产生过量的合成层，每个合成层都占用额外的内存，而内存是移动设备上的宝贵资源，过多使用内存可能会导致浏览器崩溃，让性能优化适得其反。</li></ul></li></ul><h2 id="重绘、回流、合成"><a href="#重绘、回流、合成" class="headerlink" title="重绘、回流、合成"></a>重绘、回流、合成</h2><h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><p><strong>触发条件</strong></p><p>当DOM的修改导致样式的变化，并且没有影响几何属性的时候，会导致重绘</p><p><strong>重绘过程</strong></p><p><a href="https://imgse.com/i/z3enkF"><img src="https://s1.ax1x.com/2022/11/22/z3enkF.png" alt="z3enkF.png"></a><br><strong>重绘不一定导致回流，但回流一定发生重绘</strong></p><h3 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h3><p><strong>触发条件</strong></p><p>当对DOM结构的修改引发的DOM集合尺寸变化的时候，会发生回流</p><ul><li>几何属性：width、height、padding、margin、left、top、border等</li><li>DOM节点发生增删或移动</li><li>读写offset、scroll、client族属性时，浏览器为了获取这些值，会进行回流操作</li><li>调用window.getComputedStyle方法</li></ul><p><strong>回流过程</strong></p><p><a href="https://imgse.com/i/z3euY4"><img src="https://s1.ax1x.com/2022/11/22/z3euY4.png" alt="z3euY4.png"></a></p><h3 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h3><p>有一种情况是直接合成，比如利用CSS3的transform、opacity、filter这些属性就可以实现合成的效果，也就是GPU加速。</p><p>在合成的情况下，会直接跳过布局和绘制的过程，直接进入非主线程处理的部分，即交给合成线程处理。</p><p>GPU善于进行图像处理</p><h3 id="实践意义"><a href="#实践意义" class="headerlink" title="实践意义"></a>实践意义</h3><ul><li>避免频繁修改style，而是采用修改class的方式</li><li>使用createDocumentFragment进行批量的DOM操作</li><li>对于resize、sscroll等进行防抖节流处理</li><li>添加<strong>will-change:transform，</strong> 让渲染引擎为其单独实现一个图层</li></ul><h2 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h2><h3 id="XSS跨站脚本攻击（Cross-Site-Scripting）"><a href="#XSS跨站脚本攻击（Cross-Site-Scripting）" class="headerlink" title="XSS跨站脚本攻击（Cross Site Scripting）"></a>XSS跨站脚本攻击（Cross Site Scripting）</h3><p>指在浏览器中执行恶意脚本，从而拿到用户的信息并进行操作。浏览器没有对恶意代码进行过滤，使其在用户浏览器运行，从而：</p><ul><li>窃取Cookie</li><li>监听用户行为，比如输入账号密码之后直接发送到黑客服务器</li><li>修改DOM伪造登录表单</li><li>在页面中生成悬浮广告</li></ul><p><strong>XSS也分为下面三种方式：</strong></p><ul><li><p><strong>1.</strong>  <strong>存储型</strong></p><p>  <a href="https://imgse.com/i/z3eYTO"><img src="https://s1.ax1x.com/2022/11/22/z3eYTO.png" alt="z3eYTO.png"></a></p></li><li><p><strong>2.  反射型</strong></p><p>  <a href="https://imgse.com/i/z3eafH"><img src="https://s1.ax1x.com/2022/11/22/z3eafH.png" alt="z3eafH.png"></a></p></li><li><p><strong>3.  文档型</strong></p><p>  <a href="https://imgse.com/i/z3eafH"><img src="https://s1.ax1x.com/2022/11/22/z3eafH.png" alt="z3eafH.png"></a></p></li></ul><p><strong>防范措施（一个信念，两个利用）：</strong></p><ul><li>永远不要相信任何用户输入</li><li>利用Cookie的HttpOnly进制JS脚本获取Cookie</li><li>利用CSP规定浏览器只能访问特定资源</li></ul><h3 id="CSRF跨站请求伪造（Cross-site-request-forgery）"><a href="#CSRF跨站请求伪造（Cross-site-request-forgery）" class="headerlink" title="CSRF跨站请求伪造（Cross-site request forgery）"></a>CSRF跨站请求伪造（Cross-site request forgery）</h3><ul><li><h2 id="自动发起GET请求"><a href="#自动发起GET请求" class="headerlink" title="自动发起GET请求"></a>自动发起GET请求</h2><p>  <a href="https://imgse.com/i/z3eB6I"><img src="https://s1.ax1x.com/2022/11/22/z3eB6I.png" alt="z3eB6I.png"></a></p></li><li><p>模拟用户自动发送post</p></li><li><p>诱导点击发送GET请求</p></li></ul><p><strong>解决办法：</strong></p><ul><li>利用Cookie sameSite属性，对请求的Cookie携带进行限制</li><li>验证来源站点，通过请求头里面的Origin Referer</li><li>CSRF Token ， 例如Python Django框架，在请求的时候向服务器发送指定字符串，当再次发送请求时，客户端携带指定字符串，服务器经验证通过后，才命中请求。</li></ul><h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><h3 id="HTTPS为什么让数据传输更安全"><a href="#HTTPS为什么让数据传输更安全" class="headerlink" title="HTTPS为什么让数据传输更安全"></a>HTTPS为什么让数据传输更安全</h3><p>由于HTTP明文传输，可能被截获、伪造请求，不会验证报文完整性</p><p><a href="https://imgse.com/i/z3eh1s"><img src="https://s1.ax1x.com/2022/11/22/z3eh1s.png" alt="z3eh1s.png"></a></p><p><a href="https://imgse.com/i/z3eon0"><img src="https://s1.ax1x.com/2022/11/22/z3eon0.png" alt="z3eon0.png"></a></p><p><strong>HTTPS的优点：</strong></p><ul><li>加密</li><li>完整性校验</li><li>身份认证</li></ul><p><strong>什么是TLS&#x2F;SSL？</strong></p><p><code>TLS(Transport Layer Security)</code>是 <code>SSL(Secure Socket Layer)</code>的后续版本，它们是用于在互联网两台计算机之间用于<code>身份验证</code>和<code>加密</code>的一种协议。</p><p><strong>TLS使用了对称加密和非对称加密两种</strong></p><p>对称加密，一个密钥，如果密钥泄露，就完蛋了</p><p>非对称加密，一个公钥，一个私钥，即使公钥泄露，私钥依然保存在自己手中，没完蛋，但是是单向的，我传你，你不能传我</p><p><a href="https://imgse.com/i/z3eqNF"><img src="https://s1.ax1x.com/2022/11/22/z3eqNF.png" alt="z3eqNF.png"></a></p><h2 id="浏览器组成"><a href="#浏览器组成" class="headerlink" title="浏览器组成"></a>浏览器组成</h2><ul><li>浏览器主进程</li><li>GPU进程</li><li>网络进程</li><li>多个渲染进程</li><li>多个插件进程</li></ul><h2 id="浏览器事件循环机制"><a href="#浏览器事件循环机制" class="headerlink" title="浏览器事件循环机制"></a>浏览器事件循环机制</h2><h3 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h3><p>每一个函数在运行的时候都会生成新的执行上下文，执行上下文回包含当前函数的参数，局部变量信息，正在执行的上下文始终处于栈的顶部</p><h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><h2 id="优化首屏加载时间"><a href="#优化首屏加载时间" class="headerlink" title="优化首屏加载时间"></a>优化首屏加载时间</h2><p>计算方式：performance.timing.domComplete - performance.timing.navigationStart</p><ul><li>使用路由懒加载，只有在跳转到该路由时才加载组件</li><li>最好使用CDN的方式引入</li><li>采用HTTP缓存</li><li>按需加载组件</li><li>图片资源压缩</li><li>gzip格式压缩</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Js小总结</title>
      <link href="/blog/2022/11/11/%E9%9D%A2%E8%AF%95%E5%A4%87%E6%88%98-JS/"/>
      <url>/blog/2022/11/11/%E9%9D%A2%E8%AF%95%E5%A4%87%E6%88%98-JS/</url>
      
        <content type="html"><![CDATA[<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><a href="https://juejin.cn/post/6844903983429976078">https://juejin.cn/post/6844903983429976078</a></p><p>一些例子</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> + <span class="string">&#x27;1&#x27;</span> === <span class="string">&#x27;01&#x27;</span>            <span class="comment">// true</span></span><br><span class="line"><span class="literal">true</span> + <span class="literal">true</span> === <span class="number">2</span>           <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> === <span class="number">0</span>                 <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> + <span class="literal">false</span> === <span class="number">0</span>         <span class="comment">// true</span></span><br><span class="line">&#123;&#125; + [] === <span class="number">0</span>               <span class="comment">// true</span></span><br><span class="line">[] + &#123;&#125; === <span class="number">0</span>               <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li><p>类型种类</p><ul><li>简单类型<ul><li>number</li><li>string</li><li>boolean</li><li>null</li><li>undefined</li><li>bigint</li><li>symbol</li></ul></li><li>复杂类型<ul><li>对象</li></ul></li></ul></li><li><p>强制类型转换</p><ul><li><p>toString</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>(<span class="number">4</span>)                    <span class="comment">// &quot;4&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">false</span>)                <span class="comment">// &quot;false&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">true</span>)                 <span class="comment">// &quot;true&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">null</span>)                 <span class="comment">// &quot;null&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="literal">undefined</span>)            <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="title class_">String</span>(<span class="title class_">Symbol</span>(<span class="string">&#x27;s&#x27;</span>))          <span class="comment">// &quot;Symbol(s)&quot;</span></span><br><span class="line"><span class="comment">// 对于复杂数据类型，toString()会调用原型上的toString方法，</span></span><br><span class="line"><span class="comment">// 因此可以重写该方法</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.<span class="title function_">toString</span>()             <span class="comment">// &quot;1,2&quot;</span></span><br><span class="line"><span class="title class_">String</span>(arr)                <span class="comment">// &quot;1,2&quot;</span></span><br><span class="line"><span class="comment">// 重写toString</span></span><br><span class="line">arr.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">join</span>(<span class="string">&#x27;/&#x27;</span>) &#125;;</span><br><span class="line"><span class="title class_">String</span>(arr)                <span class="comment">// &quot;1/2&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>toNumber</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;4&quot;</span>)                  <span class="comment">// 4</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;4a&quot;</span>)                 <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;&quot;</span>)                   <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">false</span>)                <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">true</span>)                 <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">null</span>)                 <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">undefined</span>)            <span class="comment">// NaN</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="title class_">Symbol</span>(<span class="string">&#x27;s&#x27;</span>))          <span class="comment">// TypeError...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于引用类型，会先看对象中是否有valueOf()方法，若有则先调用valueOf</span></span><br><span class="line"><span class="comment">// ，否则调用toString，最后才返回NaN。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li><p>隐式转换</p><p>  js隐式转换都遵循强制转换规则的</p><p>  在隐式转换中最令人迷惑的应该就是+操作符和&#x3D;&#x3D;操作符导致的隐式转换<br>  ，因为对于其他类型的操作符，类型四则运算的-、*、÷和位运算符&amp;、^、|在设计目标就是对数字进行操作。</p><ul><li><p><strong>+的隐式转换</strong></p><p>  <strong>两边都能转换成数字才进行数字相加，否则就进行字符串拼接</strong></p></li><li><p><strong>&#x3D;&#x3D;的隐式转换</strong></p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">NaN</span> == <span class="title class_">NaN</span>        <span class="comment">// false，这算是个坑吧，没啥聊的</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true，属于ecma规范</span></span><br><span class="line">[<span class="number">1</span>] == <span class="number">1</span>      <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">&#x27;0&#x27;</span>  <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == <span class="string">&#x27;&#x27;</span>   <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;&#x27;</span> == <span class="string">&#x27;0&#x27;</span>     <span class="comment">// false</span></span><br><span class="line"><span class="literal">true</span> == <span class="number">1</span>     <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == <span class="number">0</span>    <span class="comment">// true</span></span><br><span class="line"><span class="literal">true</span> == []    <span class="comment">// false</span></span><br><span class="line">[] == &#123;&#125;      <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">valueOf</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj == <span class="number">1</span>     <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 绝望</span></span><br><span class="line">[] == ![]    <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p>  <strong>对于数字和字符串的抽象比较，将字符串进行ToNumber操作后再进行比较</strong></p><p>  <strong>对于布尔值和其他类型的比较，将其布尔类型进行ToNumber操作后再进行比较</strong></p><p>  <strong>对于对象和基础类型的比较，将对象进行ToPrimitive操作后在进行比较</strong></p><p>  <strong>对象之间的比较，引用同一个对象则为true，否则为false</strong></p></li></ul><p><strong>总结：</strong><br>对于+而言，若出现字符串，则进行字符串拼接，否则两边尽可能转化成Number类型进行运算。<br>对于&#x3D;&#x3D;而言，对于object而言，进行toPrimitive操作，先看valueOf是否转换普通类型，再看toString是否转换普通类型，否则报错。</p><h2 id="作用域与作用域链"><a href="#作用域与作用域链" class="headerlink" title="作用域与作用域链"></a>作用域与作用域链</h2><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><ul><li>最外层函数和最外层变量</li><li>未直接声明就赋值的变量</li><li>window对象的属性</li></ul><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><ul><li>定义在函数内部的变量</li></ul><h3 id="ES6块级作用域"><a href="#ES6块级作用域" class="headerlink" title="ES6块级作用域"></a>ES6块级作用域</h3><ul><li>let const {}</li></ul><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。</p><p>作用域链的作用是<strong>保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。</strong></p><p>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p><p>当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。</p><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><ul><li>全局执行上下文</li><li>函数执行上下文</li><li>eval函数执行上下文</li></ul><p><strong>执行上下文栈</strong></p><p>JavaScript引擎使用执行上下文栈来管理执行上下文当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。</p><p>在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。</p><p><strong>总结</strong>：作用域分为全局、块级、函数，函数执行上下文在执行时入栈，执行完出栈（执行栈），全局执行上下文最后出栈。</p><h2 id="闭包以及闭包的应用"><a href="#闭包以及闭包的应用" class="headerlink" title="闭包以及闭包的应用"></a>闭包以及闭包的应用</h2><p><strong>闭包就是一个函数，能够访问另一个函数作用域内的变量。</strong></p><ul><li><p><strong>产生原因</strong></p><p>  作用域链，每个函数都会拷贝上一级的作用域链+本地的作用域来形成自身的作用域链。</p><p>  当一个函数，在另一个函数的作用域内，就会访问父函数作用域内的自由变量。</p></li><li><p><strong>闭包的表现形式</strong></p><ul><li>返回一个函数</li><li>作为函数参数传递</li><li>使用了回调函数</li><li>立即执行函数</li></ul></li></ul><h3 id="基础（Base）函数装饰器"><a href="#基础（Base）函数装饰器" class="headerlink" title="基础（Base）函数装饰器"></a>基础（Base）函数装饰器</h3><p><strong>函数修饰器，都是基于此变化而来。</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Base</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="防抖（Debounce）"><a href="#防抖（Debounce）" class="headerlink" title="防抖（Debounce）"></a>防抖（Debounce）</h3><p><strong>就是一个函数执行两次需要指定间隔时间，若不能满足，则重新计算间隔时间。</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防抖，被装饰的函数每隔一定时间间隔才能运行，若强制运行，则会重新计算间隔时间</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Debounce</span>(<span class="params">fn, delay_time</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer)&#123; <span class="built_in">clearTimeout</span>(timer); timer = <span class="literal">null</span>&#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(fn.<span class="title function_">bind</span>(<span class="variable language_">this</span>, ...args), delay_time)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="节流（Throttle）"><a href="#节流（Throttle）" class="headerlink" title="节流（Throttle）"></a>节流（Throttle）</h3><p><strong>节流， 函数在特定时间内只能执行一次。</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节流， 函数在特定时间内只能执行一次</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Throttle</span>(<span class="params">fn, time</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="keyword">return</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">        &#125;, time)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="万斯（Once）"><a href="#万斯（Once）" class="headerlink" title="万斯（Once）"></a>万斯（Once）</h3><p><strong>函数只执行一次</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数只执行一次</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Once</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            flag = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="限制（Limit）"><a href="#限制（Limit）" class="headerlink" title="限制（Limit）"></a>限制（Limit）</h3><p><strong>限制函数执行指定次数。</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数只执行限定次数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Limit</span>(<span class="params">fn, num</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        count++</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= num)</span><br><span class="line">            <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消耗（Consumer）"><a href="#消耗（Consumer）" class="headerlink" title="消耗（Consumer）"></a>消耗（Consumer）</h3><p><strong>定义操作栈，间隔某个时间从操作栈取出执行(延迟执行效果)</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义操作栈，间隔某个时间从操作栈取出执行(延迟执行效果)</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Consumer</span>(<span class="params">fn, time</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> ops = []</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">        ops.<span class="title function_">push</span>(fn.<span class="title function_">bind</span>(<span class="variable language_">this</span>, ...args))</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="keyword">return</span></span><br><span class="line">        timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ops.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">                timer = <span class="literal">null</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (ops.<span class="title function_">shift</span>())() <span class="comment">// 立即执行函数</span></span><br><span class="line">        &#125;, time)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><ul><li>arr.flat()方法</li><li>先转化为字符串再字符串操作</li><li>转化为JSON字符串，再正则替换</li><li>递归<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, [<span class="number">6</span>, <span class="number">7</span>, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;]]]]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">flat</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = []</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myFlat</span>(<span class="params">item, n</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> item) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(i) &amp;&amp; n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            n--</span><br><span class="line">            <span class="title function_">myFlat</span>(i)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">myFlat</span>(a, <span class="number">1</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br></pre></td></tr></table></figure></li></ul><h2 id="数组中常用的高阶函数"><a href="#数组中常用的高阶函数" class="headerlink" title="数组中常用的高阶函数"></a>数组中常用的高阶函数</h2><ul><li>map</li><li>reduce</li><li>filter</li><li>sort<br>内部是利用递归进行冒泡排序的，传入一个Compare函数，根据返回bool判断是否交换两个数。</li><li>some</li><li>every</li></ul><h2 id="var与let"><a href="#var与let" class="headerlink" title="var与let"></a>var与let</h2><ul><li>var无块级作用域</li><li>var存在变量提升</li><li>var重复声明变量依然照常运行</li><li>全局定义的var变量会成为window的属性，let和const则不会</li></ul><h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><p>手动实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span> &amp;&amp; target !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> cloneTarget = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? [] : &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> target) &#123;</span><br><span class="line">            cloneTarget[i] = <span class="title function_">clone</span>(target[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    <span class="attr">field1</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">field2</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">field3</span>: <span class="string">&#x27;ConardLi&#x27;</span>,</span><br><span class="line">    <span class="attr">field4</span>: &#123;</span><br><span class="line">        <span class="attr">child</span>: <span class="string">&#x27;child&#x27;</span>,</span><br><span class="line">        <span class="attr">child2</span>: &#123;</span><br><span class="line">            <span class="attr">child2</span>: <span class="string">&#x27;child2&#x27;</span>,</span><br><span class="line">            <span class="attr">a</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">23</span>, <span class="number">3</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">clone</span>(target));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="浏览器输入URL发生了什么"><a href="#浏览器输入URL发生了什么" class="headerlink" title="浏览器输入URL发生了什么"></a>浏览器输入URL发生了什么</h2><p>浏览器先去服务器找真实IP -&gt; 与客户端建立连接 -&gt; 缓存协商 -&gt; 获取页面 -&gt; 渲染页面</p><h2 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h2><ol><li><p>全局上下文</p><p> this默认指向window，严格模式指向undefined</p></li><li><p>对象中的方法</p><p> 谁调用指向谁，若在全局调用则指向按照全局上下文</p></li><li><p>事件绑定</p><p> 指向绑定事件的dom元素</p></li><li><p>箭头函数</p><p> 指向最近一级作用域，若外部有非箭头函数包裹，则this指向箭头函数this，否则指向window（严格模式undefined）</p></li></ol><h2 id="数据是如何存储的"><a href="#数据是如何存储的" class="headerlink" title="数据是如何存储的"></a>数据是如何存储的</h2><p>一般来说，普通数据类型存放在栈中，引用数据类型，也就是对象，存放在堆中。</p><p>但是闭包例外，闭包变量存放在堆中。</p><p>栈不仅仅存放临时数据类型，同时也用来记录当前程序的执行状态，也就是将程序执行上下文的指针存放到栈中。</p><h2 id="垃圾回收（GC）"><a href="#垃圾回收（GC）" class="headerlink" title="垃圾回收（GC）"></a>垃圾回收（GC）</h2><p>并行回收，浏览器垃圾清理线程会开启多个辅助线程来帮助浏览器进行垃圾清理，缩短垃圾清理时间，也就是主线程<strong>全停顿</strong>时间</p><p><strong>v8堆内存大小</strong></p><p>64位系统而言，新生代64MB，老生代1.4G</p><p>无法控制垃圾回收时间</p><p><strong>变量 → 新生代 → 老生代</strong></p><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>采用<strong>Copy(复制)<strong>、</strong>Scavenge(新生代互换)</strong></p><h3 id="老生代"><a href="#老生代" class="headerlink" title="老生代"></a>老生代</h3><p>采用<strong>Mark-Sweep(标记清除)<strong>、</strong>Mark-Compact(标记整理)</strong></p><p><strong>Mark-Compact先整理再清除</strong></p><p>在那之后，由于统一时间进行内存清理，因此用户体验比较差，也就出现了之后的增量标记，但是又出现一个问题，也就是1.暂停后如何恢复；2.暂停后引用关系修改了怎么办。解决办法：</p><ul><li>三色标记法<ul><li>黑：被引用对象，且成员函数均被标记</li><li>白：未引用对象</li><li>灰：自身被引用，但成员对象指向的引用未被标记</li></ul></li><li>写屏障法<ul><li>强制将被改变对象的颜色变为灰色</li></ul></li></ul><h2 id="浏览器如何运行js代码"><a href="#浏览器如何运行js代码" class="headerlink" title="浏览器如何运行js代码"></a>浏览器如何运行js代码</h2><ol><li>首先通过词法分析，语法分析，生成<strong>AST（抽象语法树）</strong></li><li>其次，将AST转换为字节码</li><li>最后，<strong>解释器</strong>逐行执行<strong>字节码</strong>，当遇到某一部分代码重复出现，v8则会启动<strong>编译器</strong>，将<strong>热点代码</strong>编译成机器码，以优化执行效率。（这也就是为什么js并不是严格意义上的解释性语言，因为有编译器的参与。）</li></ol><p><strong>为什么需要先转换成字节码，直接转换成机器码不好吗？</strong></p><p>这是因为机器码占据内存大，这样做减轻了内存的负荷。</p><h2 id="浏览器事件循环机制"><a href="#浏览器事件循环机制" class="headerlink" title="浏览器事件循环机制"></a>浏览器事件循环机制</h2><p><strong>浏览器的事件循环机制图解</strong></p><p><a href="https://imgse.com/i/z3ZS2R"><img src="https://s1.ax1x.com/2022/11/22/z3ZS2R.md.png" alt="z3ZS2R.md.png"></a></p><p>由于js是单线程模式，因此有了同步任务，异步任务之分</p><p>异步任务又分为宏任务、微任务</p><p>执行顺序是:</p><p><strong>同步任务</strong> → <strong>微任务</strong> → <strong>宏任务</strong></p><h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><ul><li>setTimeout\setInterval\setImmediate(这三个是由定时器模块控制，当到达事件后，进入宏任务队列，等待任务队列读取执行)</li><li>渲染事件</li><li>用户交互事件</li><li>js脚本执行</li><li>网络请求、文件读写完成等等</li></ul><h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><ul><li>Promise</li><li>V8垃圾回收</li><li>MutationObserver</li></ul><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise有一下三大特性：</p><ul><li><p>回调函数延迟绑定</p><p>  回调函数并不是直接声明，而是从后面的.then方法传入</p></li><li><p>返回值穿透</p><p>  可以把返回的Promise穿透到外层</p></li><li><p>错误冒泡</p><p>  返回的错误会一直向后传递，被catch接收到</p></li></ul><p>Promise解决的问题：</p><p>实现链式调用，解决多层嵌套的问题</p><p>错误的一站式处理，解决每次代码中判断错误，减少代码混乱度</p><h4 id="Promise-then-参数必须是函数，如果是其他，则会传递下去"><a href="#Promise-then-参数必须是函数，如果是其他，则会传递下去" class="headerlink" title="Promise.then()参数必须是函数，如果是其他，则会传递下去"></a>Promise.then()参数必须是函数，如果是其他，则会传递下去</h4><h4 id="现在有一个p，是一个Promise，p的所有返回值不可以是p本身"><a href="#现在有一个p，是一个Promise，p的所有返回值不可以是p本身" class="headerlink" title="现在有一个p，是一个Promise，p的所有返回值不可以是p本身"></a>现在有一个p，是一个Promise，p的所有返回值不可以是p本身</h4><h4 id="Promise-all-会等待Promise数组里面的都完成，或第一个失败，若都成功，则返回一个成功的数组，若有一个失败，则只catch出第一次失败的返回值，结束时间取决于最后所有Promise0完成的时间-其他函数依然执行，但不会被捕获了。"><a href="#Promise-all-会等待Promise数组里面的都完成，或第一个失败，若都成功，则返回一个成功的数组，若有一个失败，则只catch出第一次失败的返回值，结束时间取决于最后所有Promise0完成的时间-其他函数依然执行，但不会被捕获了。" class="headerlink" title="Promise.all()会等待Promise数组里面的都完成，或第一个失败，若都成功，则返回一个成功的数组，若有一个失败，则只catch出第一次失败的返回值，结束时间取决于最后所有Promise0完成的时间. 其他函数依然执行，但不会被捕获了。"></a>Promise.all()会等待Promise数组里面的都完成，或第一个失败，若都成功，则返回一个成功的数组，若有一个失败，则只catch出第一次失败的返回值，结束时间取决于最后所有Promise0完成的时间. 其他函数依然执行，但不会被捕获了。</h4><h4 id="Promise-race-会返回最快的Promise，完成时间与最后一个Promise执行时间相同，只捕获最早返回的函数，其他函数依然执行，只是不被捕获。"><a href="#Promise-race-会返回最快的Promise，完成时间与最后一个Promise执行时间相同，只捕获最早返回的函数，其他函数依然执行，只是不被捕获。" class="headerlink" title="Promise.race()会返回最快的Promise，完成时间与最后一个Promise执行时间相同，只捕获最早返回的函数，其他函数依然执行，只是不被捕获。"></a>Promise.race()会返回最快的Promise，完成时间与最后一个Promise执行时间相同，只捕获最早返回的函数，其他函数依然执行，只是不被捕获。</h4><h4 id="Async-Await-可以理解为await后面的语句被放到new-Promise中，之后的语句会放到Promise-then中"><a href="#Async-Await-可以理解为await后面的语句被放到new-Promise中，之后的语句会放到Promise-then中" class="headerlink" title="Async Await 可以理解为await后面的语句被放到new Promise中，之后的语句会放到Promise.then中"></a>Async Await 可以理解为await后面的语句被放到new Promise中，之后的语句会放到Promise.then中</h4><h2 id="生成器Generator"><a href="#生成器Generator" class="headerlink" title="生成器Generator"></a>生成器Generator</h2><p>调用Generator函数时，函数并不直接执行，而是返回一个指向函数内部状态的指针</p><p><strong>Generator相当于一个状态机，迭代器对象中，每次遇到 yield 或 return 时，就相当于一个状态，会暂停函数执行，调用next()才会向下运行，改变状态。</strong></p><p><strong>注意yield只能用在Generator函数里面，用在普通函数中会报错</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;状态1&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;状态2&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;终止状态&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f = <span class="title function_">foo</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">next</span>()); <span class="comment">// &#123; value: &#x27;状态1&#x27;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">next</span>()); <span class="comment">// &#123; value: &#x27;状态2&#x27;, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">next</span>()); <span class="comment">// &#123; value: &#x27;终止状态&#x27;, done: false &#125;</span></span><br></pre></td></tr></table></figure><p><strong>next可以传递参数,作为yield执行返回值</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">    a = <span class="keyword">yield</span> <span class="string">&#x27;状态1&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">    a = <span class="keyword">yield</span> <span class="string">&#x27;状态2&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;终止状态&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f = <span class="title function_">foo</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">next</span>(<span class="number">12</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">next</span>(<span class="number">14</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">next</span>(<span class="number">24</span>));</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// &#123; value: &#x27;状态1&#x27;, done: false &#125;</span></span><br><span class="line"><span class="comment">// 14</span></span><br><span class="line"><span class="comment">// &#123; value: &#x27;状态2&#x27;, done: false &#125;</span></span><br><span class="line"><span class="comment">// 24</span></span><br><span class="line"><span class="comment">// &#123; value: &#x27;终止状态&#x27;, done: true &#125;</span></span><br></pre></td></tr></table></figure><p><strong>for…of可以遍历Generator</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="literal">undefined</span></span><br><span class="line">    a = <span class="keyword">yield</span> <span class="string">&#x27;状态1&#x27;</span></span><br><span class="line">    a = <span class="keyword">yield</span> <span class="string">&#x27;状态2&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;终止状态&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f = <span class="title function_">foo</span>()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> f) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 状态1</span></span><br><span class="line"><span class="comment">// 状态2</span></span><br></pre></td></tr></table></figure><p><strong>异步使用Generator函数</strong></p><p><a href="https://imgse.com/i/z3ZPr6"><img src="https://s1.ax1x.com/2022/11/22/z3ZPr6.md.png" alt="z3ZPr6.md.png"></a></p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>Generator是如何然函数暂停执行后又再次恢复的呢，这里就涉及到协程的概念。</p><p><strong>什么是协程？</strong></p><p>协程是一种比线程更加轻量的存在，一个线程可以有多个协程。可以将协程理解为线程中的一个个任务。协程不由操作系统管理，而是通过被具体的应用程序代码所控制</p><p><strong>协程运作过程？</strong></p><p>协程之间是互斥执行的，比如当前执行A协程，要想此时执行B协程，需要先将A协程的控制权交给B，等待协程B运行完毕之后，再将协程控制权交给A。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 协程A</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是协程A&#x27;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">B</span>() <span class="comment">// 将控制权交给协程B</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;结束了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是协程B&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;我是B传给A的值&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="title function_">A</span>()</span><br><span class="line">a.<span class="title function_">next</span>()</span><br><span class="line">a.<span class="title function_">next</span>()</span><br></pre></td></tr></table></figure><h2 id="clientHeight、innerHeight、offsetHeight、scrollHeight联系和区别"><a href="#clientHeight、innerHeight、offsetHeight、scrollHeight联系和区别" class="headerlink" title="clientHeight、innerHeight、offsetHeight、scrollHeight联系和区别"></a>clientHeight、innerHeight、offsetHeight、scrollHeight联系和区别</h2><ul><li>clientHeight返回视口高度，包括padding</li><li>offsetHeight返回实际元素占用的像素高度</li><li>innerHeight浏览器内部高度</li><li>outerHeight浏览器包括工具栏</li><li>scrollHeight包括由于滚动被抹去的部分元素高度</li><li>scrollTop指的是滚动条滚动的长度</li></ul><h2 id="js脚本延迟加载的方式"><a href="#js脚本延迟加载的方式" class="headerlink" title="js脚本延迟加载的方式"></a>js脚本延迟加载的方式</h2><ul><li>defer属性 异步加载，最后执行，顺序不保证</li><li>async属性 异步加载，加载后立即执行</li><li>动态注入script标签</li><li>使用setTimeout延迟方法</li><li>将js写到文档底部</li></ul><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p><strong>变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。</strong></p><p><strong>函数先于变量进行提升</strong></p><h2 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h2><p>尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p><h2 id="ES6-Module-与-CommonJS模块的异同"><a href="#ES6-Module-与-CommonJS模块的异同" class="headerlink" title="ES6 Module 与 CommonJS模块的异同"></a>ES6 Module 与 CommonJS模块的异同</h2><p>ES6相当于对模块的引用，不能改变其值 （const a &#x3D; {}）</p><p>CommonJs相当于指针指向当前模块，可以改变指针指向 (let a &#x3D; {})</p><h2 id="常见的DOM操作"><a href="#常见的DOM操作" class="headerlink" title="常见的DOM操作"></a>常见的DOM操作</h2><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><p>采用先创建后添加的方式</p><p>createElement创建</p><p>appendChild添加</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>removeChild删除</p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p><em>&#x2F;&#x2F; 交换两个元素，把 content 置于 title 前面</em></p><p>container.<strong>insertBefore</strong>(content, title)</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>略</p><h2 id="原型、原型链"><a href="#原型、原型链" class="headerlink" title="原型、原型链"></a>原型、原型链</h2><p>每个构造函数（类）的内部都有一个原型属性prototype，属性值是一个对象，里面存放者所有实例（对象）所共有的属性和方法。每创建一个新的对象实例时，其内部有个指针（__proto__）指向构造函数的原型属性prototype。</p><p><strong>最好不要使用__proto__来获取原型，因为不规范，应该使用Object.getPrototypeOf()方法</strong></p><p>eg:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改原型</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span> === p.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 重写原型</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line"><span class="attr">getName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)        <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span> === p.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>导致最后输出false的原因是：由于Person原型被修改，导致存放在原型中的构造函数（constructor）丢失，实例p在自身原型中查找自身构造函数未找到，于是继续向上查找吗，找到了Object的构造函数，类Object的prototype与修改之后的实例对象__proto__肯定不同，因此返回false</p><p>eg:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="property">__proto__</span>  <span class="comment">// Person.prototype</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>  <span class="comment">// Object.prototype</span></span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">__proto__</span> <span class="comment">//Object.prototype</span></span><br><span class="line">p.<span class="property">__proto__</span>.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> <span class="comment">// Object.prototype</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> <span class="comment">// Object.prototype</span></span><br><span class="line">p1.<span class="property">__proto__</span>.<span class="property">constructor</span> <span class="comment">// Person</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>  <span class="comment">// Person</span></span><br></pre></td></tr></table></figure><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>实际上重载了**.**运算符，即自己的定义覆盖了语言的原始定义，所有对对象的操作，都会会被Proxy感知。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxt</span>(target, handler)</span><br><span class="line"><span class="comment">// target是目标对象，handler是处理器</span></span><br></pre></td></tr></table></figure><h3 id="handler的选项"><a href="#handler的选项" class="headerlink" title="handler的选项"></a>handler的选项</h3><ul><li><p>get(target, key, receiver)拦截取值</p><p>  get函数中必须有返回值或reflect操作才能返回值</p></li><li><p>set(target, key, value, receiver)拦截赋值</p><ul><li>可用于实现数据验证</li></ul></li><li><p>apply(target, ctx, arg) 用于拦截函数调用</p></li><li><p>has() 可用于隐藏属性</p></li><li><p>。。。详见文档<a href="https://www.bookstack.cn/read/es6-3rd/spilt.3.docs-reflect.md">15. Reflect - 实例：使用 Proxy 实现观察者模式 - 《阮一峰 ECMAScript 6 (ES6) 标准入门教程 第三版》 - 书栈网 · BookStack</a></p></li></ul><h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><ul><li>Reflect上的方法与Proxy上的选项一一对应，目的是找到改变之前的默认方法</li><li>将一些Object上明显属于语言内部的方法放到reflect上</li><li>修改某些Object上的方法，让其变得合理</li><li>将Object上的一些命令式行为变成函数式行为放在Reflect上</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/blog/2022/11/06/%E9%9D%A2%E8%AF%95%E5%A4%87%E6%88%98-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/blog/2022/11/06/%E9%9D%A2%E8%AF%95%E5%A4%87%E6%88%98-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>衡量计算机性能的指标：</p><ul><li>速率</li><li>吞吐量</li><li>带宽</li><li>时延：指数据从网络一端传送到另一端所用的时间<ul><li>发送时延（传输时延）：发送数据全部进入信道所用的时间（机器内部）</li><li>传播时延：数据在信道上传输所占用的时间（信道上）</li><li>排队时延：分组在排队等待路由分发时所消耗的时间</li><li>处理时延：路由器或主机在接收到数据包后处理数据所用的时间</li></ul></li></ul><p>OSI参考模型0 </p><p><a href="https://imgse.com/i/z3mWVK"><img src="https://s1.ax1x.com/2022/11/22/z3mWVK.md.png" alt="z3mWVK.md.png"></a></p><p>其中前三层主要是由物理链路组成的，5 6 7 这三层则是由软件（协议）控制的</p><ul><li><p><strong>物理层</strong></p><p>  物理层主要负责规定了电气特性，比如光纤，有光脉冲表示1，无表示0.</p><p>  物理层设备需要中继器，这是为了保证数据传输的稳定性，解决信号衰减、信号失真的问题。中继器会对信号进行再生和还原，增加了信号传输的距离。</p></li><li><p><strong>数据链路层</strong></p><ul><li>封装成帧：将网络信号封装成数据包，在链路层就叫数据帧。</li><li>透明传输：由于链路层会将网络信号添加首部和尾部进行封装，那比如传输的内容和待封装的首部信息一样，那么网络层进行解析就可能搞混乱，因此需要采取一定的措施，让接收方不被误导。（类似js的转义字符<br>这个是标签还是普通字符串）</li><li>差错控制：确保数据传输不会出错</li><li>流量控制：注意，TCP也有流量控制，TCP是端到端的流量控制，链路层是点到点的流量控制。（滑动窗口协议、选择重传协议）</li></ul></li><li><p><strong>网络层</strong></p><p>  网络层主要是将分组从一台主机移动到另一台主机</p><p>  分组交换就是：当<code>主机H1</code>要向另一<code>主机H2</code>发送数据（报文）时，首先将数据划分成若干个<code>等长的分组</code>，然后将这些分组一个接一个地发往里与H1相联的<code>路由A</code> ,当<code>A</code>接到分组后，先放入缓冲区，再按一定的路由算法确定该分组下一步将发注哪个结点，如此一个结点一个结点传递，直到<code>最终目的H2</code>。</p><p>  数据报：是通过网络传输的数据的基本格式</p></li><li><p><strong>传输层</strong></p><p>  传输层是面向计算机进程之间的，端对端的</p><p>  传输层主要协议分为</p><ul><li>UDP 用户数据报协议（无连接）</li><li>TCP 传输控制协议（面向连接）</li></ul><p>  端口：用来找到计算机上运行的各个进程，数值为16位 0-65535</p><p>  端口的分类：</p><ul><li>服务器使用的端口号<ul><li>熟知端口号（系统端口号）0-1023，这些端口号被指派给TCP&#x2F;IP协议下的重要的应用程序。</li><li>登记端口号，这些端口号使用前需要在IANA按照规定的手续进行办理。 1024-49151</li></ul></li><li>客户端使用的端口号 49152-65535 短暂端口号，这类端口号留给进程进行短暂的使用。</li></ul><p>  <strong>UDP</strong></p></li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>底层是TCP协议，确保数据传输的准确性（顺序正确，没有丢包）三次握手四次挥手</p><p><strong>http报文结构包括：起始行+头部+空行+实体</strong></p><ul><li>简单快速</li><li>灵活：允许任意类型的数据对象</li><li>无状态性</li></ul><h3 id="HTTP特点"><a href="#HTTP特点" class="headerlink" title="HTTP特点"></a>HTTP特点</h3><ol><li><p>灵活可扩展：</p><p> 语法限制较为宽泛</p><p> 传输形式多样</p></li><li><p>可靠传输：</p><p> HTTP基于TCP&#x2F;IP，因此更可靠。</p></li><li><p>请求响应：</p><p> 有来有回</p></li><li><p>无状态：</p><p> 无法记录状态信息</p></li></ol><h3 id="HTTP缺点"><a href="#HTTP缺点" class="headerlink" title="HTTP缺点"></a>HTTP缺点</h3><ol><li><p>无状态：</p><p> 主要分场景来看的，在需要长连接场景中，需要保存大量的上下文信息，以免传输大量重复的信息，这时无状态就是HTTP的缺点了。</p><p> 当不需要状态时,大大节省了网络开销，反而是优点。</p></li><li><p>明文传输：</p><p> 比如WIFI陷阱，就是通过HTTP明文传输的性质，疯狂抓取用户信息。</p></li><li><p>队头阻塞问题</p></li></ol><h3 id="起始行"><a href="#起始行" class="headerlink" title="起始行"></a>起始行</h3><p>对于请求报文</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /login <span class="variable constant_">HTTP</span>/<span class="number">1.1</span></span><br></pre></td></tr></table></figure><p>响应报文</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="number">200</span> <span class="variable constant_">OK</span></span><br></pre></td></tr></table></figure><h3 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h3><p>请求头&#x2F;响应头</p><ul><li>大小写不敏感</li><li>字段名不允许出现_或空格</li><li>字段名后面必须接 :</li></ul><h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><p>用来区分头部和实体</p><p>如果在头部之间故意加一个空行：</p><p>那么空行后的内容会被认为是实体</p><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><p>请求体+响应体</p><h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><p><strong>八种</strong></p><ul><li>GET：通常用于获取资源（GET不能对服务器产生副作用）</li><li>POST：向服务器提交数据</li><li>PUT：与POST相似，但是侧重修改</li><li>OPTIONS：列出对特定资源的服务器支持的请求方法</li><li>HEAD：只返回接口的首部</li><li>DELETE：删除资源（很少用到）</li><li>TRACE：追踪请求，常常用于测试</li><li>CONNECT：代理</li></ul><h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3><ul><li><strong>缓存角度：GET会被浏览器缓存，但是POST默认不会</strong></li><li><strong>编码角度：GET只进行URL编码，只支持ASKCII</strong></li><li><strong>参数角度：GET参数外露，不利于进行敏感信息传输</strong></li><li><strong>幂等角度：GET是幂等的，基执行相同操作，结果依然相同</strong></li><li><strong>TCP角度：GET往往是一个数据包发出，而POST一个或两个，依据不同浏览器而定</strong></li><li><strong>爬虫角度：GET会被网络蜘蛛直接访问，因此，不应将不利于服务器的操作用于GET协议。</strong></li></ul><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><ul><li><p><strong>1XX：表示目前协议处理处于中间状态，还需要后续操作。</strong></p><p>  <strong>101</strong> 在HTTP协议准备升级到WS协议时，如果服务器同意变更，则会发送状态码101.</p><p>  <strong>100 continue</strong> </p></li><li><p><strong>2XX：表示成功状态。</strong></p><p>  <strong>200 OK</strong> 成功返回数据，并存在响应体。</p><p>  <strong>204 No Content</strong> 成功返回，但是没有响应体。</p><p>  <strong>206 Partial Content</strong> 返回部分内容，往往适用于分块下载和断点续传，当然·也会带上相应字段Content-Range</p></li><li><p><strong>3XX：重定向状态，资源位置发生变动，需要重新进行请求。</strong></p><p>  <strong>301 Moved Permanently</strong> 永久重定向：网站会做缓存优化，下次再访问则直接跳转到重定向的那个网址。</p><p>  <strong>302 Found</strong> 临时重定向：有网站劫持的风险</p><p>  <strong>304：</strong>当协商缓存命中时会返回这个状态码。</p></li><li><p><strong>4XX：请求报文有误。</strong></p><p>  <a href="https://imgse.com/i/z3mHKI"><img src="https://s1.ax1x.com/2022/11/22/z3mHKI.png" alt="z3mHKI.png"></a></p></li><li><p><strong>5XX：服务端发生错误。</strong></p><p>  <a href="https://imgse.com/i/z3mzGQ"><img src="https://s1.ax1x.com/2022/11/22/z3mzGQ.png" alt="z3mzGQ.png"></a></p></li></ul><h2 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h2><p><strong>URL+URE</strong></p><p>仅支持ASCII码，所有不支持的将被转化为16进制字节值</p><p><a href="https://imgse.com/i/z3nPrq"><img src="https://s1.ax1x.com/2022/11/22/z3nPrq.png" alt="z3nPrq.png"></a></p><h3 id="头部字段"><a href="#头部字段" class="headerlink" title="头部字段"></a>头部字段</h3><ul><li><p><strong>Accept（请求头）</strong></p><p>  用于告知发送方，你支持什么样的接收方式 </p><p>  Accept字段常用的功能有如下四个部分：</p><p>  数据格式、压缩方式、支持语言、字符集</p></li><li><p><strong>Content（响应头）</strong></p><p>  <strong>定长字段</strong></p><p>  Content-Length</p><p>  必须完全符合所发送的字符长度，过长则无法返回，过短则字符串被截取</p><p>  <strong>不定长字段</strong></p><p>  Transfer-Encoding: chunked</p><p>  表示分块传输数据，设置这个字段后Content-Length字段会被自动忽略，基于长连接持续推送动态内容。</p></li></ul><h3 id="两种表单提交的方式"><a href="#两种表单提交的方式" class="headerlink" title="两种表单提交的方式"></a>两种表单提交的方式</h3><ul><li><p>x-www-form-urlencoded</p><p>  其中的数据会被编码成以&amp;分割的键值对</p><p>  字符以URL编码方式编写</p></li><li><p>multipart&#x2F;form-data</p><p>  将不同的表单元素拆分开，且每个单元浏览器会自动添加特定的boundary，对于文件、图片等资源的上传，因为没有必要做URL编码，因此减少消耗，减小占用空间按</p></li></ul><h3 id="队头阻塞问题"><a href="#队头阻塞问题" class="headerlink" title="队头阻塞问题"></a>队头阻塞问题</h3><p>HTTP从1.0版本升级到1.1版本之后，改变了每次请求都需要三次握手四次挥手的繁琐操作，HTTP1.1采用<strong>管道化的方式，允许客户端在已发送请求之后，响应请求之前发送下一个请求</strong>，借此来减少等待时间和吞吐量。</p><p>但是由于管道化的特定需求，服务端响应顺序必须与发送端相对应（FIFO）</p><p><strong>支持管道化的请求必须是幂等请求（GET、OPTION）</strong></p><p>解决办法：</p><ol><li>并发连接，以chrom为例，一个域名下可以存在多个长连接，只需要增加队列数目来解决</li><li>可以采用域名分片，将域名分出多个二级域名</li></ol><h3 id="HTTP1-0和1-1的区别"><a href="#HTTP1-0和1-1的区别" class="headerlink" title="HTTP1.0和1.1的区别"></a>HTTP1.0和1.1的区别</h3><ul><li>连接方面： http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。</li><li>资源请求方面：在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>缓存方面</strong>，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li><li>新增了请求方法</li><li>host字段</li></ul><h3 id="HTTP1-1和2-0的区别"><a href="#HTTP1-1和2-0的区别" class="headerlink" title="HTTP1.1和2.0的区别"></a>HTTP1.1和2.0的区别</h3><ul><li>二进制协议</li><li>多路复用</li><li>数据流</li><li>头信息压缩</li><li>服务器推送</li></ul><h3 id="浏览器输入网址之后发生了什么"><a href="#浏览器输入网址之后发生了什么" class="headerlink" title="浏览器输入网址之后发生了什么"></a>浏览器输入网址之后发生了什么</h3><p>解析URL→查找缓存→DNS→获取MAC地址→TCP三次握手→HTTPS握手(TLS四次握手)→返回数据→解析页面→TCP四次挥手</p><p><strong>TLS加密原理（先非对称后对称加密）</strong></p><p><a href="https://imgse.com/i/z3nMs1"><img src="https://s1.ax1x.com/2022/11/22/z3nMs1.png" alt="z3nMs1.png"></a></p><h3 id="TCP-x2F-IP协议"><a href="#TCP-x2F-IP协议" class="headerlink" title="TCP&#x2F;IP协议"></a>TCP&#x2F;IP协议</h3><p><a href="https://imgse.com/i/z3n8IO"><img src="https://s1.ax1x.com/2022/11/22/z3n8IO.png" alt="z3n8IO.png"></a></p><p>TCP&#x2F;IP协议往往指的是互联网协议的统称</p><p><a href="https://imgse.com/i/z3nNzd"><img src="https://s1.ax1x.com/2022/11/22/z3nNzd.png" alt="z3nNzd.png"></a></p><p>数据处理流程</p><p><a href="https://imgse.com/i/z3nwLt"><img src="https://s1.ax1x.com/2022/11/22/z3nwLt.png" alt="z3nwLt.png"></a></p><p>区分不同的通信</p><p><a href="https://imgse.com/i/z3nDdf"><img src="https://s1.ax1x.com/2022/11/22/z3nDdf.png" alt="z3nDdf.png"></a></p><p>IP</p><p>网络标识+主机标识</p><p>通过网络标识来标记不同网段</p><h2 id="TCP和UDP协议的区别"><a href="#TCP和UDP协议的区别" class="headerlink" title="TCP和UDP协议的区别"></a>TCP和UDP协议的区别</h2><p>UDP：</p><ul><li>无连接协议，想发就发，不会预先打招呼</li><li>有单播、多播、广播的功能，不仅仅支持一对一传输</li><li>面向报文，即UDP对应用层传递过来的报文既不合并也不拆分</li><li>不可靠性，即UDP不会根据网络情况调整发送速率，也不会检查数据包是否发送成功</li><li>头部开销小，仅仅有8字节，相比于TCP头部的至少20字节来说确实小了很多。</li></ul><p>TCP：</p><ul><li>面向连接，发送数据前两端必须事先建立连接。</li><li>仅支持单播</li><li>面向字节流，会将应用层的报文进行拆分以字节流的方式进行发送</li><li>可靠数据传输，能够确定发送顺序，是否丢包，按照当前网络拥塞情况调整发送速度。</li><li>拥塞控制</li><li>全双工通信</li></ul><p><a href="https://imgse.com/i/z3ncWQ"><img src="https://s1.ax1x.com/2022/11/22/z3ncWQ.png" alt="z3ncWQ.png"></a></p><h3 id="TCP重传机制"><a href="#TCP重传机制" class="headerlink" title="TCP重传机制"></a>TCP重传机制</h3><ul><li>基于计时器</li><li>基于ACK确认序号</li></ul><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>三次握手的目的主要是建立TCP连接，确认双发的收发状态，同步发送双方的序列号和确认号，交换TCP窗口大小信息。</p><ul><li>SYN同步位，1表示进行连接请求，0表示不进行</li><li>ACK确认位，1表示确认有效，0表示确认无效</li><li>ack确认号，一般等于对方发送过来的序号+1</li><li>seq序列号，起初是随机的，之后等于对方发送过来的确认号</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML</title>
      <link href="/blog/2022/10/12/%E9%9D%A2%E8%AF%95%E5%A4%87%E6%88%98-HTML/"/>
      <url>/blog/2022/10/12/%E9%9D%A2%E8%AF%95%E5%A4%87%E6%88%98-HTML/</url>
      
        <content type="html"><![CDATA[<h2 id="html标签的类型（head，-body，！Doctype）-他们的作用是什么"><a href="#html标签的类型（head，-body，！Doctype）-他们的作用是什么" class="headerlink" title="html标签的类型（head， body，！Doctype） 他们的作用是什么"></a><strong><strong>html标签的类型（head， body，！Doctype） 他们的作用是什么</strong></strong></h2><p><strong>!Doctype</strong></p><ul><li>声明HTML版本</li></ul><p><strong>Head</strong></p><ul><li>文档的头部，一般不展示给用户看</li><li>meta</li><li>title</li></ul><h2 id="src和href的区别"><a href="#src和href的区别" class="headerlink" title="src和href的区别"></a>src和href的区别</h2><p>src表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src会将其指向的资源下载到对应文档中，例如请求js脚本，img标签，frame等。</p><p>href表示对超文本的引入，用在link和a等元素上，将当前元素与引用资源建立联系。</p><p>src会等待该资源加载完毕之后再加载其他资源，这也是为什么会将js标签放到文档底部。</p><h2 id="HTML语义化"><a href="#HTML语义化" class="headerlink" title="HTML语义化"></a>HTML语义化</h2><p>语义化是指根据标签中的内容的语义，选择合适的标签。例如：header头部、footer尾部、nav导航栏、section区块、main主要区域、article主要内容、aside侧边栏等</p><h2 id="DOCTYPE文档类型的作用"><a href="#DOCTYPE文档类型的作用" class="headerlink" title="DOCTYPE文档类型的作用"></a>DOCTYPE文档类型的作用</h2><p>告诉浏览器应该以什么样的方式解析文档，不同的渲染模式会影响CSS甚至js的解析，它必须声明在文档的第一行。</p><p>例如：标准模式：浏览器按照W3C标准去解析CSS。怪异模式(混杂模式)：IE盒模型、溢出处理不同。</p><h2 id="说一下webworker"><a href="#说一下webworker" class="headerlink" title="说一下webworker"></a>说一下webworker</h2><p>一般浏览器执行js脚本为单线程， web worker是运行在浏览器后台的js，独立于其他脚本，不会影响页面性能，通过postMessage将结构传回主线程，通过onMessage进行消息监听。</p><h2 id="常见meta标签的作用"><a href="#常见meta标签的作用" class="headerlink" title="常见meta标签的作用"></a>常见meta标签的作用</h2><ul><li>keywords</li><li>charset</li><li>authorization作者信息</li><li>description</li><li>robots告诉浏览器索引规则</li><li>viewport</li><li>refresh重定向刷新</li><li>http-equiv&#x3D;”X-UA-Compatible”兼容给IE</li></ul><h2 id="h5的更新"><a href="#h5的更新" class="headerlink" title="h5的更新"></a>h5的更新</h2><ul><li>语义化</li><li>媒体标签</li><li>表单控件</li><li>DOM查询</li><li>web存储</li><li>dragAPI</li><li>canvas</li><li>svg</li></ul><h2 id="WebWorker"><a href="#WebWorker" class="headerlink" title="WebWorker"></a>WebWorker</h2><p>这是一个h5新增的非常好用的api，解决了浏览器js引擎由于单线程导致高计算量场景下的页面卡顿问题。</p><p>主线程</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主线程</span></span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;worker.js&#x27;</span>)</span><br><span class="line"><span class="comment">// 监听worker信息</span></span><br><span class="line">worker.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">messageEvent</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(messageEvent);</span><br><span class="line">    <span class="title function_">alert</span>(<span class="number">11</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监听Worker错误信息</span></span><br><span class="line">worker.<span class="property">onmessageerror</span> = <span class="keyword">function</span> (<span class="params">messageEvent</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(messageEvent)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为worker传递信息</span></span><br><span class="line">worker.<span class="title function_">postMessage</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;start&#x27;</span>, <span class="attr">count</span>: <span class="number">10000000000</span> &#125;); <span class="comment">// 发送信息给worker</span></span><br><span class="line"><span class="comment">// 终止worker</span></span><br><span class="line"><span class="comment">// worker.terminate();</span></span><br></pre></td></tr></table></figure><p>worker线程</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听事件，主线程可以通过 postMessage 发送信息过来</span></span><br><span class="line">self.<span class="property">onmessage</span> = <span class="function">(<span class="params">messageEvent</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="keyword">type</span>, count &#125; = messageEvent.<span class="property">data</span>;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;start&#x27;</span>:</span><br><span class="line">            <span class="comment">// 通过 type 去区分不同的业务逻辑，payload 是传过来的数据</span></span><br><span class="line">            <span class="keyword">let</span>  result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                result += i</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ....,通过一系列处理之后，把最终的结果发送给主线程</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">postMessage</span>(result);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>shareWorker</strong>， 普通worker升级版</p><p>是的跨tab页面通信成为可能</p><h2 id="dragAPI"><a href="#dragAPI" class="headerlink" title="dragAPI"></a>dragAPI</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_Drag_and_Drop_API">HTML 拖放 API - Web API 接口参考 | MDN (mozilla.org)</a></p><h2 id="Canvas和svg的区别"><a href="#Canvas和svg的区别" class="headerlink" title="Canvas和svg的区别"></a>Canvas和svg的区别</h2><p>Canvas使用的是位图，利用像素进行渲染，放大会失真</p><p>SVG是采用矢量图，利用XML描述图形，放大不会失真</p><p>SVG</p><ul><li>不依赖分辨率</li><li>支持事件处理器</li><li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li><li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li><li>不适合游戏应用</li></ul><p>Canvas</p><ul><li>依赖分辨率</li><li>不支持事件处理器</li><li>弱的文本渲染能力</li><li>能够以 .png 或 .jpg 格式保存结果图像</li><li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
